% $Author: CesarBallardini $
% $Date: 2009-12-21 01:54:32 +0100 (Mon, 21 Dec 2009) $
% $Revision: 30012 $

% HISTORY:
% 2006-10-24 - Stef started
% 2006-10-25 - Stef first draft
% 2006-12-07 - Andrew edit
% 2007-06-13 - Andrew revised
% 2007-06-21 - Oscar edit
% 2007-07-26 - Stef review
% 2007-08-23 - Oscar review
% 2007-08-29 - Andrew corrections

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	\renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
\chapter{El modelo de objetos de \st}
\chalabel{model}

El modelo de programaci\'on de \st es simple y uniforme: todo es un objeto, y los objetos se comunican entre si \'unicamente mediante el env\'io de mensajes. 

Sin embargo, esta simplicidad y uniformidad puedes ser una fuente de dificultad para aquellos programadores que est\'an acostumbrados a otros lengujes. En este cap\'itulo, presentamos los conceptos claves del modelo de objetos de \st; en particular discutimos las concequencias de representar clases como objetos.

%=========================================================
\section{Las reglas del modelo}
\seclabel{rules}

El modelo de objetos de \st est\'a basado en un conjunto de reglas simples  que son aplicadas  \emph{de manera uniforme}. Dichas reglas son las siguientes:

\begin{enumerate}[label={\textbf{Rule \arabic{*}}.}, ref={Rule \arabic{*}}, leftmargin=*]
\item{} \rulelabel{everything}
	Todo es un objeto.

\item{} \rulelabel{instance}
	Todo objeto es instancia de una clase.

\item{}  \rulelabel{inheritance}
	Toda clase tiene una superclase.

\item{}  \rulelabel{message}
	Todo ocurre mediante el env\'io de mensajes.

\item{}  \rulelabel{lookup}
	El Method lookup sigue la cadena de herencia.
% VER COMO TRADUZCO ESTO
\end{enumerate}

\noindent
Veamos cada una de estas reglas en detalle.

%=========================================================
\section{Todo es un Objeto}

%\ruleref{everything}

La frase ``todo es un objeto'' es altamente contagiosa.
Despu\'es de poco tiempo trabajando con \st, te sorprender\'as de c\'omo esta regla simplifica todo lo que haces.  
Los n\'umeros enteros, por ejemplo, son objetos verdaderos, por lo tanto puedes enviarles mensajes, tal como lo haces con cualquier otro objeto.


\begin{code}{@TEST}
3 + 4            --> 7    ``env\'\i{}a '+ 4' to 3, yielding 7''
20 factorial  --> 2432902008176640000   "send factorial, yielding a big number"
\end{code}

La representaci\'on de \ct{20 factorial} es ciertamente diferente de la representaci\'on de \ct{7}, pero dado que ambos dos son objetos, ninguno de los dos c\'odigos\,---\,ni siquiera la implementaci\'on de \ct{factorial}\,---\,necesita saber acerca de esto.  

\needlines{3}
Quiz\'as, la consecuencia fundamental de esta regla es lo siguiente:
\important{Las clases son objetos tambi\'en.}

Adem\'as, las clases no son objetos de segundo orden: realmente son objetos de primer orden a los cuales les puedes enviar mensajes, inspeccionar, etc.
Esto significa que \pharo es un sistema verdaderamente reflectivo, lo que da un gran poder de expresi\'on a los desarrolladores.

M\'as produndo en la implementaci\'on, hay tres tipos diferentes de objetos. Existen (1) objetos ordinarios con variables de instancia que son pasadas por referencia, existen (2) \emph{small integers} %VER COMO TRADUZCO ESTO
que son pasados por valor, y existen objetos indexables como arrays % VER COMO TRADUZCO
 que contienen una porci\'on continua de memoria. La belleza de \st es que normalmente no tienes que preocuparte por las diferencias de estos tres tipos de objetos. 


%=========================================================
\section{Todo objeto es instancia de una clase}

%\ruleref{instance}

Todo objeto tiene una clase; puedes averiguar cu\'al envi\'andole el mensaje \ct{class}.

\begin{code}{@TEST}
1 class                 --> SmallInteger
20 factorial class --> LargePositiveInteger
'hello' class          --> ByteString
#(1 2 3) class       --> Array
(4@5) class         --> Point
Object new class --> Object
\end{code}

Una clase define la \emph{estructura} de sus instancias mediante variables de instancia, y el \emph{comportamiento} mediante m\'etodos. Cada m\'etodo tiene un nombre, llamado su \emphsubind{method}{selector}, que es \'unico dentro de su clase. 

Dado que \emph{las clases son objetos}, y que \emph{todo objeto es instancia de una clase}, entonces se deduce que las clases tambi\'en tienen que ser instancias de clases. Una clase cuyas instancias son clases, se llama  \emphind{metaclase}. Siempre que creas una clase, el sistema crea autom\'aticamente la metaclase. 
La metaclase define la estructura y el comportamiento de la clase que es su instancia. 
El 99\% \damien{Did any of you verify it is 99\%? Maybe 'Most' would have been better than '99\%'}de las veces no necesitar\'as pensar en metaclases, y posiblemente, las ignores. 
(Tendremos una mirada m\'as de cerca a metaclases en \charef{metaclasses}.)
%No esta andando el charef

%---------------------------------------------------------
\subsection{Variables de instancia}

Las variables de instancia en \st son privadas a la instancia en si misma. 
Esto es un contraste con \ind{Java} y \ind{C++}, que permiten que las variables de instancia (tambi\'en conocidas como ``campos'', ``atributos'' o incluso ``colaboradores internos'') sean accedidas por otras instancias de la misma clase.  
Decimos que el \emphind{l\'\i{}mite del encapsulamiento} de los objetos en Java y C++ es la clase, mientras que en \st es la instancia.

%QUE HAGO CON ESTO? LO TRADUZCO ?
\seeindex{variable!instance}{instance variable}
\seeindex{field}{instance variable}
\seeindex{attribute}{instance variable}
\seeindex{slot}{instance variable}
\index{instance variable}


En \st dos instancias de la misma clase no pueden acceder a las variables de instancia de la otra a menos que la clase defina ``m\'etodos de \ind{acceso}''.
%Aca tengo que hacer referencia a la palabra en ingles accessor  o getter


No existe sintaxis alguna del lenguaje que provea acceso directo a las variables de instancia de cualquier otro objeto. 
(En realidad, un mecanismo llamado reflexi\'on s\'\i{} 
% pongo reflextion en inges?
provee una forma de pedirle a otro objeto el valor de sus variables de instancia; la meta-programaci\'on es usada para escribir herramientas como el inspector de objetos,
%Menciono el Object inspector en ingles?
 cuyo \'unico prop\'osito es mirar internamente otros objetos.) 


Las variables de instancia pueden ser accedidas por nombre desde cualquier m\'etodo de instancia de la clase que las define y tambi\'en desde los m\'etodos definidos en sus subclases. Esto significa que las variables de instancia de \st son similares a las variables  \emph{protegidas} de C++ y Java.      
%Tengo que traducir el protected variabes
No obstante, preferimos decir que son privadas, pues en \st es considerado un mal estilo acceder directamente a las variables de instancia desde una subclase.  



\subsubsection{Ejemplo}

El m\'etodo \cmind{Point}{dist:} (\mthref{dist:}) computa la distancia entre el receptor y otro punto. Las variabes de instancia \ct{x} e \ct{y} del receptor son accedidas directamente por el cuerpo de m\'etodo. Sin embargo, las variables de instancia del otro punto deben ser accedidas envi\'andole los mensajes \ct{x} e \ct{y}.


%Se traducen los comentarios de los ejemplos de codigo ?
\needlines{7}
\begin{method}[dist:]{la distancia entre dos puntos}
Point>>>dist: aPoint 
	"Answer the distance between aPoint and the receiver."  
	| dx dy |
	dx := aPoint x - x.
	dy :=  aPoint y - y.
	^ ((dx * dx) + (dy * dy)) sqrt
\end{method}

\begin{code}{@TEST}
1@1 dist: 4@5 --> 5.0
\end{code}

La raz\'on clave para preferir encapsulamiento basado en instancias sobre encapsulamiento basado en clases, es que permite que diferentes implementaciones de la misma abstracci\'on puedan coexistir. 

Por ejemplo, el m\'etodo \ct{point>>>dist:} no necesita saber o preocuparse si el argumento \ct{aPoint} es una instancia de la misma clase que el receptor o no. El objeto del argumento podr\'\i{}a estar representado en coordinadas polares, o como un registro en una base de datos, o en otra computadora en un sistema distribuido; mientras pueda responder a los mensajes \ct{x} e \ct{y}, el c\'odigo de \mthref{dist:} va a seguir funcionando correctamente.

%---------------------------------------------------------
\subsection{M\'etodos}

Todos los m\'etodos  son \subind{method}{p\'ublicos}.\footnote{Bueno, en realidad, casi todos. En \pharo, los m\'etodos cuyos selectores empiezan con el prefijo \ct{pvt} son privados: Un mensaje \ct{pvt} puede ser enviado  \emph{solamente} a \self. No obstante, los m\'etodos \ct{pvt} no son muy usados.}
Los m\'etodos son agrupados en protocolos que indican su intenci\'on. 
Algunos nombres de protocolos comunes han sido establecidos por convenci\'on, por ejemplo, \protind{accessing} para todos los m\'etodos de acceso, e \protind{initialization} para crear un estado concistente inicial del objeto. El protocolo \protind{private} se usa a veces para agrupar m\'etodos que no deber\'\i{}an ser vistos desde afuera del objeto. Sin embargo, nada previene que le puedas enviar un mensaje que est\'a implementado como ``privado''.  

Los m\'etodos pueden acceder a todas las variables de instancia del objeto.
Algunos programadores \st prefieren acceder a las variables de instancia \'unicamente mediante m\'etodos de acceso. 
Dicha pr\'actica tiene cierto valor, pero tambi\'en impacta en la interfaz de las clases, y pero a\'un, expone estado privado al mundo.

%---------------------------------------------------------
\subsection{Del lado de instancia y del lado de clase}

Dado que las clases son objetos, tambi\'en tienen sus propias variables de instancia y sus propios m\'etodos.
Llamamos a ellos, \emph{variables de instancia de clase} y \emph{m\'etodos de clase}, pero en realidad no son diferentes a las variables de instancia y m\'etodos ordinarios:
las variables de instancia de clase son s\'olo variables de instancia definidas por una metaclase, y los m\'etodos de clase son simplemente m\'etodos definidos por una  \ind{metaclase}. 

\index{class!instance variable}
\seeindex{variable!class instance}{class, instance variable}
\index{class!method}

Una clase y su \ind{metaclase} son dos clases separadas, a pesar de que la primera es una instancia de la segunda. No obstante, esto es en gran medida irrelevante para el programador:  debe concentrarse en definir el comportamiento de sus objetos y en las clases que los crean. 


\begin{figure}[htb]
\begin{center}
\includegraphics[width=\textwidth]{Color-Buttons}
\caption{Navegando una clase y su metaclase.
% \sd{Do we use Key everywhere in the picture as a legend indicator?}
% \on{sure, wherever appropriate}
\figlabel{Buttons}}
\end{center}
\end{figure}

For esta raz\'on, el navegador \index{browser}  te ayuda a navegar ambas, la clase y su metaclase, como si fueran una sola cosa con dos pesta\~nas: ``\subind{browser}{del lado de instancia}'' y ``\subind{browser}{del lado de clase}'', como se muestra en \figref{Buttons}. 

%Como traduzco clicking ?
Clickeando en el bot\'on \button{instance} navegamos la clase \ct{Color}, \ie puedes navegar los m\'etodos que son ejecutados cuando se le env\'\i{}an mensajes a una instancia de \ct{Color}, como por ejemplo el color azul. Presionando el bot\'on  \button{class} navegamos la clase \ct{Color class}, \ie se pueden ver los m\'etodos que ser\'an ejecutados cuando se le envien mensajes a la clase \ct{Color}  propiamente dicha.
Por ejemplo, \ct{Color blue} env\'\i{}a el mesaje \ct{blue} a la clase \clsind{Color}. Por lo tanto, encontrar\'as el m\'etodo  \ct{blue} definido en el lado de clase de  \ct{Color}, no del lado de instancia. 
\seeindex{class side}{browser!class side}
\seeindex{instance side}{browser!instance side}


\needlines{5}
\begin{code}{@TEST | aColor |}
aColor := Color blue.               "Class side method blue"
aColor        --> Color blue
aColor red  --> 0.0         "Instance side accessor method red"
aColor blue --> 1.0        "Instance side accessor method blue"
\end{code}


%como traduzco template ?
Una clase se define completando el esqueleto propuesto en el  \subind{browser}{lado de instancia}. 
Cuando se acepta esta plantilla, el sistema crea no s\'olo la clase definida, pero tambi\'en la metaclase asociada.

Puede navegar la metaclase clickeando en el bot\'on \button{class}.
La \'unica parte de la plantilla de creaci\'on de la metaclase que tiene sentido editar directamente es la lista de nombres de variables de instancia.

Una vez que una clase fue creada, clickeando en el bot\'on \button{instance} podemos editar y navegar los m\'etodos  que ser\'an pose\'\i{}dos por instancias de esa clase (y de sus subclases). Por ejemplo, podemos ver en la \figref{Buttons} que el m\'etodo \ct{hue} est\'a definido en el lado de instancia de la clase  \ct{Color}.
Por el contrario, el b\'oton  \button{class} permite navegar y editar la metaclase (en este caso \ct{Color class}).

%---------------------------------------------------------
\subsection{M\'etodos de clase} 

Los m\'etodos de clase pueden ser muy \'utiles; puedes navegar \ct{Color class} para ver unos buenos ejemplos.
Ver\'as que hay dos tipos de \subind{class}{m\'etodos} definidos en una clase: aquellos que crean instancias de la clase, como \cmind{Color class}{blue} y aquellos que llevan a cabo una funci\'on de utilidad, como \cmind{Color class}{showColorCube}. 
Esto es lo t\'\i{}pico, aunque ocasionalmente encontrar\'as m\'etodos de clase usados para otra cosa.  

Es conveniente poner los m\'etodos de utilidad \subind{browser}{del lado de clase} porque pueden ser ejecutados sin tener que crear ning\'un objeto primero.
De hecho, la mayor\'\i{}a de ellos tendr\'an un comentario cuyo objetivo es hacer m\'as f\'acil su ejecuci\'on.

\dothis{Navegue el m\'etodo  \ct{Color class>>>showColorCube}, doble click justo adentro de las comillas del comentario  \ct{"Color showColorCube"} y tipee \short{d}.}
Ver\'as el efecto de ejecutar este m\'etodo. (Seleccione \menu{World \go \ind{restore display}~(r)} para deshacer los cambios.)


Para aquellos familiarizados con \ind{Java} y \ind{C++}, los m\'etodos de clase parecieran ser similares a los m\'etodos est\'aticos.
Sin embargo, la uniformidad de \st implica que de alguna forma son distintos: mientras que los m\'etodos est\'aticos de Java son realmente simples procedimientos resueltos est\'aticamente, los m\'etodos de clase de \st son m\'etodos despachados dinamicamente. 
%como traduzco dynamic-dispatteched methods?
Esto significa que la herencia, sobre-escritura y mensajes enviados con super funcionan en los m\'etdos de clase en \st, mientras que no funcionan con los m\'etodos est\'aticos de Java.


%---------------------------------------------------------

\subsection{Variables de instancia de clase}

Con las variables de instancia ordinarias, todas las instancias de una clase tienen el mismo conjunto de nombres de variables, y las instancias de sus subclases heredan esos nombres; no obstante, cada instancia tiene su propio conjunto privado de valores.
%No se como poner el subind aca
La historia es exactamente la misma con las variables de instancia de clase: cada clase tiene sus propias variables de instancia de clase privadas. 
Una subclase heredar\'a esas variables de instancia de clase, \emph{pero tendr\'a sus propias copias de dichas variables}.
As\'\i{} c\'omo los objetos no comparten sus variables de instancia, tampoco las clases ni sus subclases comparten las variables de instancia de clase.

Una variable de instancia de clase llamada \ct{contador} se podr\'\i{}a usar por ejemplo, para llevar la cuenta de cuantas instancias se crean de una clase dada. De todos modos, cada subclase tendr\'a su propia variable \ct{count}, por lo tanto, las instancias de las subclases ser\'\i{}an contadas por separado. 

\paragraph{Ejemplo: las variables de instancia de clase no son compartidas con sus subclases.}
Supongamos que definimos las classes  \ct{Dog} (perro) y \ct{Hyena} (hiena), donde \ct{Hyena} hereda la variable de instancia de clase  \ct{contador} de \ct{Dog}.

\begin{classdef}[dog]{Perros y hienas}
Object subclass: #Dog
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-CIV'

Dog class
	instanceVariableNames: 'count'

Dog subclass: #Hyena
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-CIV'
\end{classdef}

Ahora supongamos que creamos m\'etodos de clase en \ct{Dog} para inicializar su variable \ct{count} a \ct{0}.
\begin{method}[dogcount]{Manteniendo la cuenta de perros nuevos}
Dog class>>>initialize
	super initialize.
	count := 0.

Dog class>>>new
	count := count +1.
	^ super new

Dog class>>>count
	^ count
\end{method}

Ahora cuando creamos un nuevo perro su contador es incrementado, y lo mismo para cada hiena, pero son contados por separado:

\begin{code}{}
Dog initialize.
Hyena initialize.
Dog count     --> 0
Hyena count --> 0
Dog new.
Dog count     --> 1
Dog new.
Dog count     --> 2
Hyena new.
Hyena count --> 1
\end{code}
% ON: In order to make this a test, I need the previous code to be part of the setup. Bleh.

Note tambi\'en que las variables de instancia de clase son privadas a la clase extactamente de la misma forma en que las variables de instancia son privadas a la instancia. 
Dado que las clases y sus instancias son diferentes objetos, existen las siguientes inmediatas consecuencias:
\important{Una clase no tiene acceso a las variables de instancia de sus propias instancias.}
\important{Una instancia de una clase no tiene acceso a las variables de instancia de clase de su propia clase.}
%No se como poner el subind aca
Por esta raz\'on, los m\'etodos de inicializaci\'on de instancia deber ser definidos siempre en el lado de instancia del navegador
\,---\,el lado de clase del navegador no tiene acceso a las variables de instancia, por lo tanto no las puede inicializar! 

De manera similar, las instancias puede acceder a las variables de instancia de clase solamente de forma indirecta, enviando un mensaje de acceso a sus clases. 

\ind{Java} no tiene nada equivalente a las variables de instancia de clase. 
Las variables est\'aticas de Java y \ind{C++} son m\'as parecidas a las variables de clase de \st, que discutiremos en la \secref{classVars}: todas las subclases y todas sus instancias comparten la misma variable est\'atica.


%Traduzco Singleton ? como ?
\paragraph{Ejemplo: Definiendo un Singleton.}
El \ind{patr\'on Singleton}~\cite{Alpe98a} provee un t\'\i{}pico ejemplo del uso de variables de instancia de clase y de m\'etodos de clase.
Imagine que quisi\'eramos implementar la clase \ct{WebServer} y usar el patr\'on Singleton para asegurarnos que tenga una \'unica instancia. 

Clickeando en el bot\'on \button{instance} del navegador, definimos la clase \clsind{WebServer} como sigue (\clsref{singleton}). 

\begin{classdef}[singleton]{Una clase singleton}
Object subclass: #WebServer
	instanceVariableNames: 'sessions' 	
	classVariableNames: '' 	
	poolDictionaries: '' 	
	category: 'Web'
\end{classdef}

Luego, clieckeando en el bot\'on \button{class}, agregamos la variable de instancia \ct{uniqueInstance} \subind{browser}{del lado de clase}

\begin{classdef}[webserver]{El lado de clase de la clase singleton}
WebServer class 	
	instanceVariableNames: 'uniqueInstance'
\end{classdef}

La consequencia de esto es que la clase \ct{WebServer} ahora tiene otra variable de instancia, 
adem\'as de las variables de instancia que hereda, como \ct{superclass} y \ct{methodDict}.


%Habria que cambiar el mthref para que lo imprima en espaniol
Ahora podemos definir un \subind{class}{m\'etodo} de clase llamado \ct{uniqueInstance} como se muestra en el \mthref{uniqueInstance}.
Este m\'etodo primero chequea si  \ct{uniqueInstance} ha sido inicializada o no.
Si no lo fue, el m\'etodo crea una instancia y la asigna a la variable de instancia de clase  \ct{uniqueInstance}.  
Finalmente el valor de \ct{uniqueInstance} es retornado.
Como  \ct{uniqueInstance} es una variable de instancia de clase, \'este m\'etodo puede acceder a ella directamente. 

    
\begin{method}[uniqueInstance]{uniqueInstance (en el lado de clase)}
WebServer class>>>uniqueInstance
     uniqueInstance ifNil: [uniqueInstance := self new].
     ^ uniqueInstance
\end{method}

La primera vez que \ct{WebServer uniqueInstance} es ejecutado, una instancia de la clase \ct{WebServer}  ser\'a creada y asignada a la variable \ct{uniqueInstance}.
La pr\'oxima vez, la instancia creada previamente ser\'a retornada, en lugar de crear una nueva. 


Note que el c\'odigo de creaci\'on de instancias adentro del condicional en el \mthref{uniqueInstance} est\'a escrito como \ct{self new}  y no como \ct{WebServer new}.
?`Cu\'al es la diferencia?   Dado que el m\'etodo \ct{uniqueInstance} est\'a definido en la \ct{clase WebServer}, podr\'\i{}a pensarse que ambas son iguales. De hecho, hasta que alguien cree una subclase de \lct{WebServer}, son iguales. Pero supongamos que \ct{ReliableWebServer} es una subclase de  \ct{WebServer}, y hereda el m\'etodo \ct{uniqueInstance}. Esperar\'\i{}amos claramente que \ct{ReliableWebServer uniqueInstance} responda un \lct{ReliableWebServer}. Usando \self nos aseguramos de que as\'\i{} sea, pues ser\'a ligado con la correspondiente clase. 
Note tambi\'en que \ct{WebServer} y \ct{ReliableWebServer} van a tener, cada uno, sus propias variables de instancia de clase llamadas
\ct{uniqueInstance}.  Esas dos variables van a tener obviamente distintos valores.


%=========================================================
\section{Toda clase tiene una superclase}

%\ruleref{inheritance}

Cada clase en \st hereda su comportamiento y la descripci\'on de su estructura de una \'unica \emphind{superclase}.
Esto significa que \st tiene \ind{herencia} simple.

\needlines{2}
\begin{code}{@TEST}
SmallInteger superclass --> Integer
Integer superclass          --> Number
Number superclass        --> Magnitude
Magnitude superclass    --> Object
Object superclass           --> ProtoObject
ProtoObject superclass  --> nil
\end{code}


Tradicionalmente la raiz de la jerarqu\'\i{}a de herencia en \st es la clase \clsind{Object} (dado que todo es un objeto).
En \pharo, la raiz es en realidad una clase llamada \clsind{ProtoObject}, aunque normalmente no prestar\'as atenci\'on a esta clase. 
\ct{ProtoObject} encapsula el conjunto de mensajes m\'\i{}nimos que todos los objetos \emph{deben} tener. Sin embargo, la mayor\'\i{}a de las clases heredan de \ct{Object}, quien define varios mensajes adicionales que casi todos los objetos deber\'\i{}an entender y responder.
A menos que tengas una muy buena raz\'on para hacer lo contrario, cuando crees clases para aplicaciones deber\'\i{}an normalmente 
heredar de  \ct{Object}, o de una de sus subclases.


\dothis{Una nueva clase es creada normalmente enviando el mensaje
\ct{subclass: instanceVariableNames: ...}
a una clase existente.
Hay tambi\'en algunos otros m\'etodos para crear clases.
Puedes observar el protocolo \prot{Kernel-Classes \go Class \go subclass creation} para ver cuales son.}
\scatindex{Kernel-Classes}
\protindex{creation}	

%There is no special syntax for creating abstract classes in \st.
%An abstract class is an ordinary class in which the implementation of some methods is deferred to a subclass.
%This is repeated in the next section

Aunque \pharo no provee m\'ultiple herencia, s\'\i{} soporta una mecanismo llamado \emphind{trait}{}s para compartir comportamiento entre clases no relacionadas.
Traits son colecciones de m\'etodos que pueden ser reutilizados por m\'ultiples cases que no est\'an relacionadas por la herencia. Usando traits uno puede compartir c\'odigo entre diferentes clases sin duplicaci\'on de c\'odigo.


%---------------------------------------------------------
\subsection{M\'etodos abstractos y clases abstractas}

Una clase \subind{clase}{abstracta}  es una clase que existe para ser subclasificada, m\'as que instanciada. 
Una clase abstracta es usualmente incompleta, en el sentido de que no define todos los m\'etodos que usa. 
Todos esos m\'etodos que le faltan\,---\,aquellos que otros m\'etodos asumen, pero que no est\'an definidos en si mismos\,---\, son llamados m\'etodos \subind{m\'etodo}{abstractos}. 
\seeindex{clase abstracta}{clase, abstracta}
\seeindex{m\'etodo abstracto}{m\'etodo, abstracto}


\st no tiene una sintaxis dedicada para especificar que un m\'etodo o clase es abstracta. 
Por convenci\'on, el cuerpo de un m\'etodo abstracto conciste en la expresi\'on \mbox{\ct{self subclassResponsibility}.} 
Este es un conocido ``Marker Method'', e indica que las subclases tienen la responsabilidad de definir una versi\'on concreta del m\'etodo.
Los m\'etodos \ct{self subclassResponsibility} deber\'\i{}an ser siempre sobreescritos, y por lo tanto nunca deber\'\i{}an ser ejecutados.
Si te olvidas de sobreescribir alguno, y es ejecutado, una excepci\'on ser\'a lanzada. 
\cmindex{Object}{subclassResponsibility}


Una clase es considerada abstracta si al menos uno de sus m\'etodos es abstracto.
En realidad, nada te previene de crear una instancia de una clase abstracta: todo va a andar bien hasta que un m\'etodo abstracto sea invocado. 


\subsubsection{Ejemplo: la clase \ct{Magnitude}.}


\clsind{Magnitude} is an abstract class that helps us to  define objects that can be compared to each other. Subclasses of \ct{Magnitude} should implement the methods \ct{<}, \ct{=} and \ct{hash}. Using such messages \ct{Magnitude} defines other methods such as \ct{>}, \ct{>=}, \ct{<=}, \ct{max:}, \ct{min:} \ct{between:and:} and others for comparing objegraphses. The method \mthind{Magnitude}{<} is abstract and defined as shown in \mthref{MagnitudeLessThan}.


\clsind{Magnitude} es una clase abstracta que nos ayuda a definir objetos que pueden ser comparados con otros. Las subclases de \ct{Magnitude} deber\'\i{}an implementar los m\'etodos \ct{<}, \ct{=} and \ct{hash}. Usando esos mensajes \ct{Magnitude} define otros m\'etodos como \ct{>}, \ct{>=}, \ct{<=}, \ct{max:}, \ct{min:} \ct{between:and:} y otros para comparar grafos de objetos.  El m\'etodo  \mthind{Magnitude}{<}  es abstracto y definido como se muestra en  \mthref{MagnitudeLessThan}.


\begin{method}[MagnitudeLessThan]{\ct{Magnitude>>><}}
Magnitude>>>< aMagnitude 
	"Answer whether the receiver is less than the argument."
	^self subclassResponsibility
\end{method}

\noindent
Por el contrario, el m\'etodo \mthind{Magnitude}{>=} es concreto; est\'a definido en t\'erminos de \ct{<}:


\begin{method}[Magnitude>=]{\ct{Magnitude>>>>=}}
>= aMagnitude 
	"Answer whether the receiver is greater than or equal to the argument."
	^(self < aMagnitude) not
\end{method}

Lo mismo sucede con los otros m\'etodos de comparaci\'on.

\clsind{Character} es una subclase de \ct{Magnitude}; sobreescribe el m\'etodo \mthind{Object}{subclassResponsibility} de \ct{<} con su propia versi\'on de \ct{<} (mirar \mthref{CharacterLessThan}).  \ct{Character} tambi\'en define los m\'etodos \ct{=} y \ct{hash}; hereda de \ct{Magnitude} los m\'etodos \ct{>=}, \ct{<=}, \ct{~=} entre otros.


\begin{method}[CharacterLessThan]{\ct{Character>>><}}
Character>>>< aCharacter 
	"Answer true if the receiver's value < aCharacter's value."
	^self asciiValue < aCharacter asciiValue
\end{method}



%---------------------------------------------------------
\subsection{Traits}
Un \emphind{trait} es una colecci\'on de m\'etodos que pueden ser incluidos en el comportamiento de una clase sin la necesidad de la herencia. Esto permite facilmente que las clases tengan una \'unica superclase, pero que tambi\'en puedan compartir m\'etodos con otras clases con las que no est\'an relacionadas.

Para definir un nuevo trait, simplemente remplaza la plantilla de creaci\'on de subclases, enviando un mensaje a la clase \clsind{Trait}.

\needspace{5\baselineskip}
\begin{classdef}[tauthor]{Defining a new trait}
Trait named: #TAuthor
	uses: { }
	category: 'PBE-LightsOut'
\end{classdef}

\noindent
Ac\'a definimos el trait \ct{TAuthor} en la categor\'\i{}a \scat{PBE-LightsOut}.
Este trait no \emph{usa} ning\'un otro trait existente.
En general siempre podemos especificar la expresi\'on de composici\'on de un trait, de otros traits para usar como parte del argumnento de palabra clave \ct{uses:}.


Los traits pueden contener m\'etodos pero no variables de instancia.
Supongamos que queremos agregar un m\'etodo \ct{author} a varias clases, independientemente de la herencia. 
Podr\'\i{}amos hacerlo de la siguiente manera:


\begin{method}[author]{An author method}
TAuthor>>>author
    "Returns author initials"
	^ 'on'    "oscar nierstrasz"
\end{method}

\
\noindent
Ahora podemos usar este trait en una clase que ya tiene su propia superclase, por ejemplo en la clase \ct{LOGame} que definimos en \charef{firstApp}.
Simplemente modificamos la plantilla de creaci\'on de clases de  \ct{LOGame} para incluir la palabra clave  \ct{uses:}  que especifica que \ct{TAuthor} deber\'\i{}a ser usado.



\begin{classdef}[sbegamewithtrait]{Using a trait}
BorderedMorph subclass: #LOGame
	uses: TAuthor
	instanceVariableNames: 'cells'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-LightsOut'
\end{classdef}

Como es esperado, si ahora instanciamos un \ct{LOGame}, dicho objeto reponder\'a al mensaje  \ct{author}  de forma correcta.

\begin{code}{}
LOGame new author --> 'on'
\end{code}

Trait composition expressions may combine multiple traits using the \ct{+} operator.
In case of conflicts (\ie if multiple traits define methods with the same name), these conflicts can be resolved by explicitly removing these methods (with \ct{-}), or by redefining these methods in the class or trait that you are defining.
It is also possible to \emph{alias} methods (with \ct{@}), providing a new name for them.

Traits are used in the system kernel.
One good example is the class \mbox{\clsind{Behavior}.}

\needlines{8}
\begin{classdef}[behaviorwithtraits]{\ct{Behavior} defined using traits}
Object subclass: #Behavior
	uses: TPureBehavior @ {#basicAddTraitSelector:withMethod:->#addTraitSelector:withMethod:}
	instanceVariableNames: 'superclass methodDict format'
	classVariableNames: 'ObsoleteSubclasses'
	poolDictionaries: ''
	category: 'Kernel-Classes'
\end{classdef}
\noindent
Here we see that the method \ct{addTraitSelector:withMethod:} defined in the trait \ct{TPureBehavior} has been aliased to \ct{basicAddTraitSelector:withMethod:}.
Support for traits is currently being added to the browsers.

%=========================================================
\section{Everything happens by sending messages}

%\ruleref{message}

This rule captures the essence of programming in \st.

In procedural programming, the choice of which piece of code to execute when a procedure is called is made by the caller.
The caller chooses the procedure or function to execute \emph{statically}, by name.  

In object-oriented programming, we do \emph{not} ``call methods'': we ``\subind{message}{send} messages.''
The choice of terminology is significant.
Each object has its own responsibilities.
We do not \emph{tell} an object what to do by applying some procedure to it.
Instead, we politely \emph{ask} an object to do something for us by sending it a message.
The message is \emph{not} a piece of code: it is nothing but a name and a list of arguments.
The receiver then decides how to respond by selecting its own \emph{method} for doing what was asked.
Since different objects may have different methods for responding to the same message, the method must be chosen \emph{dynamically}, when the message is received.
\begin{code}{@TEST}
3 + 4         --> 7          "send message + with argument 4 to integer  3"
(1@2) + 4 --> 5@6    "send message + with argument 4 to point (1@2)"
\end{code}
\noindent
As a consequence, we can send the \emph{same message} to different objects, each of which may have \emph{its own method} for responding to the message.
We do not tell the \ct{SmallInteger} \ct{3} or the \ct{Point} \ct{1@2} how to respond to the message \ct{+ 4}.
Each has its own method for \ct{+}, and responds to \ct{+ 4} accordingly.

One of the consequences of \st's model of message sending is that it encourages a style in which objects tend to have very small methods and delegate tasks to other objects, rather than implementing huge, procedural methods that assume too much responsibility.
Joseph Pelrine
\ab{Citation?}
\on{sorry, just personal communication and my own lecture notes!}
expresses this principle succinctly as follows:
\important{Don't do anything that you can push off onto someone else.}
\index{Pelrine, Joseph}

Many object-oriented languages provide both static and dynamic operations for objects; in \st there are only dynamic message sends. Instead of providing static class operations, for instance, classes are objects and we simply send messages to classes.

\emph{Nearly} everything in \st happens by sending messages.
At some point action must take place:
\begin{itemize}
  \item \emph{Variable declarations} are not message sends.
  		In fact, variable \subind{variable}{declaration}{}s are not even executable.
  		Declaring a variable just causes space to be allocated for an object reference.
  \item \emph{Assignments} are not message sends.
  		An \ind{assignment} to a variable causes that variable name to be freshly bound in the scope of its definition.
  \item \emph{Returns} are not message sends.
  		A \ind{return} simply causes the computed result to be returned to the sender.
  \item \emph{Primitives} are not message sends.
  		They are implemented in the \ind{virtual machine}.
		\index{primitive}
\end{itemize}
Other than these few exceptions, pretty much everything else does truly happen by sending messages.
In particular, since there are no ``public fields'' in \st, the only way to update an \ind{instance variable} of another object is to send it a message asking that it update its own field.
Of course, providing setter and getter methods for all the instance variables of an object is not good object-oriented style.
Joseph Pelrine also states this very nicely:
\important{Don't let anyone else play with your data.}

%=========================================================
\section{Method lookup follows the inheritance chain} 

%\ruleref{lookup}

What exactly happens when an object receives a message?

The process is quite simple:
the class of the receiver looks up the method to use to handle the message.
If this class does not have a method, it asks its \ind{superclass}, and so on, up the \ind{inheritance} chain.
When the method is found, the arguments are bound to the parameters of the method, and the \ind{virtual machine} executes it.
\index{method!lookup}

It is essentially as simple as this.
Nevertheless there are a few questions that need some care to answer:

\begin{itemize}
  \item \emph{What happens when a method does not explicitly return a value?}
  \item \emph{What happens when a class reimplements a superclass method?}
  \item \emph{What is the difference between \pvind{self} and \pvind{super} sends?}
  \item \emph{What happens when no method is found?}
\end{itemize}

The rules for method lookup that we present here are conceptual: virtual machine implementors use all kinds of tricks and optimizations to speed-up method lookup. 
That's their job, but you should never be able to detect that they are doing something different from our rules.
% Whatever the implementation does, these rules will give you a clear understanding of the semantics of sending messages to \self and \super.

First let us look at the basic lookup strategy, and then consider these further questions.

%---------------------------------------------------------
\subsection{Method lookup}
Suppose we create an instance of \ct{EllipseMorph}.
\begin{code}{@TEST | anEllipse |}
anEllipse := EllipseMorph new.
\end{code}
\noindent
If we now send this object the message \ct{defaultColor}, we get the result \ct{Color yellow}:
\begin{code}{@TEST | anEllipse | anEllipse := EllipseMorph new.}
anEllipse defaultColor --> Color yellow
\end{code}
\noindent
The class \ct{EllipseMorph} implements \ct{defaultColor}, so the appropriate method is found immediately.

\begin{method}[defaultColor]{A locally implemented method}
EllipseMorph>>>defaultColor
	"answer the default color/fill style for the receiver"
	^ Color yellow
\end{method}
\cmindex{EllipseMorph}{defaultColor}

In contrast, if we send the message \ct{openInWorld} to \ct{anEllipse}, the method is not immediately found, since the class \ct{EllipseMorph} does not implement \ct{openInWorld}.
The search therefore continues in the superclass, \lct{BorderedMorph}, and so on, until an \ct{openInWorld} method is found in the class \ct{Morph} (see \figref{openInWorldLookup}).

\begin{method}[openInWorld]{An inherited method}
Morph>>>openInWorld
	"Add this morph to the world."

	self openInWorld: self currentWorld
\end{method}
\cmindex{Morph}{openInWorld}

\begin{figure}[htb]
\begin{center}
	{\includegraphics[width=0.8\textwidth]{openInWorldLookup}}
\caption{Method lookup follows the inheritance hierarchy.\figlabel{openInWorldLookup}}
\end{center}
\end{figure}

%---------------------------------------------------------
\subsection{Returning self}

Notice that \ct{EllipseMorph>>>defaultColor} (\mthref{defaultColor}) explicitly returns \ct{Color yellow} whereas \ct{Morph>>>openInWorld} (\mthref{openInWorld}) does not appear to return anything.

Actually a method \emph{always} answers a message with a value\,---\,which is, of course, an object.
The answer may be defined by the \ct{^} construct in the method, but if execution reaches the end of the method without executing a \ct{^}, the method still answers a value: it answers the object that received the message.
We usually say that the method ``answers \self'', because in Smalltalk the pseudo-variable \self represents the receiver of the message, rather like \ct{this} in \ind{Java}.
\index{variable!pseudo}
\index{return}
\seeindex{caret}{return}

This suggests that \mthref{openInWorld} is equivalent to \mthref{openInWorldReturnSelf}:

\needlines{5}
\begin{method}[openInWorldReturnSelf]{Explicitly returning self}
Morph>>>openInWorld
	"Add this morph to the world."
	
    self openInWorld: self currentWorld
	^ self		"Don't do this unless you mean it!"
\end{method}

Why is writing \ct{^ self} explicitly not a good thing to do?
Well, when you return something explicitly, you are communicating that you are returning something of interest to the sender.
When you explicitly return \self, you are saying that you expect the sender to use the returned value.
This is not the case here, so it is best not to explicitly return \self.

This is a common idiom in \st, which Kent Beck refers to as ``Interesting return value'' \cite{Beck97a}:
\index{Beck, Kent}

\important{Return a value only when you intend for the sender to use the value.}

%---------------------------------------------------------
\subsection{Overriding and extension}

If we look again at the \ct{EllipseMorph} class hierarchy in \figref{openInWorldLookup}, we see that the classes \ct{Morph} and \mbox{\ct{EllipseMorph}} both implement \ct{defaultColor}.
In fact, if we open a new morph (\ct{Morph new openInWorld}) we see that we get a blue morph, whereas an ellipse will be yellow by default.
\index{method!overriding}
\index{method!extension}
\seeindex{overriding}{method, overriding}
\seeindex{extension}{method, extension}

We say that \ct{EllipseMorph} \emph{overrides} the \ct{defaultColor} method that it inherits from \ct{Morph}.
The inherited method no longer exists from the point of view of \ct{anEllipse}.

Sometimes we do not want to override inherited methods, but rather \emph{extend} them with some new functionality, that is, we would like to be able to invoke the overridden method \emph{in addition to} the new functionality we are defining in the subclass.
In \st, as in many object-oriented languages that support single inheritance, this can be done with the help of \super sends.

The most important application of this mechanism is in the \ct{initialize} method.
Whenever a new instance of a class is initialized, it is critical to also initialize any inherited instance variables.
However, the knowledge of how to do this is already captured in the \ct{initialize} methods of each of the superclass in the inheritance chain.
The subclass has no business even trying to initialize inherited instance variables!

It is therefore good practice whenever implementing an initialize method to send \ct{super initialize} before performing any further \ind{initialization}:
\index{super!initialize}

\needlines{6}
\begin{method}[morphinit]{Super initialize}
BorderedMorph>>>initialize
	"initialize the state of the receiver"
	super initialize.
	self borderInitialize
\end{method}

\important{An \ct{initialize} method should always start by sending \ct{super initialize}.}

%---------------------------------------------------------
\subsection{Self sends and super sends}

We need \super \subind{super}{send}{}s to compose inherited behaviour that would otherwise be overridden.
The usual way to compose methods, whether inherited or not, however, is by means of \self \subind{self}{send}{}s.

How do \self sends differ from \super sends?
Like \self, \super represents the receiver of the message.
The only thing that changes is the \ind{method lookup}.
Instead of lookup starting in the class of the receiver, it starts in the superclass of the class of the method where the \super send occurs.

Note that \super is \emph{not} the superclass!
It is a common and natural mistake to think this.
It is also a mistake to think that lookup starts in the superclass of the receiver.
We shall see with the following example precisely how this works.

Consider the message \ct{constructorString}, which we can send to any morph:
\begin{code}{@TEST | anEllipse | anEllipse := EllipseMorph new.}
anEllipse constructorString --> '((EllipseMorph newBounds: (0@0 corner: 50@40) color: Color yellow) setBorderWidth: 1 borderColor: Color black)'
\end{code}
The return value is a string that can be evaluated to recreate the morph.

How exactly is this result obtained through a combination of \self and \super sends?
First, \ct{anEllipse constructorString} will cause the method \ct{constructorString} to be found in the class \ct{Morph},
as shown in \figref{constructorStringLookup}.

\begin{figure}[htb]
\begin{center}
\ifluluelse
	{\includegraphics[width=\textwidth]{constructorStringLookup}}
	{\includegraphics[width=0.8\textwidth]{constructorStringLookup}}
\caption{\self and \super sends\figlabel{constructorStringLookup}}
\end{center}
\end{figure}

\needlines{2}
\begin{method}[constructorString]{A \self send}
Morph>>>constructorString
	^ String streamContents: [:s | self printConstructorOn: s indent: 0].
\end{method}
The method \cmind{Morph}{constructorString} performs a \self send of \lct{printConstructorOn:indent:}.
This message is also looked up, starting in the class \lct{EllipseMorph}, and found in \ct{Morph}.
This method in turn does a \self send of \lct{printConstructorOn:indent:nodeDict:}, which does a \self send of \ct{fullPrintOn:}.
Once again, \ct{fullPrintOn:} is looked up starting in the class \ct{EllipseMorph}, and \mthind{BorderedMorph}{fullPrintOn:} is found in \ct{BorderedMorph} (see \figref{constructorStringLookup} once again).
What is critical to notice is that the \self send causes the method lookup to start again in the class of the receiver, namely the class of \ct{anEllipse}.

\important{A \self send triggers a \emph{dynamic} method lookup starting in the class of the receiver.}

\needlines{4}
\begin{method}[fullPrintOn]{Combining \super and \self sends}
BorderedMorph>>>fullPrintOn: aStream
	aStream nextPutAll: '('.
	!\textbf{super fullPrintOn: aStream.}!
	aStream nextPutAll: ') setBorderWidth: '; print: borderWidth;
		nextPutAll: ' borderColor: ' , (self colorString: borderColor)
\end{method}
At this point, \ct{BorderedMorph>>>fullPrintOn:} does a \super send to extend the 
\ct{fullPrintOn:} behaviour it inherits from its superclass.
Because this is a \super send, the lookup now starts in the superclass of the class where the \super send occurs, namely in \ct{Morph}.
We then immediately find and evaluate \ct{Morph>>>fullPrintOn:}.

Note that the \super lookup did not start in the superclass of the receiver.
This would have caused lookup to start from \ct{BorderedMorph}, resulting in an infinite loop!

\important{A \super send triggers a \emph{static} method lookup starting in the superclass of the class of the method performing the \super send.}

If you think carefully about \super send and \figref{constructorStringLookup}, you will realize that \super bindings are static: all that matters is the class in which the text of the \super send is found.
By contrast, the meaning of \self is dynamic: it always represents the receiver of the currently executing message. This means that  \emph{all}  messages sent to \self are looked-up by starting in the receiver's class.

%---------------------------------------------------------
\subsection{Message not understood}

What happens if the method we are looking for is not found?
\index{message!not understood}

Suppose we send the message \ct{foo} to our ellipse.
First the normal method lookup would go through the inheritance chain all the way up to \clsind{Object} (or rather \clsind{ProtoObject}) looking for this method.
When this method is not found, the \ind{virtual machine} will cause the object to send \ct{self doesNotUnderstand: #foo}.
(See \figref{fooNotFound}.)

\begin{figure}[htb]
\begin{center}
\ifluluelse
	{\includegraphics[width=\textwidth]{fooNotFound}}
	{\includegraphics[width=0.8\textwidth]{fooNotFound}}
\caption{Message \lct{foo} is not understood\figlabel{fooNotFound}}
\end{center}
\end{figure}

Now, this is a perfectly ordinary, dynamic message send, so the lookup starts again from the class \ct{EllipseMorph}, but this time searching for the method \ct{doesNotUnderstand:}.
As it turns out, \ct{Object} implements \ct{doesNotUnderstand:}.
This method will create a new \ct{MessageNotUnderstood} object which is capable of starting a Debugger in the current execution context.

Why do we take this convoluted path to handle such an obvious error?
Well, this offers developers an easy way to intercept such errors and take alternative action.
One could easily override the method \mthind{Object}{doesNotUnderstand:} in any subclass of \ct{Object} and  provide a different way of handling the error.

In fact, this can be an easy way to implement automatic delegation of messages from one object to another.
A \ct{Delegator} object could simply delegate all messages it does not understand to another object whose responsibility it is to handle them, or raise an error itself!

%=========================================================
\section{Shared variables}

Now we will look at an aspect of \st that is not so easily covered by our five rules: \subind{variable}{shared} variables.

\st provides three kinds of shared variables: (1) \emph{globally} shared variables; (2) variables shared between instances and classes (\emph{class variables}), and (3) variables shared amongst a group of  classes (\emph{pool variables}).  The names of all of these shared variables start with a capital letter, to warn us that they are indeed shared between multiple objects.
\index{variable!global}
\index{class!variable}
\index{variable!pool}

%---------------------------------------------------------
\subsection{Global variables}
In \pharo, all global variables are stored in a namespace called \glbind{Smalltalk}, which is implemented as an instance of the class \clsind{SystemDictionary}.
Global variables are accessible everywhere. 
Every class is named by a global variable; in addition, a few globals are used to name special or commonly useful objects.

The variable \glbind{Transcript} names an instance of \clsind{TranscriptStream}, a stream that writes to a scrolling window.
The following code displays some information and then goes to the next line in the \ct{Transcript}.

\begin{code}{}
Transcript show: 'Pharo is fun and powerful' ; cr
\end{code}

\noindent
Before you \menu{do it}, open a transcript by selecting \menu{World \go Tools \ldots \go Transcript}.

\hint{Writing to the Transcript is slow, especially when the transcript window is open. 
So, if you experience some sluggishness and are writing to the Transcript, think about collapsing it.}

\subsubsection{Other useful global variables}

\begin{itemize}
\item
\ct{Smalltalk} is the instance of \ct{SystemDictionary} that defines all of the globals\,---\,including \ct{Smalltalk} itself.   
The keys to this dictionary are the symbols that name the global objects in \st code.
So, for example,
\begin{code}{@TEST}
Smalltalk at: #Boolean --> Boolean
\end{code}
Since \ct{Smalltalk} is itself a global variable,
\begin{code}{}
Smalltalk at: #Smalltalk-->a SystemDictionary(lots of globals)}
\end{code} 
and
\begin{code}{@TEST}
(Smalltalk at: #Smalltalk) == Smalltalk --> true
\end{code}

\item \clsind{Sensor} is an instance of \clsind{EventSensor}, and represents input to \pharo.
For example, \lct{Sensor keyboard} answers the next character input on the keyboard, and \ct{Sensor leftShiftDown} answers \ct{true} if the left shift key is being held down, while \ct{Sensor mousePoint} answers a \ct{Point} indicating the current mouse location.

\item \glbind{World} is an instance of \clsind{PasteUpMorph} that represents the screen.
\ct{World bounds} answers a rectangle that defines the whole screen space; all Morphs on the screen are submorphs of \ct{World}.
\index{Morphic}

\item 
\glbind{ActiveHand} is the current instance of \clsind{HandMorph}, the graphical representation of the cursor.  \ct{ActiveHand}'s submorphs hold anything being dragged by the mouse.
\ab{I have never used this, and had to browse the image to see what it is!  What do you use it for?}

\item
\glbind{Undeclared} is another dictionary\,---\,it contains all the undeclared variables.
If you write a method that references an undeclared variable, the browser will normally
prompt you to declare it, for example, as a global or as an instance variable of the class.
However, if you later delete the declaration, the code will then reference an undeclared variable.
Inspecting \ct{Undeclared} can sometimes help explain strange behaviour!

\item
\glbind{SystemOrganization} is an instance of \clsind{SystemOrganizer}: it records the organization of classes into packages.  More precisely, it categorizes the \emph{names} of classes, so
\end{itemize}

\begin{code}{@TEST}
SystemOrganization categoryOfElement: #Magnitude --> #'Kernel-Numbers'
\end{code}

Current practice is to strictly limit the use of global variables; it is usually better to use class instance variables or class variables, and to provide class methods to access them.  Indeed, if \pharo were to be implemented from scratch today, most of the global variables that are not classes would be replaced by singletons.

The usual way to define a global is just to \menu{do it} on an assignment to a capitalized but undeclared identifier.  The parser will then offer to declare the global for you.  If you want to define a global programmatically, just execute \ct{Smalltalk at: #AGlobalName put: nil}.  To remove it, execute \ct{Smalltalk removeKey: #AGlobalName}.
\glbindex{Smalltalk}

%---------------------------------------------------------
\subsection{Class variables}
\seclabel{classVars}

Sometimes we need to share some data amongst all the instances of a 
class and the class itself.
This is possible using \emph{class variables}. 
The term class \subind{class}{variable} indicates that the lifetime of the variable is the same as that of the class. However, what the
term does not convey is that these variables are shared amongst all the instances of a class as well as the class itself,
as shown in \figref{privateSharedVar}.
Indeed, a better name would have been \emph{shared variables} since this expresses more clearly their role, and also warns of the danger of using them, particularly if they are modified.

\begin{figure}[htb]
\begin{center}
\ifluluelse
	{\includegraphics[width=\textwidth]{privateSharedVarColor}}
	{\includegraphics[width=0.7\textwidth]{privateSharedVarColor}}
\caption{Instance and class methods accessing different 
variables.\figlabel{privateSharedVar}}
\end{center}
\end{figure}

In \figref{privateSharedVar} we see that \ct{rgb} and \ct{cachedDepth} are instance variables of \ct{Color}, hence only accessible to instances of \clsind{Color}.
We also see that \lct{superclass}, \lct{subclass}, \lct{methodDict} and so on are class instance variables, \ie instance variables only accessible to the \lct{Color} class.

But we can also see something new: \ct{ColorNames} and \ct{CachedColormaps} are \emph{class variables} defined for \ct{Color}.
The capitalization of these variables gives us a hint that they are shared.
In fact, not only may all instances of \ct{Color} access these shared variables, but also the \ct{Color} class itself, \emph{and any of its subclasses}.
Both instance methods and class methods can access these shared variables.

%\begin{figure}
%\begin{center}\includegraphics[width=6cm]{dateToday}\caption{A date is an object that  represents only anumber of days; all the information about month names, day names, etc.\ is shared among all the instances \figlabel{dateToday}}\end{center}.
%\end{figure}

A class \subind{class}{variable} is declared in the class definition template.
For example, the class \ct{Color} defines a large number of class variables to speed up color creation; its definition is shown below (\clsref{Color}).
\needlines{5}
\begin{classdef}[Color]{Color and its class variables}
Object subclass: #Color 	
        instanceVariableNames: 'rgb cachedDepth cachedBitPattern'
        classVariableNames: 'Black Blue BlueShift Brown CachedColormaps ColorChart ColorNames ComponentMask ComponentMax Cyan DarkGray Gray GrayToIndexMap Green GreenShift HalfComponentMask HighLightBitmaps IndexedColors LightBlue LightBrown LightCyan LightGray LightGreen LightMagenta LightOrange LightRed LightYellow Magenta MaskingMap Orange PaleBlue PaleBuff PaleGreen PaleMagenta PaleOrange PalePeach PaleRed PaleTan PaleYellow PureBlue PureCyan PureGreen PureMagenta PureRed PureYellow RandomStream Red RedShift TranslucentPatterns Transparent VeryDarkGray VeryLightGray VeryPaleRed VeryVeryDarkGray VeryVeryLightGray White Yellow'
        poolDictionaries: '' 	
        category: 'Graphics-Primitives'
\end{classdef}

The class variable \cvind{ColorNames} is an array containing the name of frequently-used colors. This array is shared by all the instances of \ct{Color} and its subclass \clsind{TranslucentColor}. It is accessible from all the instance and class methods. % (see \figref{ClassVarAccess2}).

\ct{ColorNames} is initialized once in \cmind{Color class}{initializeNames}, but it is accessed from instances of \ct{Color}.
The method \cmind{Color}{name} uses the variable to find the name of a color.
Since most colors do not have names, it was thought inappropriate to add an instance variable \ct{name} to every color.

\subsubsection{Class initialization}

The presence of class variables raises the question: how do we initialize them?  
One solution is lazy \subind{class}{initialization}.
This can be done by introducing an accessor method which, when executed, initializes the variable if it has not yet been initialized. This implies that we must use the accessor all the time and never use the class variable directly.  This furthermore imposes the cost of the accessor send and the initialization test.
It also arguably defeats the point of using a class variable, since in fact it is no longer shared.

\begin{method}[colorclasscolornames]{Color class>>colorNames}
Color class>>>colorNames	
	ColorNames ifNil: [self initializeNames].
	^ ColorNames
\end{method}	
\cmindex{Color class}{colorNames}

Another solution is to override the class method \ct{initialize}.

\needlines{3}
\begin{method}[colorclassinit]{Color class>>initialize}
Color class>>>initialize	
	!\ldots!
	self initializeNames
\end{method}	
\cmindex{Color class}{initialize}

\noindent
If you adopt this solution, you need to remember to invoke the \ct{initialize} method after you define it, \eg by evaluating \ct{Color initialize}.
Although \subind{browser}{class side} \ct{initialize} methods are executed automatically when code is loaded into memory, they are \emph{not} executed automatically when they are first typed into the browser and compiled, or when they are edited and re-compiled.

%---------------------------------------------------------
\subsection{Pool variables}
Pool variables are variables that are shared between several classes that may not be related by inheritance.
Pool variables were originally stored in pool dictionaries; now they should be defined as class variables of dedicated classes (subclasses of SharedPool). Our advice is to avoid them; you will need them only in rare and specific circumstances.
Our goal here is therefore to explain \subind{variable}{pool} variables just enough so that you can understand them when you are reading code. 

A class that accesses a pool variable must mention the pool in its class definition. 
For example, the class \clsind{Text} 
indicates that it is using the pool dictionary \ct{TextConstants}, which contains all the text constants such as \glbind{CR} and \glbind{LF}. 
This dictionary has a key \ct{#CR} that is bound to the value \ct{Character cr}, \ie the carriage return character.
\cmindex{Character class}{cr}

\begin{classdef}[textpooldict]{Pool dictionaries in the \ct{Text} class}
ArrayedCollection subclass: #Text
        instanceVariableNames: 'string runs' 	
        classVariableNames: '' 	
        !\textbf{poolDictionaries: 'TextConstants'}!
        category: 'Collections-Text'
\end{classdef}
   
This allows methods of the class \ct{Text} to access the keys of the dictionary in the method body \emph{directly}, \ie by using variable syntax rather than an explicit dictionary lookup.
For example, we can write the following method. 
  
\begin{method}[texttestcr]{Text>>testCR}
Text>>>testCR 	
      ^ CR == Character cr
\end{method}

Once again,  we recommend that you avoid the use of pool variables and pool dictionaries. 

%=========================================================
\section{Chapter summary}

The object model of \pharo is both simple and uniform.
Everything is an object, and pretty much everything happens by sending messages.

\begin{itemize}
  \item Everything is an object.
  Primitive entities like integers are objects, but also classes are first-class objects.

  \item Every object is an instance of a class.
  Classes define the structure of their instances via \emph{private} instance variables and the behaviour of their instances via \emph{public} methods. Each class is the unique instance of its metaclass.  Class variables are private variables shared by the class and all the instances of the class.
  Classes cannot directly access instance variables of their instances, and instances cannot access instance variables of their class.
  Accessors must be defined if this is needed.

  \item Every class has a superclass.
  The root of the single inheritance hierarchy is \lct{ProtoObject}.
  Classes you define, however, should normally inherit from \ct{Object} or its subclasses.
  There is no syntax for defining abstract classes.
  An abstract class is simply a class with an abstract method\,---\,one 
  whose implementation consists of the expression \ct{self subclassResponsibility}.
  Although \pharo supports only single inheritance, it is easy to share implementations of methods by packaging them as \emph{traits}.

  \item Everything happens by sending messages.
	We do not ``call methods'', we ``send messages''.
	The receiver then chooses its own method for responding to the message.

  \item Method lookup follows the inheritance chain;
  \self sends are dynamic and start the method lookup again in the class of the receiver, whereas
  \super sends are static, and start in the superclass of class in which the \super send is written.
  
  \item There are three kinds of shared variables.
  		Global variables are accessible everywhere in the system.
		Class variables are shared between a class, its subclasses and its instances.
		Pool variables are shared between a selected set of classes.
		You should avoid shared variables as much as possible.

\end{itemize}

%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=========================================================

%=================================================================
%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:

%---------------------------------------------------------
