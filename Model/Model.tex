% $Author: CesarBallardini $
% $Date: 2009-12-21 01:54:32 +0100 (Mon, 21 Dec 2009) $
% $Revision: 30012 $

% HISTORY:
% 2006-10-24 - Stef started
% 2006-10-25 - Stef first draft
% 2006-12-07 - Andrew edit
% 2007-06-13 - Andrew revised
% 2007-06-21 - Oscar edit
% 2007-07-26 - Stef review
% 2007-08-23 - Oscar review
% 2007-08-29 - Andrew corrections
% 2011-06    - Maxi Sarno translation to Spanish

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
\chapter{El modelo de objetos de \st}
\chalabel{model}

El modelo de programaci\'on de \st es simple y uniforme: todo es un objeto, y los objetos se comunican entre si \'unicamente mediante el env\'io de mensajes. 

Sin embargo, esta simplicidad y uniformidad puedes ser una fuente de dificultad para aquellos programadores que est\'an acostumbrados a otros lengujes. En este cap\'itulo, presentamos los conceptos claves del modelo de objetos de \st; en particular discutimos las concequencias de representar clases como objetos.

%=========================================================
\section{Las reglas del modelo}
\seclabel{rules}

El modelo de objetos de \st est\'a basado en un conjunto de reglas simples  que son aplicadas  \emph{de manera uniforme}. Dichas reglas son las siguientes:

\begin{enumerate}[label={\textbf{Rule \arabic{*}}.}, ref={Rule \arabic{*}}, leftmargin=*]
\item{} \rulelabel{everything}
	Todo es un objeto.

\item{} \rulelabel{instance}
	Todo objeto es instancia de una clase.

\item{}  \rulelabel{inheritance}
	Toda clase tiene una superclase.

\item{}  \rulelabel{message}
	Todo ocurre mediante el env\'io de mensajes.

\item{}  \rulelabel{lookup}
	El Method lookup sigue la cadena de herencia.

\end{enumerate}

\noindent
Veamos cada una de estas reglas en detalle.

%=========================================================
\section{Todo es un Objeto}

%\ruleref{everything}

La frase ``todo es un objeto'' es altamente contagiosa.
Despu\'es de poco tiempo trabajando con \st, te sorprender\'as de c\'omo esta regla simplifica todo lo que haces.  
Los n\'umeros enteros, por ejemplo, son objetos verdaderos, por lo tanto puedes enviarles mensajes, tal como lo haces con cualquier otro objeto.


\begin{code}{@TEST}
3 + 4            --> 7    ``env\'ia '+ 4' to 3, yielding 7''
20 factorial  --> 2432902008176640000   "send factorial, yielding a big number"
\end{code}

La representaci\'on de \ct{20 factorial} es ciertamente diferente de la representaci\'on de \ct{7}, pero dado que ambos dos son objetos, ninguno de los dos c\'odigos\,---\,ni siquiera la implementaci\'on de \ct{factorial}\,---\,necesita saber acerca de esto.  

\needlines{3}
Quiz\'as, la consecuencia fundamental de esta regla es lo siguiente:
\important{Las clases son objetos tambi\'en.}

Adem\'as, las clases no son objetos de segundo orden: realmente son objetos de primer orden a los cuales les puedes enviar mensajes, inspeccionar, etc.
Esto significa que \pharo es un sistema verdaderamente reflectivo, lo que da un gran poder de expresi\'on a los desarrolladores.

M\'as produndo en la implementaci\'on, hay tres tipos diferentes de objetos. Existen (1) objetos ordinarios con variables de instancia que son pasadas por referencia, existen (2) \emph{small integers} %VER COMO TRADUZCO ESTO
que son pasados por valor, y existen objetos indexables como arrays que contienen una porci\'on continua de memoria. La belleza de \st es que normalmente no tienes que preocuparte por las diferencias de estos tres tipos de objetos. 

%=========================================================
\section{Todo objeto es instancia de una clase}

%\ruleref{instance}

Todo objeto tiene una clase; puedes averiguar cu\'al envi\'andole el mensaje \ct{class}.

\begin{code}{@TEST}
1 class                 --> SmallInteger
20 factorial class --> LargePositiveInteger
'hello' class          --> ByteString
#(1 2 3) class       --> Array
(4@5) class         --> Point
Object new class --> Object
\end{code}

Una clase define la \emph{estructura} de sus instancias mediante variables de instancia, y el \emph{comportamiento} mediante m\'etodos. Cada m\'etodo tiene un nombre, llamado su \emphsubind{method}{selector}, que es \'unico dentro de su clase. 

Dado que \emph{las clases son objetos}, y que \emph{todo objeto es instancia de una clase}, entonces se deduce que las clases tambi\'en tienen que ser instancias de clases. Una clase cuyas instancias son clases, se llama  \emphind{metaclase}. Siempre que creas una clase, el sistema crea autom\'aticamente la metaclase. 
La metaclase define la estructura y el comportamiento de la clase que es su instancia. 
El 99\% \damien{Did any of you verify it is 99\%? Maybe 'Most' would have been better than '99\%'}de las veces no necesitar\'as pensar en metaclases, y posiblemente, las ignores. 
(Tendremos una mirada m\'as de cerca a metaclases en \charef{metaclasses}.)
%No esta andando el charef

%---------------------------------------------------------
\subsection{Variables de instancia}

Las variables de instancia en \st son privadas a la instancia en si misma. 
Esto es un contraste con \ind{Java} y \ind{C++}, que permiten que las variables de instancia (tambi\'en conocidas como ``campos'', ``atributos'' o incluso ``colaboradores internos'') sean accedidas por otras instancias de la misma clase.  
Decimos que el \emphind{l\'\i{}mite del encapsulamiento} de los objetos en Java y C++ es la clase, mientras que en \st es la instancia.

\seeindex{variable!instance}{instance variable}
\seeindex{field}{instance variable}
\seeindex{attribute}{instance variable}
\seeindex{slot}{instance variable}
\index{instance variable}


En \st dos instancias de la misma clase no pueden acceder a las variables de instancia de la otra a menos que la clase defina ``m\'etodos de \ind{acceso}''.
%Aca tengo que hacer referencia a la palabra en ingles accessor  o getter


No existe sintaxis alguna del lenguaje que provea acceso directo a las variables de instancia de cualquier otro objeto. 
(En realidad, un mecanismo llamado reflexi\'on s\'\i{} 
provee una forma de pedirle a otro objeto el valor de sus variables de instancia; la meta-programaci\'on es usada para escribir herramientas como el inspector de objetos,
%Menciono el Object inspector en ingles?
 cuyo \'unico prop\'osito es mirar internamente otros objetos.) 


Las variables de instancia pueden ser accedidas por nombre desde cualquier m\'etodo de instancia de la clase que las define y tambi\'en desde los m\'etodos definidos en sus subclases. Esto significa que las variables de instancia de \st son similares a las variables  \emph{protegidas} de C++ y Java.      
No obstante, preferimos decir que son privadas, pues en \st es considerado un mal estilo acceder directamente a las variables de instancia desde una subclase.  

\subsubsection{Ejemplo}

El m\'etodo \cmind{Point}{dist:} (\mthref{dist:}) computa la distancia entre el receptor y otro punto. Las variabes de instancia \ct{x} e \ct{y} del receptor son accedidas directamente por el cuerpo de m\'etodo. Sin embargo, las variables de instancia del otro punto deben ser accedidas envi\'andole los mensajes \ct{x} e \ct{y}.


%Se traducen los comentarios de los ejemplos de codigo ?
\needlines{7}
\begin{method}[dist:]{la distancia entre dos puntos}
Point>>>dist: aPoint 
	"Answer the distance between aPoint and the receiver."  
	| dx dy |
	dx := aPoint x - x.
	dy :=  aPoint y - y.
	^ ((dx * dx) + (dy * dy)) sqrt
\end{method}

\begin{code}{@TEST}
1@1 dist: 4@5 --> 5.0
\end{code}

La raz\'on clave para preferir encapsulamiento basado en instancias sobre encapsulamiento basado en clases, es que permite que diferentes implementaciones de la misma abstracci\'on puedan coexistir. 

Por ejemplo, el m\'etodo \ct{point>>>dist:} no necesita saber o preocuparse si el argumento \ct{aPoint} es una instancia de la misma clase que el receptor o no. El objeto del argumento podr\'\i{}a estar representado en coordinadas polares, o como un registro en una base de datos, o en otra computadora en un sistema distribuido; mientras pueda responder a los mensajes \ct{x} e \ct{y}, el c\'odigo de \mthref{dist:} va a seguir funcionando correctamente.

%---------------------------------------------------------
\subsection{M\'etodos}

Todos los m\'etodos  son \subind{method}{p\'ublicos}.\footnote{Bueno, en realidad, casi todos. En \pharo, los m\'etodos cuyos selectores empiezan con el prefijo \ct{pvt} son privados: Un mensaje \ct{pvt} puede ser enviado  \emph{solamente} a \self. No obstante, los m\'etodos \ct{pvt} no son muy usados.}
Los m\'etodos son agrupados en protocolos que indican su intenci\'on. 
Algunos nombres de protocolos comunes han sido establecidos por convenci\'on, por ejemplo, \protind{accessing} para todos los m\'etodos de acceso, e \protind{initialization} para crear un estado concistente inicial del objeto. El protocolo \protind{private} se usa a veces para agrupar m\'etodos que no deber\'\i{}an ser vistos desde afuera del objeto. Sin embargo, nada previene que le puedas enviar un mensaje que est\'a implementado como ``privado''.  

Los m\'etodos pueden acceder a todas las variables de instancia del objeto.
Algunos programadores \st prefieren acceder a las variables de instancia \'unicamente mediante m\'etodos de acceso. 
Dicha pr\'actica tiene cierto valor, pero tambi\'en impacta en la interfaz de las clases, y pero a\'un, expone estado privado al mundo.

%---------------------------------------------------------
\subsection{Del lado de instancia y del lado de clase}

Dado que las clases son objetos, tambi\'en tienen sus propias variables de instancia y sus propios m\'etodos.
Llamamos a ellos, \emph{variables de instancia de clase} y \emph{m\'etodos de clase}, pero en realidad no son diferentes a las variables de instancia y m\'etodos ordinarios:
las variables de instancia de clase son s\'olo variables de instancia definidas por una metaclase, y los m\'etodos de clase son simplemente m\'etodos definidos por una  \ind{metaclase}. 

\index{class!instance variable}
\seeindex{variable!class instance}{class, instance variable}
\index{class!method}

Una clase y su \ind{metaclase} son dos clases separadas, a pesar de que la primera es una instancia de la segunda. No obstante, esto es en gran medida irrelevante para el programador:  debe concentrarse en definir el comportamiento de sus objetos y en las clases que los crean. 


\begin{figure}[htb]
\begin{center}
\includegraphics[width=\textwidth]{Color-Buttons}
\caption{Navegando una clase y su metaclase.
% \sd{Do we use Key everywhere in the picture as a legend indicator?}
% \on{sure, wherever appropriate}
\figlabel{Buttons}}
\end{center}
\end{figure}

Por esta raz\'on, el navegador \index{browser}  te ayuda a navegar ambas, la clase y su metaclase, como si fueran una sola cosa con dos pesta\~nas: ``\subind{browser}{del lado de instancia}'' y ``\subind{browser}{del lado de clase}'', como se muestra en \figref{Buttons}. 

Haciendo clic en el bot\'on \button{instance} navegamos la clase \ct{Color}, \ie puedes navegar los m\'etodos que son ejecutados cuando se le env\'\i{}an mensajes a una instancia de \ct{Color}, como por ejemplo el color azul. Presionando el bot\'on  \button{class} navegamos la clase \ct{Color class}, \ie se pueden ver los m\'etodos que ser\'an ejecutados cuando se le envien mensajes a la clase \ct{Color}  propiamente dicha.
Por ejemplo, \ct{Color blue} env\'\i{}a el mesaje \ct{blue} a la clase \clsind{Color}. Por lo tanto, encontrar\'as el m\'etodo  \ct{blue} definido en el lado de clase de  \ct{Color}, no del lado de instancia. 
\seeindex{class side}{browser!class side}
\seeindex{instance side}{browser!instance side}


\needlines{5}
\begin{code}{@TEST | aColor |}
aColor := Color blue.               "Class side method blue"
aColor        --> Color blue
aColor red  --> 0.0         "Instance side accessor method red"
aColor blue --> 1.0        "Instance side accessor method blue"
\end{code}


Una clase se define completando el esqueleto propuesto en el  \subind{browser}{lado de instancia}. 
Cuando se acepta esta plantilla, el sistema crea no s\'olo la clase definida, pero tambi\'en la metaclase asociada.

Puede navegar la metaclase haciendo clic en el bot\'on \button{class}.
La \'unica parte de la plantilla de creaci\'on de la metaclase que tiene sentido editar directamente es la lista de nombres de variables de instancia.

Una vez que una clase fue creada, haciendo clic en el bot\'on \button{instance} podemos editar y navegar los m\'etodos  que ser\'an pose\'\i{}dos por instancias de esa clase (y de sus subclases). Por ejemplo, podemos ver en la \figref{Buttons} que el m\'etodo \ct{hue} est\'a definido en el lado de instancia de la clase  \ct{Color}.
Por el contrario, el b\'oton  \button{class} permite navegar y editar la metaclase (en este caso \ct{Color class}).

%---------------------------------------------------------
\subsection{M\'etodos de clase} 

Los m\'etodos de clase pueden ser muy \'utiles; puedes navegar \ct{Color class} para ver unos buenos ejemplos.
Ver\'as que hay dos tipos de \subind{class}{m\'etodos} definidos en una clase: aquellos que crean instancias de la clase, como \cmind{Color class}{blue} y aquellos que llevan a cabo una funci\'on de utilidad, como \cmind{Color class}{showColorCube}. 
Esto es lo t\'ipico, aunque ocasionalmente encontrar\'as m\'etodos de clase usados para otra cosa.  

Es conveniente poner los m\'etodos de utilidad \subind{browser}{del lado de clase} porque pueden ser ejecutados sin tener que crear ning\'un objeto primero.
De hecho, la mayor\'ia de ellos tendr\'an un comentario cuyo objetivo es hacer m\'as f\'acil su ejecuci\'on.

%strange the following does not compile
%\dothis{Navegue el m\'etodo  \ct{Color class>>>showColorCube}, doble clic justo adentro de las comillas del comentario \ct{"Color showColorCube"} y tipee \short{d}.}

Ver\'as el efecto de ejecutar este m\'etodo. (Seleccione \menu{World \go \ind{restore display}~(r)} para deshacer los cambios.)


Para aquellos familiarizados con \ind{Java} y \ind{C++}, los m\'etodos de clase parecieran ser similares a los m\'etodos est\'aticos.
Sin embargo, la uniformidad de \st implica que de alguna forma son distintos: mientras que los m\'etodos est\'aticos de Java son realmente simples procedimientos resueltos est\'aticamente, los m\'etodos de clase de \st son m\'etodos despachados dinamicamente. 
Esto significa que la herencia, sobre-escritura y mensajes enviados con super funcionan en los m\'etdos de clase en \st, mientras que no funcionan con los m\'etodos est\'aticos de Java.


%---------------------------------------------------------

\subsection{Variables de instancia de clase}

Con las variables de instancia ordinarias, todas las instancias de una clase tienen el mismo conjunto de nombres de variables, y las instancias de sus subclases heredan esos nombres; no obstante, cada instancia tiene su propio conjunto privado de valores.
%No se como poner el subind aca
La historia es exactamente la misma con las variables de instancia de clase: cada clase tiene sus propias variables de instancia de clase privadas. 
Una subclase heredar\'a esas variables de instancia de clase, \emph{pero tendr\'a sus propias copias de dichas variables}.
As\'\i{} c\'omo los objetos no comparten sus variables de instancia, tampoco las clases ni sus subclases comparten las variables de instancia de clase.

Una variable de instancia de clase llamada \ct{contador} se podr\'\i{}a usar por ejemplo, para llevar la cuenta de cuantas instancias se crean de una clase dada. De todos modos, cada subclase tendr\'a su propia variable \ct{count}, por lo tanto, las instancias de las subclases ser\'\i{}an contadas por separado. 

\paragraph{Ejemplo: las variables de instancia de clase no son compartidas con sus subclases.}
Supongamos que definimos las classes  \ct{Dog} (perro) y \ct{Hyena} (hiena), donde \ct{Hyena} hereda la variable de instancia de clase  \ct{contador} de \ct{Dog}.

\begin{classdef}[dog]{Perros y hienas}
Object subclass: #Dog
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-CIV'

Dog class
	instanceVariableNames: 'count'

Dog subclass: #Hyena
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-CIV'
\end{classdef}

Ahora supongamos que creamos m\'etodos de clase en \ct{Dog} para inicializar su variable \ct{count} a \ct{0}.
\begin{method}[dogcount]{Manteniendo la cuenta de perros nuevos}
Dog class>>>initialize
	super initialize.
	count := 0.

Dog class>>>new
	count := count +1.
	^ super new

Dog class>>>count
	^ count
\end{method}

Ahora cuando creamos un nuevo perro su contador es incrementado, y lo mismo para cada hiena, pero son contados por separado:

\begin{code}{}
Dog initialize.
Hyena initialize.
Dog count     --> 0
Hyena count --> 0
Dog new.
Dog count     --> 1
Dog new.
Dog count     --> 2
Hyena new.
Hyena count --> 1
\end{code}
% ON: In order to make this a test, I need the previous code to be part of the setup. Bleh.

Note tambi\'en que las variables de instancia de clase son privadas a la clase extactamente de la misma forma en que las variables de instancia son privadas a la instancia. 
Dado que las clases y sus instancias son diferentes objetos, existen las siguientes inmediatas consecuencias:
\important{Una clase no tiene acceso a las variables de instancia de sus propias instancias.}
\important{Una instancia de una clase no tiene acceso a las variables de instancia de clase de su propia clase.}
%No se como poner el subind aca
Por esta raz\'on, los m\'etodos de inicializaci\'on de instancia deber ser definidos siempre en el lado de instancia del navegador
\,---\,el lado de clase del navegador no tiene acceso a las variables de instancia !`por lo tanto no las puede inicializar! 

De manera similar, las instancias puede acceder a las variables de instancia de clase solamente de forma indirecta, enviando un mensaje de acceso a sus clases. 

\ind{Java} no tiene nada equivalente a las variables de instancia de clase. 
Las variables est\'aticas de Java y \ind{C++} son m\'as parecidas a las variables de clase de \st, que discutiremos en la \secref{classVars}: todas las subclases y todas sus instancias comparten la misma variable est\'atica.


\paragraph{Ejemplo: Definiendo un Singleton.}
\nicopaez{Singleton no se traduce pues en este caso es un nombre propio, esta haciendo referencia al nombre de patron conocido}
El \ind{patr\'on Singleton}~\cite{Alpe98a} provee un t\'\i{}pico ejemplo del uso de variables de instancia de clase y de m\'etodos de clase.
Imagine que quisi\'eramos implementar la clase \ct{WebServer} y usar el patr\'on Singleton para asegurarnos que tenga una \'unica instancia. 

haciendo clic en el bot\'on \button{instance} del navegador, definimos la clase \clsind{WebServer} como sigue (\clsref{singleton}). 

\begin{classdef}[singleton]{Una clase singleton}
Object subclass: #WebServer
	instanceVariableNames: 'sessions' 	
	classVariableNames: '' 	
	poolDictionaries: '' 	
	category: 'Web'
\end{classdef}

Luego, haciendo clic en el bot\'on \button{class}, agregamos la variable de instancia \ct{uniqueInstance} \subind{browser}{del lado de clase}

\begin{classdef}[webserver]{El lado de clase de la clase singleton}
WebServer class 	
	instanceVariableNames: 'uniqueInstance'
\end{classdef}

La consequencia de esto es que la clase \ct{WebServer} ahora tiene otra variable de instancia, 
adem\'as de las variables de instancia que hereda, como \ct{superclass} y \ct{methodDict}.


%Habria que cambiar el mthref para que lo imprima en espaniol
Ahora podemos definir un \subind{class}{m\'etodo} de clase llamado \ct{uniqueInstance} como se muestra en el \mthref{uniqueInstance}.
Este m\'etodo primero chequea si  \ct{uniqueInstance} ha sido inicializada o no.
Si no lo fue, el m\'etodo crea una instancia y la asigna a la variable de instancia de clase  \ct{uniqueInstance}.  
Finalmente el valor de \ct{uniqueInstance} es retornado.
Como  \ct{uniqueInstance} es una variable de instancia de clase, \'este m\'etodo puede acceder a ella directamente. 

    
\begin{method}[uniqueInstance]{uniqueInstance (en el lado de clase)}
WebServer class>>>uniqueInstance
     uniqueInstance ifNil: [uniqueInstance := self new].
     ^ uniqueInstance
\end{method}

La primera vez que \ct{WebServer uniqueInstance} es ejecutado, una instancia de la clase \ct{WebServer}  ser\'a creada y asignada a la variable \ct{uniqueInstance}.
La pr\'oxima vez, la instancia creada previamente ser\'a retornada, en lugar de crear una nueva. 


Note que el c\'odigo de creaci\'on de instancias adentro del condicional en el \mthref{uniqueInstance} est\'a escrito como \ct{self new}  y no como \ct{WebServer new}.
?`Cu\'al es la diferencia?   Dado que el m\'etodo \ct{uniqueInstance} est\'a definido en la \ct{clase WebServer}, podr\'\i{}a pensarse que ambas son iguales. De hecho, hasta que alguien cree una subclase de \lct{WebServer}, son iguales. Pero supongamos que \ct{ReliableWebServer} es una subclase de  \ct{WebServer}, y hereda el m\'etodo \ct{uniqueInstance}. Esperar\'\i{}amos claramente que \ct{ReliableWebServer uniqueInstance} responda un \lct{ReliableWebServer}. Usando \self nos aseguramos de que as\'\i{} sea, pues ser\'a ligado con la correspondiente clase. 
Note tambi\'en que \ct{WebServer} y \ct{ReliableWebServer} van a tener, cada uno, sus propias variables de instancia de clase llamadas
\ct{uniqueInstance}.  Esas dos variables van a tener obviamente distintos valores.

%=========================================================
\section{Toda clase tiene una superclase}

%\ruleref{inheritance}

Cada clase en \st hereda su comportamiento y la descripci\'on de su estructura de una \'unica \emphind{superclase}.
Esto significa que \st tiene \ind{herencia} simple.

\needlines{2}
\begin{code}{@TEST}
SmallInteger superclass --> Integer
Integer superclass          --> Number
Number superclass        --> Magnitude
Magnitude superclass    --> Object
Object superclass           --> ProtoObject
ProtoObject superclass  --> nil
\end{code}


Tradicionalmente la raiz de la jerarqu\'\i{}a de herencia en \st es la clase \clsind{Object} (dado que todo es un objeto).
En \pharo, la raiz es en realidad una clase llamada \clsind{ProtoObject}, aunque normalmente no prestar\'as atenci\'on a esta clase. 
\ct{ProtoObject} encapsula el conjunto de mensajes m\'\i{}nimos que todos los objetos \emph{deben} tener. Sin embargo, la mayor\'\i{}a de las clases heredan de \ct{Object}, quien define varios mensajes adicionales que casi todos los objetos deber\'\i{}an entender y responder.
A menos que tengas una muy buena raz\'on para hacer lo contrario, cuando crees clases para aplicaciones deber\'\i{}an normalmente 
heredar de  \ct{Object}, o de una de sus subclases.


\dothis{Una nueva clase es creada normalmente enviando el mensaje
\ct{subclass: instanceVariableNames: ...}
a una clase existente.
Hay tambi\'en algunos otros m\'etodos para crear clases.
Puedes observar el protocolo \prot{Kernel-Classes \go Class \go subclass creation} para ver cuales son.}
\scatindex{Kernel-Classes}
\protindex{creation}	

%There is no special syntax for creating abstract classes in \st.
%An abstract class is an ordinary class in which the implementation of some methods is deferred to a subclass.
%This is repeated in the next section

Aunque \pharo no provee m\'ultiple herencia, s\'\i{} soporta una mecanismo llamado \emphind{trait}{}s para compartir comportamiento entre clases no relacionadas.
Traits son colecciones de m\'etodos que pueden ser reutilizados por m\'ultiples cases que no est\'an relacionadas por la herencia. Usando traits uno puede compartir c\'odigo entre diferentes clases sin duplicaci\'on de c\'odigo.


%---------------------------------------------------------

\subsection{M\'etodos abstractos y clases abstractas}

Una clase \subind{clase}{abstracta}  es una clase que existe para ser subclasificada, m\'as que instanciada. 
Una clase abstracta es usualmente incompleta, en el sentido de que no define todos los m\'etodos que usa. 
Todos esos m\'etodos que le faltan\,---\,aquellos que otros m\'etodos asumen, pero que no est\'an definidos en si mismos\,---\, son llamados m\'etodos \subind{m\'etodo}{abstractos}. 
\seeindex{clase abstracta}{clase, abstracta}
\seeindex{m\'etodo abstracto}{m\'etodo, abstracto}


\st no tiene una sintaxis dedicada para especificar que un m\'etodo o clase es abstracta. 
Por convenci\'on, el cuerpo de un m\'etodo abstracto conciste en la expresi\'on \mbox{\ct{self subclassResponsibility}.} 
Este es un conocido ``Marker Method'', e indica que las subclases tienen la responsabilidad de definir una versi\'on concreta del m\'etodo.
Los m\'etodos \ct{self subclassResponsibility} deber\'\i{}an ser siempre sobreescritos, y por lo tanto nunca deber\'\i{}an ser ejecutados.
Si te olvidas de sobreescribir alguno, y es ejecutado, una excepci\'on ser\'a lanzada. 
\cmindex{Object}{subclassResponsibility}


Una clase es considerada abstracta si al menos uno de sus m\'etodos es abstracto.
En realidad, nada te previene de crear una instancia de una clase abstracta: todo va a andar bien hasta que un m\'etodo abstracto sea invocado. 

\subsubsection{Ejemplo: la clase \ct{Magnitude}.}
%
%
\clsind{Magnitude} es una clase abstracta que nos ayuda a definir objetos que pueden ser comparados con otros. Las subclases de \ct{Magnitude} deber\'ian implementar los m\'etodos \ct{<}, \ct{=} and \ct{hash}. Usando esos mensajes \ct{Magnitude} define otros m\'etodos como \ct{>}, \ct{>=}, \ct{<=}, \ct{max:}, \ct{min:} \ct{between:and:} y otros para comparar grafos de objetos.  El m\'etodo  \mthind{Magnitude}{<}  es abstracto y definido como se muestra en  \mthref{MagnitudeLessThan}.
%
\begin{method}[MagnitudeLessThan]{\ct{Magnitude>>><}}
Magnitude>>>< aMagnitude 
	"Answer whether the receiver is less than the argument."
	^self subclassResponsibility
\end{method}
%
\noindent
Por el contrario, el m\'etodo \mthind{Magnitude}{>=} es concreto; est\'a definido en t\'erminos de \ct{<}:
%
%
\begin{method}[Magnitude>=]{\ct{Magnitude>>>>=}}
>= aMagnitude 
	"Answer whether the receiver is greater than or equal to the argument."
	^(self < aMagnitude) not
\end{method}

Lo mismo sucede con los otros m\'etodos de comparaci\'on.

\clsind{Character} es una subclase de \ct{Magnitude}; sobreescribe el m\'etodo \mthind{Object}{subclassResponsibility} de \ct{<} con su propia versi\'on de \ct{<} (mirar \mthref{CharacterLessThan}).  \ct{Character} tambi\'en define los m\'etodos \ct{=} y \ct{hash}; hereda de \ct{Magnitude} los m\'etodos \ct{>=}, \ct{<=}, \ct{~=} entre otros.
%
%
\begin{method}[CharacterLessThan]{\ct{Character>>><}}
Character>>>< aCharacter 
	"Answer true if the receiver's value < aCharacter's value."
	^self asciiValue < aCharacter asciiValue
\end{method}

%---------------------------------------------------------
\subsection{Traits}
Un \emphind{trait} es una colecci\'on de m\'etodos que pueden ser incluidos en el comportamiento de una clase sin la necesidad de la herencia. Esto permite facilmente que las clases tengan una \'unica superclase, pero que tambi\'en puedan compartir m\'etodos con otras clases con las que no est\'an relacionadas.

Para definir un nuevo trait, simplemente remplaza la plantilla de creaci\'on de subclases, enviando un mensaje a la clase \clsind{Trait}.

\needspace{5\baselineskip}
\begin{classdef}[tauthor]{Defining a new trait}
Trait named: #TAuthor
	uses: { }
	category: 'PBE-LightsOut'
\end{classdef}

\noindent
Ac\'a definimos el trait \ct{TAuthor} en la categor\'\i{}a \scat{PBE-LightsOut}.
Este trait no \emph{usa} ning\'un otro trait existente.
En general siempre podemos especificar la expresi\'on de composici\'on de un trait, de otros traits para usar como parte del argumnento de palabra clave \ct{uses:}.


Los traits pueden contener m\'etodos pero no variables de instancia.
Supongamos que queremos agregar un m\'etodo \ct{author} a varias clases, independientemente de la herencia. 
Podr\'\i{}amos hacerlo de la siguiente manera:


\begin{method}[author]{An author method}
TAuthor>>>author
    "Returns author initials"
	^ 'on'    "oscar nierstrasz"
\end{method}

\
\noindent
Ahora podemos usar este trait en una clase que ya tiene su propia superclase, por ejemplo en la clase \ct{LOGame} que definimos en \charef{firstApp}.
Simplemente modificamos la plantilla de creaci\'on de clases de  \ct{LOGame} para incluir la palabra clave  \ct{uses:}  que especifica que \ct{TAuthor} deber\'\i{}a ser usado.



\begin{classdef}[sbegamewithtrait]{Using a trait}
BorderedMorph subclass: #LOGame
	uses: TAuthor
	instanceVariableNames: 'cells'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-LightsOut'
\end{classdef}

Como es de esperarse, si ahora instanciamos un \ct{LOGame}, dicho objeto reponder\'a al mensaje  \ct{author}  de forma correcta.

\begin{code}{}
LOGame new author --> 'on'
\end{code}

Las expresiones de composici\'on de Trait pueden combinar m\'ultiples traits usando el operador \ct{+}.
En caso de conflictos (\ie m\'ultiples traits definen m\'etodos con el mismo nombre), estos pueden resolverse removiendo expl\'icitamente estos m\'etodos (con \ct{-}), o redefiniendo or by redefining estos m\'etodos en la clase o trait que estes definiendo.
Tambi\'en es posible darle un \emph{alias} a los m\'etodos (con \ct{@}), proporcionandoles as\'i un nuevo nombre.

Los Traits son usados en el n\'ucleo del sistema.
Un buen ejemplo es la clase \mbox{\clsind{Behavior}.}

\needlines{8}
\begin{classdef}[behaviorwithtraits]{\ct{Behavior} defined using traits}
Object subclass: #Behavior
	uses: TPureBehavior @ {#basicAddTraitSelector:withMethod:->#addTraitSelector:withMethod:}
	instanceVariableNames: 'superclass methodDict format'
	classVariableNames: 'ObsoleteSubclasses'
	poolDictionaries: ''
	category: 'Kernel-Classes'
\end{classdef}
\noindent
Aqu\'i vemos que al m\'etodo \ct{addTraitSelector:withMethod:} definido en el trait \ct{TPureBehavior} se le ha dado el alias \ct{basicAddTraitSelector:withMethod:}.
Actualmente se esta agregando a los navegadores el soporte para traits.

%=========================================================
\section{Todo ocurre mediante el env\'io de mensajes}

%\ruleref{message}

Esta regla captura la escencia de programar en \st.

En la programaci\'on procedural, la elecci\'on de que pieza del c\'odigo se ejecutar\'a cuando un procedimiento se llama es hecha por quien llama.
El que llama elige el procedimiento o funci\'on se ejecutar\'a \emph{de forma est\'atica}, por nombre.  

En la programaci\'on orientada a objetos, nosotros \emph{no} ``llamamos m\'etodos'': nosotros ``\subind{message}{enviamos} mensajes.''
La elecci\'on de terminolog\'ia es significativa.
Cada objeto tiene sus propias responsabilidades.
No le \emph{decimos} a un objeto qu\'e hacer apicandole alg\'un procedimiento.
En su lugar, le \emph{pedimos} a un objeto que haga algo por nosotros enviandole un mensaje.
El mensaje \emph{no} es una pieza de c\'odigo: no es mas que un nombre y una lista de argumentos.
El receptor luego decide como responder seleccionando su propio \emph{m\'etodo} para hacer lo que le pedimos.

Dado que objetos diferentes pueden terner m\'etodos diferentes para responder al mismo mensaje, el m\'etodo debe ser escojido \emph{din\'amicamente}, cuando el mensaje es recibido.
\begin{code}{@TEST}
3 + 4         --> 7          "enviar el mensaje + con argumento 4 al integer  3"
(1@2) + 4 --> 5@6    "enviar el mensaje + con argumento 4 al point (1@2)"
\end{code}
\noindent
Como consecuencia, podemos enviarle el \emph{mismo mensaje} a diferentes objetos, cada uno de los cuales puede tener \emph{su propio m\'etodo} para responder al mensaje.
No le decimos al \ct{SmallInteger} \ct{3} o al \ct{Point} \ct{1@2} como responder al mensaje \ct{+ 4}.
Cada uno tiene su propio m\'etodo para \ct{+}, y responde a \ct{+ 4} como corresponde.

Una de las consecuencias del modelo de env\'io de mensajes de \st's es que fomenta un estilo en el cual los objetos tienden a tener m\'etodos muy peque\~nos y delegan tareas a otros objetos, en lugar de implementar m\'etodos procedurales enormes que asumen demasiada responsabilidad.
Joseph Pelrine expresa este principio de la siguiente manera:

\important{No haga nada que pueda recaer en alguien mas.}
\nicopaez{ La frase anterior es la traduccion de: Don't do anything that you can push off onto someone else.}
\index{Pelrine, Joseph}

Muchos lenguajes orientados a proporcionan operaciones para objetos tanto estaticas como din\'amicas; en \st hay \'unicamente env\'ios de mensajes din\'amicos. En lugar de proporcionar operaciones de clase est\'aticas, por ejemplo, las clases son objetos y sencillamente les mandamos mensajes.

\emph{Casi} todo en \st sucede enviando mensajes.
En alg\'un punto la acci\'on debe llevarse a cabo:
\begin{itemize}
  \item Las \emph{declaraciones de variable} no son envios de mensajes.
  		De hecho, las declaraciones de variable \subind{variable} ni siquiera son ejecutables.
  		Declarar una variable solo provoca que se asigne espacio para una referencia al objeto.
  \item Las\emph{asignaciones} no son envios de mensajes.
  		Una \ind{asignaci\'on} a una variable provoca que ese nombre de variable sea vinculada en el contexto \nicopaez{aqui contexto es la traduccion de scope} de esa definici\'on.
  \item Los \emph{Returns} no son envios de mensajes.
  		Un \ind{return} simplemente hace que el resultado computado sea devuelto al emisor.
  \item Los \emph{primitivos} no son envios de mensajes.
  		Est\'an implementados en la \ind{m\'aquina virtual}.
		\index{primitive}
\end{itemize}
Salvo estas pocas excepciones, casi todo lo dem\'as realmente sucede mediante el env\'io de mensajes.
En particular, dado que no hay ``campos p\'ublicos'' en \st, la unica manera de actualizar una \ind{variable de instancia} de otro objeto es enviandole un mensaje solicitando que actualize su propio campo.
Por supuesto, proporcionar m\'etodos getter y setter para todas las variables de instancia de un objeto no es una buena practica de la orientaci\'on a objetos.
Joseph Pelrine tambi\'en establece esta muy bien:
\important{No deje que nadie juegue con sus datos.}

%=========================================================
\section{El Method lookup sigue la cadena de herencia} 

%\ruleref{lookup}

?`Que sucede exactamente cuando un objeto recibe un mensaje?

El proceso es bastante sencillo:
La clase del receptor busca el m\'etodo a usar para encargarse del mensaje.
Si la clase no posee un m\'etodo, le pregunta a su \ind{superclase}, y asi sucesivamente, subiendo en la cadena de \ind{herencia}.
Cuando el m\'etodo es encontrado, los argumentos se vinculan con los par\'ametros del m\'etodo, y la \ind{maquina virtual} lo ejecuta.
\index{method!lookup}

En esencia es tan simple como esto
Sin embargo hay algunas cuestiones que necesitan ser respondidas con cuidado:

\begin{itemize}
  \item \emph{?`Qu\'e sucede cu\'ando un m\'etodo no devuelve explicitamente un valor?}
  \item \emph{?`Qu\'e sucede cu\'ando una clase reimplementa un metodo de superclase?}
  \item \emph{?`Cu\'al es la diferencia entre enviar mensajes a \pvind{self} y \pvind{super}?}
  \item \emph{?`Qu\'e sucede cuando no se encuentra ning\'un m\'etodo?}
\end{itemize}

Las reglas que aqui presentamos para el method lookup son conceptuales: las implementaciones de la maquina virtual usan todo tipo de trucos y optimizaciones para acelerar el method lookup. 
Ese es su trabajo, pero usted nunca deber\'ia detectar que estan haciendo algo diferente a nuestras reglas.
% Sin importar lo que la implementaci\'on haga, estas reglas le daran una clara comprensi\'on de la sem\'antica de enviar mensajes a \self y \super.

Primero echemos un vistazo a la estrategia b\'asica de busqueda, y luego consideremos estas cuestiones.

%---------------------------------------------------------
\subsection{El Method lookup}
Suponga que creamos una instancia de \ct{EllipseMorph}.
\begin{code}{@TEST | anEllipse |}
anEllipse := EllipseMorph new.
\end{code}
\noindent
Si ahora le enviamos a este objeto el mensaje \ct{defaultColor}, obtenemos el resultado \ct{Color yellow}:
\begin{code}{@TEST | anEllipse | anEllipse := EllipseMorph new.}
anEllipse defaultColor --> Color yellow
\end{code}
\noindent
La clase \ct{EllipseMorph} implementa \ct{defaultColor}, asi que el m\'etodo indicado es encontrado inmediatamente.

\begin{method}[defaultColor]{A locally implemented method}
EllipseMorph>>>defaultColor
	"responder el color predeterminado / estilo de relleno a el receptor"
	^ Color yellow
\end{method}
\cmindex{EllipseMorph}{defaultColor}

En cambio, si enviamos el mensaje \ct{openInWorld} a \ct{anEllipse}, el m\'etodo no es encontrado de inmediato, dado que la clase \ct{EllipseMorph} no implementa \ct{openInWorld}.
La busqueda por lo tamto continua en la superclase, \lct{BorderedMorph}, y asu sucesivamente, hasta que un m\'etodo \ct{openInWorld} sea encontrado en la clase \ct{Morph} (ver \figref{openInWorldLookup}).

\begin{method}[openInWorld]{An inherited method}
Morph>>>openInWorld
	"a\~nadir este morph al mundo."

	self openInWorld: self currentWorld
\end{method}
\cmindex{Morph}{openInWorld}

\begin{figure}[htb]
\begin{center}
	{\includegraphics[width=0.8\textwidth]{openInWorldLookup}}
\caption{El Method lookup sigue la cadena de herencia.\figlabel{openInWorldLookup}}
\end{center}
\end{figure}

%---------------------------------------------------------
\subsection{Devolviendo self}

Note que \ct{EllipseMorph>>>defaultColor} (\mthref{defaultColor}) explicitamente devuelve \ct{Color yellow} mientras que \ct{Morph>>>openInWorld} (\mthref{openInWorld}) no parece devolver nada.

De hecho un m\'etodo \emph{siempre} responde un mensaje con un valor\,---\,que es, por supuesto, un objeto.

La respuesta puede estar definida por el concepto de \ct{^} en el m\'etodo, pero si la ejecuci\'on alcanza el final del m\'etodo sin ejecutar un \ct{^}, el m\'etodo a\'un devuelve un valor: devuelve el objeto que recibi\'o el mensaje.
Com\'unmente decimos que el m\'etodo ``responde a \self'', porque en Smalltalk la pseudo-variable \self representa al receptor del mensaje, como lo hace \ct{this} en \ind{Java}.
\index{variable!pseudo}
\index{return}
\seeindex{caret}{return}

Esto sugiere que \mthref{openInWorld} es equivalente a \mthref{openInWorldReturnSelf}:

\needlines{5}
\begin{method}[openInWorldReturnSelf]{Explicitly returning self}
Morph>>>openInWorld
	"A\~nade este morph al mundo."

    self openInWorld: self currentWorld
	^ self		"No hagas esto a menos que sea tu intenci\'on!"
\end{method}

?`Por qu\'e no es bueno escribir \ct{^ self} explicitamente?
Bueno, cuando devuelves algo explicitamente, estas comunicando que devuelves algo de inter\'es para el emisor.
Cuando expresamente devuelves \self, estas diciendo que esperas que el emisor utilice el valor devuelto.
Aqu\'i este no es el caso, as\'i que es mejor no retornar explicitamente \self.

Se trata de un lenguaje com\'un en \st, al cual Kent Beck denomina ``Valor de retorno interesante'' \cite{Beck97a}:
\index{Beck, Kent}

\important{Devuelve un valor solo cuando es tu intenci\'on que el emisor use el valor.}

%---------------------------------------------------------
\subsection{Sobreescribiendo una extensi\'on}

Si miramos nuevamente la herencia de clase de \ct{EllipseMorph} en \figref{openInWorldLookup}, observamos que las clases \ct{Morph} y \mbox{\ct{EllipseMorph}} implementan \ct{defaultColor}.
De hecho, si abrimos un nuevo morph (\ct{Morph new openInWorld}) observamos que obtenemos un morph azul, mientras que una elipse ser\'a por defecto de color amarillo.
\index{method!overriding}
\index{method!extension}
\seeindex{overriding}{method, overriding}
\seeindex{extension}{method, extension}

Decimos que \ct{EllipseMorph} \emph{sobreescribe} el m\'etodo \ct{defaultColor} que hereda de \ct{Morph}.
El m\'etodo heredado ya no existe desde el punto de vista de \ct{anEllipse}.

A veces no queremos sobreescribir m\'etodos heredados, sino m\'as bien \emph{extenderlos} con alguna funcionalidad nueva, es decir, nos gustar\'ia ser capaces de invocar el m\'etodo sobreescrito \emph{en adici\'on a} la nueva funcionalidad que estamos definiendo en la subclase.
En \st, como en  muchos lenguajes orientados a objetos que soportan herencia simple, esto se puede hacer enviando mensajes a \super.

La aplicaci\'on mas importante de este mecanismo est\'a en el m\'etodo \ct{initialize}.
Siempre que una nueva instancia de una clase se inicializa, es fundamental tambi\'en inicializar las variables de instancia heredadas.
Sin embargo, el conocimiento de c\'omo hacer esto ya est\'a capturado en los m\'etodos \ct{initialize} de cada una de las superclases de la cadena de herencia.
!`La subclase nada tiene que hacer tratando de inicializar las variables de instancia heredadas!

Por tanto es una buena pr\'actica siempre que implementamos un m\'etodo initialize enviar \ct{super initialize} antes de realizar cualquier ulterior \ind{initialization}:
\index{super!initialize}

\needlines{6}
\begin{method}[morphinit]{Super initialize}
BorderedMorph>>>initialize
	"initialize the state of the receiver"
	super initialize.
	self borderInitialize
\end{method}

\important{Un m\'etodo \ct{initialize} siempre deber\'ia comenzar enviando \ct{super initialize}.}

%---------------------------------------------------------
%---------------------------------------------------------
\subsection{Env\'io de mensajes a self y super}

Necesitamos que los env\'ios de mensajes a \super \subind{super}{send}{}s compongan el comportamiento heredado que de otra manera ser\'ia sobreescrito.
Sin embargo la forma habitual de escribir m\'etodos, ya sea heredados o no, es por medio de env\'ios a \self \subind{self}.

?`C\'omo es que los env\'ios de mensajes a \self difieren de los env\'ios a \super ?
As\'i como \self, \super representa al receptor del mensaje.
Lo \'unico que cambia es el \ind{method lookup}.
En lugar de que la busqueda del method lookup empiece en la clase del receptor, comienza en la superclase de la clase del m\'etodo donde el env\'io a \super toma lugar.

!`Note que \super \emph{no} es la superclase!
Es un error com\'un y natural el pensar esto.
Tambi\'en es un error pensar que la b\'usqueda del method lookup comienza en la superclase del receptor.
Veremos con el siguiente ejemplo con precisi\'on c\'omo funciona esto.

Considere el mensaje \ct{constructorString}, que podemos enviarle a cualquier morph:
\begin{code}{@TEST | anEllipse | anEllipse := EllipseMorph new.}
anEllipse constructorString --> '((EllipseMorph newBounds: (0@0 corner: 50@40) color: Color yellow) setBorderWidth: 1 borderColor: Color black)'
\end{code}
El valor de retorno es una cadena de caracteres que puede ser evaluada para recrear el morph.

?`C\'omo es obtenido exactamente este resultado a trav\'es de una combinacion de env\'io de mensajes a \self y a \super ?
Primero, \ct{anEllipse constructorString} provocara que el m\'etodo \ct{constructorString} sea encontrado en la clase \ct{Morph},
como se muestra en \figref{constructorStringLookup}.

\begin{figure}[htb]
\begin{center}
\ifluluelse
	{\includegraphics[width=\textwidth]{constructorStringLookup}}
	{\includegraphics[width=0.8\textwidth]{constructorStringLookup}}
\caption{\self and \super sends\figlabel{constructorStringLookup}}
\end{center}
\end{figure}

\needlines{2}
\begin{method}[constructorString]{A \self send}
Morph>>>constructorString
	^ String streamContents: [:s | self printConstructorOn: s indent: 0].
\end{method}
El m\'etodo \cmind{Morph}{constructorString} lleva a cabo un env\'io a \self de \lct{printConstructorOn:indent:}.
Este mensaje tambi\'en se busca subiendo en la cadena de herencia, comenzando en la clase \lct{EllipseMorph}, y siendo encontrado en la clase \ct{Morph}.
Este m\'etodo, a su vez hace un env\'io a \self de \lct{printConstructorOn:indent:nodeDict:}, que hace un env\'io a \self de \ct{fullPrintOn:}.
Una vez m\'as, \ct{fullPrintOn:} se busca subiendo en la cadena de herencia comenzando por la clase \ct{EllipseMorph}, y \mthind{BorderedMorph}{fullPrintOn:} es encontrado en \ct{BorderedMorph} (v\'ea \figref{constructorStringLookup} otra vez).
Lo que es fundamental tener en cuenta es que el env\'io a \self provoca que el method lookup comience nuevamente en la clase del receptor, es decir, la clase de \ct{anEllipse}.

\important{Un env\'io a \self dispara un method lookup \emph{din\'amico} comenzando en la clase del receptor.}

\needlines{4}
\begin{method}[fullPrintOn]{Combining \super and \self sends}
BorderedMorph>>>fullPrintOn: aStream
	aStream nextPutAll: '('.
	!\textbf{super fullPrintOn: aStream.}!
	aStream nextPutAll: ') setBorderWidth: '; print: borderWidth;
		nextPutAll: ' borderColor: ' , (self colorString: borderColor)
\end{method}
At this point, \ct{BorderedMorph>>>fullPrintOn:} does a \super send to extend the 
\ct{fullPrintOn:} behaviour it inherits from its superclass.
Because this is a \super send, the lookup now starts in the superclass of the class where the \super send occurs, namely in \ct{Morph}.
We then immediately find and evaluate \ct{Morph>>>fullPrintOn:}.

Note that the \super lookup did not start in the superclass of the receiver.
This would have caused lookup to start from \ct{BorderedMorph}, resulting in an infinite loop!

\important{A \super send triggers a \emph{static} method lookup starting in the superclass of the class of the method performing the \super send.}

Si piensas cuidadosamente acerca de los env\'ios a \super y \figref{constructorStringLookup}, te dar\'as cuenta que \super bindings are static: lo \'unico que importa es la clase en la cual se encuentra el texto del env\'io a \super.
By contrast, the meaning of \self is dynamic: it always represents the receiver of the currently executing message. This means that  \emph{all}  messages sent to \self are looked-up by starting in the receiver's class.

%---------------------------------------------------------
\subsection{Mensaje no comprendido}

?`Qu\'e sucede si el m\'etodo que estamos buscando no se encuentra?
\index{message!not understood}

Supongamos que enviamos el mensaje \ct{foo} a nuestra elipse.
En primer lugar el method lookup normal subir\'a por la cadena de herencia todo el camino hasta \clsind{Object} (o m\'as bien \clsind{ProtoObject}) en busca de este m\'etodo.
Cuando este m\'etodo no se encuentra, la ind \ind{m\'aquina virtual} har\'a que el objeto envie \ct{self doesNotUnderstand: #foo}.
(See \figref{fooNotFound}.)

\begin{figure}[htb]
\begin{center}
\ifluluelse
	{\includegraphics[width=\textwidth]{fooNotFound}}
	{\includegraphics[width=0.8\textwidth]{fooNotFound}}
\caption{El mensaje \lct{foo} no se comprende\figlabel{fooNotFound}}
\end{center}
\end{figure}

Ahora, este es un envio de mensaje din\'amico perfectamente ordinario, por lo que la b\'usqueda se inicia de nuevo desde la clase \ct{EllipseMorph}, pero esta vez buscando el m\'etodo \ct{doesNotUnderstand:}.
Como resultado, \ct{Object} implementa \ct{doesNotUnderstand:}.
Este m\'etodo crear\'a un nuevo objeto \ct{MessageNotUnderstood} que sea capaz de iniciar un depurador en el contexto de ejecuci\'on actual.

?`Por qu\'e tomar este camino complicado de manejar como un error evidente?
Bueno, esto ofrece a los desarrolladores una manera f\'acil de interceptar estos errores y tomar las medidas alternativas.
Uno podr\'ia f\'acilmente reemplazar el m\'etodo \mthind{Object}{doesNotUnderstand:} en cualquier subclase de \ct{Object} y proporcionar una forma diferente de manejar el error.

De hecho, esta puede ser una manera f\'acil de implementar delegaci\'on autom\'atica de mensajes de un objeto a otro.
Un objeto \ct{Delegador} simplemente podr\'ia delegar todos los mensajes que no entiende a otro objeto cuya responsabilidad es manejarlos !`o arrojar un error mismo!

%=========================================================
\section{Variables compartidas}

Ahora echaremos un vistazo a un aspecto de \st que no queda cubierto tan facilmente por nuestras cinco reglas: las variables \subind{variable}{compartidas}.

\st proporciona tres tipos de variables compartidas: (1) variables \emph{globalmente} compartidas; (2) variables compartidas entre instancias y clases (\emph{variables de clase}), y (3) variables compartidas entre un grupo de clases (\emph{pool variables}).  Los nombres de todas esas variables compartidas comienzan con una letra mayuscula, para advertirnos que realmente estan compratidas entre m\'ultiples objetos.
% COMO TRADUZCO POOL VARIABLES?
\index{variable!global}
\index{class!variable}
\index{variable!pool}

%---------------------------------------------------------
\subsection{Variables globales}
En \pharo, todas las variables globales estan almacenadas en un namespace llamado \glbind{Smalltalk}, el cual est\'a implementado como una instancia de la clase \clsind{SystemDictionary}.
% COMO TRADUZCO namespace
Las variables globales son accesibles en todas partes. 
Cada clase es nombrada por una variable global; adem\'as, unas pocas variables globales son usadas para nombrar objetos especiales u objetos comunmente \'utiles.

La variable \glbind{Transcript} nombra una instancia de \clsind{TranscriptStream}, un flujo de datos que escribe en una ventana que se desplaza.
El siguiente c\'odigo muestra cierta informaci\'on y luego avanza a la siguiente linea en el \ct{Transcript}.

\begin{code}{}
Transcript show: 'Pharo is fun and powerful' ; cr
\end{code}

\noindent
Antes de ejecutar \menu{do it}, abre un transcript seleccionando \menu{World \go Tools \ldots \go Transcript}.

\hint{Escribir en el Transcript es lento, en especial cuando la ventana de transcript est\'a abierta. 
Asi que, si experimentas algo de lentitud y estas escribiendo en el Transcript, considera cerrarlo.}

\subsubsection{Otras variables globales \'utiles}

\begin{itemize}
\item
\ct{Smalltalk} es la instancia de \ct{SystemDictionary} que define todas las variables globales\,---\,incluyendo al mismo \ct{Smalltalk}.   
Las claves para este diccionario son los s\'imbolos que dan nombre a los objetos globales en el codigo \st.
Asi que, por ejemplo,
\begin{code}{@TEST}
Smalltalk at: #Boolean --> Boolean
\end{code}
Dado que \ct{Smalltalk} en si mismo es una variable global,
\begin{code}{}
Smalltalk at: #Smalltalk-->a SystemDictionary(lots of globals)}
\end{code} 
y
\begin{code}{@TEST}
(Smalltalk at: #Smalltalk) == Smalltalk --> true
\end{code}

\item \clsind{Sensor} es una instancia de \clsind{EventSensor}, y representa la entrada de informaci\'on a \pharo.
Por ejemplo, el \lct{Sensor keyboard} responde con el siguiente input de un caracter en el teclado, y \ct{Sensor leftShiftDown} responde \ct{true} si la tecla shift izquierda est\'a siendo oprimida, mientras que \ct{Sensor mousePoint} responde un \ct{Point} indicando la locaci\'on actual del rat\'on.

\item \glbind{World} es una instancia de \clsind{PasteUpMorph} que representa la pantalla.
\ct{World bounds} responde un rectangulo que define todo el espacio de la pantalla; todos los Morphs en la pantalla son submorphs de \ct{World}.
\index{Morphic}

\item 
\glbind{ActiveHand} es la instancia actual de \clsind{HandMorph}, la representacion gr\'afica del cursor.  Los submorphs de \ct{ActiveHand} contienen cualquier cosa que est\'e siendo arrastrada por el rat\'on.
\ab{I have never used this, and had to browse the image to see what it is!  What do you use it for?}

\item
\glbind{Undeclared} es otro diccionario\,---\,contiene todas las variables no declaradas.
Si escribes un m\'etodo que hace referencia a una variable no declarada, el navegador normalmente
te sugerir\'a declararla, por ejemplo, como una variable global o como una variable de instancia de la clase.
Sin embargo, si mas tarde borras la declaraci\'on, el c\'odigo referenciar\'a a una variable no declarada.

!`Examinar a \ct{Undeclared} puede a veces ayudar a explicar este comportamiento extra\~no!

\item
\glbind{SystemOrganization} es una instancia de \clsind{SystemOrganizer}: registra la organizaci\'on de las clases en paquetes.  Mas precisamente, clasifica los \emph{nombres} de clases, por lo que
\end{itemize}

\begin{code}{@TEST}
SystemOrganization categoryOfElement: #Magnitude --> #'Kernel-Numbers'
\end{code}

El procedimiento actual consiste en limitar estrictamente el uso de las variables globales; en general es mejor utilizar las variables de instancia de la clase o las variables de clase, y proveer m\'etodos de clase para acceder a ellas. En realidad, si \pharo hoy fuera a ser implementado desde cero, la mayoria de las variables globales que no son clases ser\'ian reemplazadas por singletons.

La manera habitual de definir una variable global es mediante el \menu{do it} en una asignacion a un identificador en mayusculas pero no declarado. The parser will then offer to declare the global for you.  If you want to define a global programmatically, just execute \ct{Smalltalk at: #AGlobalName put: nil}.  To remove it, execute \ct{Smalltalk removeKey: #AGlobalName}.
\glbindex{Smalltalk}


%---------------------------------------------------------
\subsection{Variables de clase}
\seclabel{classVars}

En ocasiones nos es necesario ,compartir informaci\'on entre todas las instancias de una clase y la clase en si. Esto es posible utilizando \emph{variables de clase}. El termino \subind{class}{variable de clase} indica que el tiempo de vida de la variable es el mismo que el de la clase. Sin embargo, lo que este termino no expresa es que estas variables son compartidas entre todas las instancias de una clase, as\'i como tambi\'en por la clase en s\'i, como se muestra en \figref{privateSharedVar}.
En efecto, un mejor nombre hubiera sido \emph{variables compartidas}, ya que este expresa m\'as claramente su rol, y adem\'as advierte del peligro de utilizarlas, en especial si son modificadas.

\begin{figure}[htb]
\begin{center}
\ifluluelse
	{\includegraphics[width=\textwidth]{privateSharedVarColor}}
	{\includegraphics[width=0.7\textwidth]{privateSharedVarColor}}
\caption{M'etodos de instancia y de clase accediendo diferentes variables.\figlabel{privateSharedVar}}
\end{center}
\end{figure}

En \figref{privateSharedVar} podemos ver que \ct{rgb} y \ct{cachedDepth} son variables de instancia de \ct{Color}, y por tanto, solo accesibles a instancias de \clsind{Color}. Tambi\'en vemos que \lct{superclass}, \lct{subclass}, \lct{methodDict}, etc. son variables de instancia de clase, \ie variables de instancia solo accesibles por la clase \lct{Color}.

Pero tambi\'en podemos ver algo nuevo: \ct{ColorNames} y \ct{CachedColormaps} son \emph{variables de clase} definidas por \ct{Color}.
La capitalizaci\'on de estas variables nos da una pista acerca de que son compartidas. De hecho, no solo pueden todas las instancias de \ct{Color} acceder estas variables compartidas, sino tambi\'en la clase \ct{Color} en s\'i, \emph{y cualquiera de sus subclases}.
Tanto los m\'etods de instancia como de clase pueden acceder estas variables compartidas.

%\begin{figure}
%\begin{center}\includegraphics[width=6cm]{dateToday}\caption{A date is an object that  represents only anumber of days; all the information about month names, day names, etc.\ is shared among all the instances \figlabel{dateToday}}\end{center}.
%\end{figure}

Una \subind{clase}{variable de clase} es definida en la plantilla de definici\'on de la clase. Por ejemplo, la clase \ct{Color} define un gran numero de variables de clase para acelerar la creaci\'on de colores; su definici\'on se muestra debajo.
A class \subind{class}{variable} is declared in the class definition template.
For example, the class \ct{Color} defines a large number of class variables to speed up color creation; its definition is shown below (\clsref{Color}).
\needlines{5}
\begin{classdef}[Color]{Color and its class variables}
Object subclass: #Color 	
        instanceVariableNames: 'rgb cachedDepth cachedBitPattern'
        classVariableNames: 'Black Blue BlueShift Brown CachedColormaps ColorChart ColorNames ComponentMask ComponentMax Cyan DarkGray Gray GrayToIndexMap Green GreenShift HalfComponentMask HighLightBitmaps IndexedColors LightBlue LightBrown LightCyan LightGray LightGreen LightMagenta LightOrange LightRed LightYellow Magenta MaskingMap Orange PaleBlue PaleBuff PaleGreen PaleMagenta PaleOrange PalePeach PaleRed PaleTan PaleYellow PureBlue PureCyan PureGreen PureMagenta PureRed PureYellow RandomStream Red RedShift TranslucentPatterns Transparent VeryDarkGray VeryLightGray VeryPaleRed VeryVeryDarkGray VeryVeryLightGray White Yellow'
        poolDictionaries: '' 	
        category: 'Graphics-Primitives'
\end{classdef}

La variable de clase \cvind{ColorNames} es un array que contiene los nombres de colores usados frecuentemente. Este array es compartido por todas las instancias de \ct{Color} y su subclase \clsind{TranslucentColor}. Es accesible desde todos los m\'etodos de instancia y de clase.
% (see \figref{ClassVarAccess2}).

\ct{ColorNames} es inicializada una vez en \cmind{Color class}{initializeNames}, pero es accedido por instancias de \ct{Color}.
El m\'etodo \cmind{Color}{name} utiliza la variable para averiguar el nombre de un color.
Ya que la mayoria de los colores no tienen nombres, se pens\'o inapropiado a\~nadir una variable de instancia \ct{name} a cada color.

\subsubsection{Inicializaci\'on de clases}

%---- accessors ?? getters?? como les llamamos
La presencia de variables de clase hace surgir la pregunta: ?`C\'omo las inicializamos? Una soluci\'on es la \subind{class}{inicializaci\'on} perezosa. Esta se puede lograr introduciendo un m\'etodo accessor el cual, cuando  es ejecutado inicializa la variable si esta no ha sido inicializada previamente. Esto implica que debemos utilizar el accessor todo el tiempo y nunca utilizar la variable directamente.
A\'un m\'as, impone el costo del env\'io del accessor y la prueba de inicializaci\'on.
Tambi\'en podr\'ia decirse que desestima la idea de usar una variable de clase, ya que de hecho esta ya no es mas compartida.

\begin{method}[colorclasscolornames]{Color class>>>colorNames}
Color class>>>colorNames	
	ColorNames ifNil: [self initializeNames].
	^ ColorNames
\end{method}	
\cmindex{Color class}{colorNames}

Otra soluci\'on es sobrescribir el m\'etodo de clase \ct{initialize}.

\needlines{3}
\begin{method}[colorclassinit]{Color class>>initialize}
Color class>>>initialize	
	!\ldots!
	self initializeNames
\end{method}	
\cmindex{Color class}{initialize}

\noindent
Si adoptas esta soluci\'on, necesitas recordar invocar el m\'etodo \ct{initialize} luego de definirlo, \eg evaluando \ct{Color initialize}.
Aunque los metodos \ct{initialize} del \subind{browser}{lado de clase} son ejecutados autom\'{a}ticamente cuando el codigo es cargado en la memoria, \emph{no} son ejecutados autom\'{a}ticamente cuando son escritos la primera vez en el navegador y compilados, o cuando son editados y re-compilados.
%---------------------------------------------------------

%%---- Pool variables? lo dejo como
\subsection{Variables de agrupamiento}
Las variables de agrupamiento son variables que se comparten entre varias clases que pueden no estar relacionadas por herencia.
Las variables de agrupamiento fueron originalmente almacenadas en diccionarios de agrupamiento; ahora deber\'ian ser definidas como variables de clase de clases dedicadas (subclases de SharedPool). Nuestro consejo es evitarlas; las necesitar\'as solo en circunstancias raras y especificas. Nuestro objetivo aqu\'i es por lo tanto explicar variables de \subind{variable}{agrupamiento} solo lo suficiente para que puedas comprenderlas cuando te encuentres leyendo c\'odigo.

Una clase que accede a una variable de agrupamiento debe mencionarla en su definici\'on de clase. Por ejemplo, la clase \clsind{Text} indica que esta usando el diccionario de agrupamiento \ct{TextConstants}, el cual contiene todas las constantes de texto, tales como \glbind{CR} y \glbind{LF}.
Este diccionario tiene una clave \ct{#CR} la cual esta ligada al valor \ct{Character cr}, \ie el caracter de retorno de carro.

\cmindex{Character class}{cr}

\begin{classdef}[textpooldict]{Pool dictionaries in the \ct{Text} class}
ArrayedCollection subclass: #Text
        instanceVariableNames: 'string runs' 	
        classVariableNames: '' 	
        !\textbf{poolDictionaries: 'TextConstants'}!
        category: 'Collections-Text'
\end{classdef}
   
Esto permite a los m\'etodos de la clase \ct{Text} acceder a las claves del diccionario en el cuerpo del m\'etodo \emph{directamente}, \ie utilizando sintaxis de variable en lugar de una b\'usqueda explicita en un diccionario.
Por ejemplo, podemos escribir el siguiente m\'etodo.
  
\begin{method}[texttestcr]{Text>>testCR}
Text>>>testCR 	
      ^ CR == Character cr
\end{method}

Una vez m\'as, recomendamos que evites el uso de variables y diccionarios de agrupamiento.

%=========================================================
\section{Resumen del cap\'itulo}

El modelo de objetos de \pharo es tanto simple como uniforme.
Todo es un objeto, y practicamente todo sucede mediante el envio de mensajes.

\begin{itemize}
  \item Todo es un objeto.
  Entidades primitivas como los enteros son objetos, pero tambi\'en las clases son objetos de primer orden.

  \item Todo objeto es instancia de una clase.
  Las clases definen la estructura de sus instancias a trav\'es de variables de instancia \emph{privadas} y su comportamiento mediante m\'etodos \emph{p\'ublicos}. Cada clase es la \'unica instancia de su metaclase. Las variables de clase son variables privadas compartidas entre la clase y todas sus instancias.
  Las clases no pueden acceder directamente a las variables de instancia de sus instancias, y las instancias no pueden acceder a las variables de instancia de su clase. Se deben definir accessors si esto fuera necesario.

  \item Toda clase tiene una superclase.
  La ra\'iz de la jerarqu\'ia de herencia es \lct{ProtoObject}.
  Las clases que definas, sin embargo, deber\'ian normalmente heredar de \ct{Object} o sus subclases.
  No hay una sintaxis para definir clases abstractas.
  Una clase abstracta es simplemente una clase con un m\'etodo abstracto\,---\,uno cuya implementaci\'oon consiste en la expresi\'on \ct{self subclassResponsibility}.
  Aunque \pharo soporta solo herencia simple, es f\'acil compartir implementaciones de m\'etodos agrup\'andolos como \emph{traits}.

  \item Todo sucede mediante el env\'io de mensajes
	No ``llamamos m\'etodos'', ``enviamos mensajes''.
	El receptor luego elije su propio m\'etodo para responder al mensaje.

  \item El method lookup sigue la cadena de herencia;
  Los env\'ios a \self son din\'amicos y comienzan el method lookup nuevamente desde la clase del receptor, mientras que
  los env\'ios a \super son est\'aticos, y comienzan en la superclase de la clase en la cual el env\'io a super fue escrito.
  
  \item Hay tres tipos de variables compartidas.
		Las variables globales son accesibles desde cualquier lugar del sistema.
		Las variables de clase son compartidas por una clase y sus subclases e instancias.
		Las variables de agrupamiento son compartidas por un grupo seleccionado de clases.
		Deber\'ias evitar las variables compartidas tanto como te sea posible.

\end{itemize}



%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=========================================================

%=================================================================
%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:

%---------------------------------------------------------
