% $Author$
% $Date$
% $Revision$

% HISTORY: [see also Metaprogramming2.tex]
% 2007-05-22 - Damien Pollet started (translation from French article by ...?)
% 2008-01-15 - Alex added text
% 2008-12-15 - Oscar revised
% 2009-03-24 - Stef started new chapter (acttalk ... see separate file)
% 2009-06-01 - Oscar started to revise again and add new material
% 2009-06-08 - Lukas -- unsent messages
% 2009-06-15 - Oscar completed revision
% 2009-06-16 _ Stef comments
% 2009-06-17 - Alexandre completed revision
% 2009-06-19 - Lukas comments
% 2009-07-07 - Oscar migrated to Pharo; fixed broken tests
% 2009-08-16 - Oscar indexing and cleaning up loose ends

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
        \documentclass[a4paper,10pt,twoside]{book}
        \usepackage[
                papersize={6.13in,9.21in},
                hmargin={.75in,.75in},
                vmargin={.75in,1in},
                ignoreheadfoot
        ]{geometry}
        \input{../common.tex}
        \pagestyle{headings}
        \setboolean{lulu}{true}
% --------------------------------------------
% A4:
%       \documentclass[a4paper,11pt,twoside]{book}
%       \input{../common.tex}
%       \usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
        \begin{document}
        % \renewcommand{\nnbb}[2]{} % Disable editorial comments
        \sloppy
\fi

%=================================================================
\chapter{Reflexi\'on}\chalabel{reflection}

\indexmain{reflection}
\st es un lenguaje de programaci\'on con reflexi\'on computacional.
En pocas palabras, quiere decir que los programas son capaces de
«reflexionar» sobre su propia ejecuci\'on y estructura.
% \lr{not only on execution, also on the static model}
% pp 301 cesar
En un sentido m\'as t\'ecnico, esto significa que
los \emphind{metaobjetos} del sistema en tiempo de ejecuci\'on
pueden \emph{reificarse} como objetos ordinarios, a los cuales se
puede consultar e inspeccionar.  Los metaobjetos en \st son las
clases, metaclases, diccionarios de m\'etodos, m\'etodos compilados, la
pila al momento de ejecuci\'on, y otros.  Esta forma de reflexi\'on
tambi\'en se denomina \emphind{introspecci\'on}, y muchos lenguajes
modernos de programaci\'on la permiten.

\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{reflect}
        \caption{Reificaci\'on y reflexi\'on.\figlabel{reflect}} % \lr{not referenced, not sure if I understand it}
\end{figure}

En el sentido contrario, en \st resulta posible modificar los
metaobjetos reificados y \emph{reflejar} esos cambios de vuelta al
sistema en ejecuci\'on (puedes verlo en la \figref{reflect}).  Esta
actividad tambi\'en se denomina \emph{intercesi\'on}. La intercesi\'on est\'a
presente principalmente en los lenguajes de programaci\'on din\'amicos
mientras que los lenguajes est\'aticos s\'olo la admiten en un grado muy
limitado.

Un programa que manipula otros programas (o se manipula a s\'i mismo) es
un \emphind{metaprograma}.  Para que un lenguaje de programaci\'on sea
capaz de reflexi\'on computacional debe permitir tanto la
\ind{introspecci\'on} como la \ind{intercesi\'on}.  La introspecci\'on es la
capacidad de \emph{examinar} las estructuras de datos que definen el
lenguaje, como los objetos, clases, m\'etodos y la pila de ejecuci\'on.
La intercesi\'on es la capacidad de \emph{modificar} dichas estructuras,
o sea, de alterar la sem\'antica del lenguaje y el comportamiento del
programa desde el interior del propio programa.  La \emph{reflexi\'on
  estructural} examina y modifica la estructura del sistema de tiempo
de ejecuci\'on y la \emphind{reflexi\'on de comportamiento} modifica la
interpretaci\'on de esas estructuras.

En este cap\'itulo nos enfocaremos principalmente en la \ind{reflexi\'on
  estructural}. Vamos a explorar muchos ejemplos pr\'acticos que
ilustrar\'an como \st permite la introspecci\'on y la metaprogramaci\'on.

%======================================
\section{Introspecci\'on}

Mediante el inspector, puedes mirar dentro de un objeto, cambiar los
valores de sus variables de instancia, e incluso enviarle mensajes.

\dothis{Eval\'ua el siguiente c\'odigo en un workspace:}
\begin{code}{| w |}
w := Workspace new.
w openLabel: 'My workspace'.
w inspect.
\end{code}

Esto va a abrir un segundo workspace y un inspector.  El inspector
muestra el estado interno de este nuevo espacio de trabajo, lista sus
variables de instancia en la parte izquierda (\ct!dependents!,
\ct!contents!, \ct!bindings!, \ldots) y en la parte derecha se ve el
valor de la variable de instancia seleccionada.  La variable de
instancia \ct!contents! representa lo que se muestra en el \'area de
texto del espacio de trabajo, as\'i que si lo seleccionas, la parte
derecha va a mostrar una cadena vac\'ia.

\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{workspaceInspector}
        \caption{Inspecci\'on de un \ct!Workspace!.\figlabel{workspaceInspector}}
\end{figure}

\dothis{Ahora escribe \ct!'hello'! en lugar de esa cadena vac\'ia, y
  luego \emph{ac\'eptala}.}

El valor de la variable \ct!contents! va a cambiar, pero la ventana
del espacio de trabajo no se percata de ello, as\'i que no se vuelve a
regenerar lo que muestra.  Para que se refresque el contenido en la
ventana, eval\'ua \ct!self contentsChanged!  en la parte inferior del
inspector.

%-----------------------------------------------------------------
\subsection{C\'omo se accede a las variables de instancia}


¿C\'omo funciona el inspector?  En \st, todas las variables de instancia
son protegidas.  En teor\'ia, es imposible accederlas desde otro objeto
si la clase no define sus accesores.  En la pr\'actica, el
inspector puede acceder a las variables de instancia sin necesidad de
accesores, porque usa las capacidades de reflexi\'on computacional de
\st.  En \st, las clases definen variables de instancia o bien
mediante un nombre o bien mediante un \'indice num\'erico.  El inspector
usa m\'etodos definidos en la clase \ct!Object! para accederlas:
\lct{instVarAt: \emph{index}} y \lct{instVarNamed: \emph{aString}} se
usan para acceder al valor de la variable de instancia en la posici\'on
\lct{\emph{index}} o aquella cuyo nombre es \lct{\emph{aString}},
respectivamente; para asignar nuevos valores a esas variables de
instancia utiliza \ct!instVarAt:put:! y \ct!instVarNamed:put:!.
\mthindex{Object}{instVarAt:} \mthindex{Object}{instVarNamed:}
\mthindex{Object}{instVarAt:put:} \mthindex{Object}{instVarNamed:put:}

Por ejemplo, puedes cambiar el valor asociado a \ct!w! en el primer
espacio de trabajo mediante la evaluaci\'on de:
\begin{code}{}
w instVarNamed: 'contents' put: 'howdy!'; contentsChanged
\end{code}

\important{\emph{Precauci\'on:} Aunque estos m\'etodos resultan \'utiles
  para construir herramientas de desarrollo, es una mala idea usarlos
  para desarrollar aplicaciones convencionales: estos m\'etodos de
  reflexi\'on computacional violan los l\'imites de la encapsulaci\'on de
  los objetos y por lo tanto pueden hacer que tu c\'odigo sea mucho m\'as
  dif\'icil de comprender y mantener.}
  % \lr{Why? The access does not show up when looking for all
  %   readers/writers in the code browser.}

Tanto \ct!instVarAt:! como \ct!instVarAt:put:! son \ind{m\'etodos
  primitivos}, lo que significa que est\'an implementados como
operaciones primitivas de la m\'aquina virtual de \pharo.  Si revisas el
c\'odigo de esos m\'etodos ver\'as la sintaxis especial \ind{pragma}
\ct!<primitive: N>! donde \ct!N! es un entero.
% \lr{actually this is the syntax of pragmas (method annotations),
%   \ct!primitive:! is just a special kind of pragma}

\needlines{5}
\begin{code}{}
Object>>>instVarAt: index
        "Primitive. Answer a fixed variable in an object. ..."
        !\textbf{<primitive: 73>}!
        "Access beyond fixed variables."
        ^self basicAt: index - self class instSize
\end{code}

En el caso m\'as usual no se ejecuta el c\'odigo que sigue a la invocaci\'on
de la primitiva.  S\'olo se ejecuta si la primitiva falla.  En este caso
espec\'ifico, si tratamos de acceder una variable que no existe entonces
se ejecuta el c\'odigo que sigue a la primitiva.  De este modo se
permite tambi\'en que el debugger se inicie sobre m\'etodos primitivos.
Aunque es posible modificar el c\'odigo de los m\'etodos primitivos, debes
entender que es una actividad de alto riesgo para la estabilidad de tu
sistema \pharo.

\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{allInstanceVariables}
        \caption{Vista de todas las variables de instancia de un \ct!Workspace!.\figlabel{allInstanceVariables}}
\end{figure}

La \figref{allInstanceVariables} muestra c\'omo pueden verse los valores
de las variables de instancia de una instancia arbitraria (\ct!w!) de
la clase \ct!Workspace!.  El m\'etodo \ct!allInstVarNames! retorna todos
los nombres de las variables de instancia de una clase dada.

De manera similar, es posible conseguir las instancias que tienen
ciertas propiedades espec\'ificas.  Por ejemplo, para obtener todas las
instancias de la clase \ct!SketchMorph! cuya variable de instancia
\ct!owner! est\'a asociada al morph mundo (o sea, las im\'agenes que se
muestran en este momento), prueba la siguiente expresi\'on:
\begin{code}{}
SketchMorph allInstances select: [:c | (c instVarNamed: 'owner') isWorldMorph]
\end{code}

%-----------------------------------------------------------------
\subsection{C\'omo recorrer las variables de instancia}

\mthindex{Object}{instanceVariableValues}
Consideremos el mensaje \ct!instanceVariableValues!, que devuelve una
colecci\'on de todos los valores de variables de instancia definidos en
dicha clase, sin tener en cuenta las variables de instancia
heredadas.  Por ejemplo:
\begin{code}{@TEST}
(1@2) instanceVariableValues --> an OrderedCollection(1 2)
\end{code}

El m\'etodo est\'a implementado en \ct{Object} como se muestra a
continuaci\'on:
\needlines{9}
\begin{code}{}
Object>>>instanceVariableValues
        "Answer a collection whose elements are the values of those instance variables of the receiver which were added by the receiver's class."
        | c |
        c := OrderedCollection new.
        self class superclass instSize + 1
                to: self class instSize
                do: [ :i | c add: (self instVarAt: i)].
        ^ c
\end{code}

Este m\'etodo itera sobre los \'indices de las variables de instancia que
est\'an definidas en la clase; el primer valor corresponde al primer
\'indice no usado por la superclase.  (El m\'etodo \ct!instSize! retorna
la cantidad de variables de instancia nominadas que define una clase)

%-----------------------------------------------------------------
\subsection{C\'omo consultar clases e interfaces}

Tods las herramientas de desarrollo de \pharo (code browser,
debugger, inspector\ldots) utilizan las caracter\'isticas de reflexi\'on
computacional que hemos visto hasta ahora.

Se muestran a continuaci\'on otros mensajes que pueden resultar \'utiles
para construir herramientas de desarrollo:

\lct{isKindOf: \emph{aClass}} retorna true si el receptor es una
instancia de \lct{\emph{aClass}} o una de sus superclases.  Por
ejemplo:
\begin{code}{@TEST}
1.5 class                     --> Float
1.5 isKindOf: Number --> true
1.5 isKindOf: Integer   --> false
\end{code}
\mthindex{Object}{class}
\mthindex{Object}{isKindOf:}

\lct{respondsTo: \emph{aSymbol}} returna true si el receptor tiene un
m\'etodo cuyo selector es \lct{\emph{aSymbol}}.
Por ejemplo:
\needlines{3}
\begin{code}{@TEST}
1.5 respondsTo: #floor      --> true    "pues Number implementa floor"
1.5 floor                            --> 1
Exception respondsTo: #, --> true    "las clases de exception se pueden agrupar"
\end{code}
\mthindex{Object}{respondsTo:}

\important{\emph{Precauci\'on:} Aunque estas caracter\'isticas resultan
  especialmente \'utiles para escribir herramientas de desarrollo,
  normalmente no son apropiadas para escribir aplicaciones t\'ipicas.
  Cuando uno consulta a un objeto para saber su clase o para saber
  a cu\'ales mensajes responde, estamos en presencia de señales t\'ipicas
  que apuntan a problemas de diseño, pues estas consultas violan el
  principio de encapsulaci\'on.  Las herramientas de desarrollo, sin
  embargo, no son aplicaciones normales, pues su dominio es el del
  software en s\'i mismo.  Por ello, estas herramientas tienen derecho a
  indagar profundamente en los detalles internos del c\'odigo.}

% There also exist mechanisms for introspecting on various parts of
% the run-time system, such as the process scheduler, the memory
% manager and so on. For now we will focus on navigating through
% objects, classes and methods, and we will look more closely at rest
% of the runtime system in an other chapter.  \on{let's not mention
%   this if we don't actually write such a chapter!}

%-----------------------------------------------------------------
\subsection{M\'etricas de c\'odigo}

Veamos c\'omo podemos usar las caracter\'isticas de introspecci\'on de \st
para extraer r\'apidamente algunas m\'etricas de c\'odigo.  Las
\ind{m\'etricas} de c\'odigo miden aspectos tales como la profundidad de
la jerarqu\'ia de herencia, la cantidad directa e indirecta de
subclases, la cantidad de m\'etodos o de variables de instancia en cada
clase, o la cantidad de m\'etodos o variables de instancia definidos
localmente.  A continuaci\'on se muestran unas m\'etricas para la clase
\ct!Morph!, que es la superclase de todos los objetos gr\'aficos en
\pharo, y que revelan que se trata de una clase enorme, y que es la
ra\'iz de una enorme jerarqu\'ia. ¡Tal vez est\'a necesitada de un poco de
refactoring!

\mthindex{Behavior}{allSuperclasses}
\mthindex{Behavior}{allSelectors}
\mthindex{Behavior}{allInstVarNames}
\mthindex{Behavior}{selectors}
\mthindex{Behavior}{instVarNames}
\mthindex{Behavior}{subclasses}
\mthindex{Behavior}{allSubclasses}
\mthindex{ClassDescription}{linesOfCode}
\begin{code}{}
Morph allSuperclasses size.  -->       2 "profundidad de la herencia"
Morph allSelectors size.        --> 1378 "cantidad de metodos"
Morph allInstVarNames size. -->      6 "cantidad de variables de instancia"
Morph selectors size.             -->  998 "cantidad de nuevos metodos"
Morph instVarNames size.     -->      6 "cantidad de nuevas variables"
Morph subclasses size.          -->    45 "cantidad de subclases directas"
Morph allSubclasses size.      -->  326 "total de subclases"
Morph linesOfCode.               --> 5968 "cantidad total de lineas de codigo"
\end{code}

Una de las m\'etricas m\'as interesantes en el dominio de los lenguajes
orientados a objetos es la cantidad de m\'etodos que extienden m\'etodos
heredados desde la superclase.  Ella nos informa de la relaci\'on entre
la clase y sus superclases.  En las siguientes secciones veremos c\'omo
aprovechar nuestro conocimiento de la estructura de tiempo de
ejecuci\'on para responder estas cuestiones.

%======================================
\section{C\'omo navegar por el c\'odigo}

En \st, todo es un objeto.  En particular, las clases son objetos que
nos proporcionan mecanismos \'utiles para navegar entre sus instancias.
La mayor\'ia de los mensajes que vamos a estudiar est\'an implementados en
\ct{Behavior} y por lo tanto todas las clases responden a ellos.

Como ya vimos antes, puedes obtener una instancia de una clase dada si
le env\'ias el mensaje \ct!#someInstance!.
\mthindex{Behavior}{someInstance}
\begin{code}{@TEST} % Possibly fragile!
Point someInstance --> 0@0
\end{code}

Adem\'as, puedes obtener todas las instancias con \ct!#allInstances!, y
la cantidad de instancias activas en memoria con \ct!#instanceCount!.

\alex{In a Pharo0.1-10342dev09.96.3, I have "ByteString instanceCount
  --> 63607"}
\mthindex{Behavior}{allInstances}
\mthindex{Behavior}{instanceCount}
\mthindex{Behavior}{allSubInstances}
\begin{code}{} % Cannot test this
ByteString allInstances        --> #('collection' 'position'  ...)
ByteString instanceCount    --> 104565
String allSubInstances size -->  101675
\end{code}

Estas caracter\'isticas pueden resultar muy \'utiles al depurar una
aplicaci\'on, porque puedes solicitar a una clase que enumere aquellos
de sus m\'etodos que exhiben ciertas propiedades.
\begin{itemize}
\item \mthind{Behavior}{whichSelectorsAccess:} retorna la lista de
  todos los selectores de m\'etodos que leen o escriben la variable de
  instancia nombrada por el argumento
\item \mthind{Behavior}{whichSelectorsStoreInto:} retorna los
  selectores de m\'etodos que modifican el valor de una variable de
  instancia dada
\item \mthind{Behavior}{whichSelectorsReferTo:} retorna los selectores
  de m\'etodos que env\'ian un dado mensaje
\item \mthind{Behavior}{crossReference} asocia cada mensaje con el
  conjunto de m\'etodos que lo env\'ian.
\end{itemize}

\begin{code}{} % TOO FRAGILE TO TEST
Point whichSelectorsAccess: 'x'    --> an IdentitySet(#'\\' #= #scaleBy: ...)
Point whichSelectorsStoreInto: 'x' --> an IdentitySet(#setX:setY: ...)
Point whichSelectorsReferTo: #+  --> an IdentitySet(#rotateBy:about: ...)
Point crossReference --> an Array(
                an Array('*' an IdentitySet(#rotateBy:about: ...))
                an Array('+' an IdentitySet(#rotateBy:about: ...))
                ...)
\end{code}

Los siguientes mensajes tienen en cuenta a la herencia:

\begin{itemize}
\item \mthind{Behavior}{whichClassIncludesSelector:} retorna la
  superclase que implementa el mensaje dado
\item \mthind{Behavior}{unreferencedInstanceVariables} retorna la
  lista de variables de instancia que no se usan en la clase del
  receptor ni en sus subclases.
\end{itemize}

\begin{code}{@TEST}
Rectangle whichClassIncludesSelector: #inspect --> Object
Rectangle unreferencedInstanceVariables            --> #()
\end{code}

\clsind{SystemNavigation} es una fachada [facade] que incluye varios
m\'etodos \'utiles para consultar y navegar a trav\'es del c\'odigo fuente del
sistema.  \ct{SystemNavigation} \mthind{SystemNavigation
  class}{default} retorna una instancia que puedes usar para navegar
por el sistema.  Por ejemplo:

\mthindex{SystemNavigation}{allClassesImplementing:}
\begin{code}{@TEST}
SystemNavigation default allClassesImplementing: #yourself --> {Object}
\end{code}

Los siguientes mensajes se explican solos:

\mthindex{SystemNavigation}{allSentMessages}
\mthindex{SystemNavigation}{allUnsentMessages}
\mthindex{SystemNavigation}{allUnimplementedCalls}
\begin{code}{}
SystemNavigation default allSentMessages size          --> 24930
SystemNavigation default allUnsentMessages size      --> 6431
SystemNavigation default allUnimplementedCalls size --> 270
\end{code}

Que un mensaje est\'e implementado y que nadie lo env\'ie no es
necesariamente una señal de un mensaje in\'util, pues puede ser que se
lo env\'ie impl\'icitamente (por ejemplo, mediante \ct{perform:}).  Los
mensajes que se env\'ian pero no est\'an implementados son m\'as
problem\'aticos, porque los m\'etodos que env\'ian esos mensajes van a
fallar en tiempo de ejecuci\'on.  Son la señal de una implementaci\'on sin
terminar, APIs obsoletas o bibliotecas faltantes.

\mthindex{SystemNavigation}{allCallsOn:}
\ct!SystemNavigation default allCallsOn: #Point! retorna todos los
mensajes enviados expl\'icitamente a \ct!Point! como receptor.

Todas estas caracter\'isticas est\'an integradas en el entorno de
programaci\'on de \pharo, en particular en los navegadores de c\'odigo.
Como ya conocer\'as, hay atajos de teclado convenientes para navegar por
todos los i\underline{m}plementors (\short{m}) y se\underline{n}ders
(\short{n}) de un mensaje dado.  Lo que tal vez no resulte tan
conocido es que hay muchas consultas preparadas que est\'an
implementadas como m\'etodos de la clase \ct{SystemNavigation} en el
protocolo \prot{browsing}.  Por ejemplo, puedes encontrar
program\'aticamente todos los implementadores del mensaje \ct{ifTrue:}
mediante la evaluaci\'on de:
\mthindex{SystemNavigation}{browseAllImplementorsOf:}
\begin{code}{}
SystemNavigation default browseAllImplementorsOf: #ifTrue:
\end{code}

\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{implementors}
        \caption{Implementadores de \ct!\#ifTrue:!.\figlabel{implementors}}
\end{figure}

Los m\'etodos \ct{browseAllSelect:} y
\lct{browseMethodsWithSourceString:} son particularmente \'utiles.  A
continuaci\'on se muestran dos manera diferentes de revisar todos los
m\'etodos en el sistema que env\'ian mensajes a super (la primera es m\'as
bien por fuerza bruta; la segunda es mejor y elimina algunos falsos
positivos):
\mthindex{SystemNavigation}{browseMethodsWithSourceString:}
\mthindex{SystemNavigation}{browseAllSelect:}
\begin{code}{}
SystemNavigation default browseMethodsWithSourceString: 'super'.
SystemNavigation default browseAllSelect: [:method | method sendsToSuper ].
\end{code}

%======================================
\section{Clases, dicionarios de m\'etodos y m\'etodos}

Como las clases son objetos, podemos inspeccionarlas o explorarlas
como a cualquier otro objeto.

\mthindex{Object}{explore}
\dothis{Eval\'ua \ct{Point explore}.}

En \figref{CompiledMethod}, el \ind{explorer} muestra la estructura de
la clase \clsind{Point}.  Puedes ver que la clase almacena sus m\'etodos
en un diccionario, indexados por su selector.  El selector \ct{#*}
apunta al \ind{bytecode} descompilado de \ct!Point>>>*!.

\begin{figure}[ht]\centering
        \includegraphics[width=.5\linewidth]{CompiledMethod}
        \caption{Explorer:la clase \ct!Point! y el bytecode de su m\'etodo \ct!\#*!.\figlabel{CompiledMethod}}
\end{figure}

Vamos a considerar la relaci\'on entre clases y m\'etodos.  En
\figref{MethodsAsObjects} vemos que las clases y metaclases tienen en
com\'un a la superclase \ct{Behavior}.  Aqu\'i es donde se define a
\mthind{Behavior}{new}, entre otros m\'etodos para las clases.  Cada
clase tiene un diccionario de m\'etodos, el cual mapea selectores de
m\'etodos en \ind{m\'etodos compilados}.  Cada m\'etodo compilado conoce la
clase en la cual est\'a instalado.  En \figref{CompiledMethod} podemos
ver incluso que esto se almacena en una asociacion en \ct{literal5}.

\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{MethodsAsObjects}
        \caption{Clases, diccionarios de m\'etodos y m\'etodos compilados\figlabel{MethodsAsObjects}}
\end{figure}

Podemos aprovechar las relaciones entre clases y m\'etodos para realizar
consultas sobre el sistema.  Por ejemplo, para descubrir cu\'ales
m\'etodos han sido recientemente incorporados por una dada clase (o sea,
m\'etodos que no sobrecargan m\'etodos de las superclases) podemos navegar
desde la clase al dicionario de m\'etodos como se muestra a
continuaci\'on:
\mthindex{Behavior}{methodDict}
\begin{code}{}
[:aClass| aClass methodDict keys select: [:aMethod |
  (aClass superclass canUnderstand: aMethod) not ]] value: SmallInteger
  --> an IdentitySet(#threeDigitName #printStringBase:nDigits: ...)
\end{code}

El m\'etodo compilado no almacena solamente los bytecodes del m\'etodo.
Es un objeto que proporciona muchos m\'etodos \'utiles para consultar el
sistema.  Uno de tales m\'etodos es \ct{isAbstract} (que nos indica si
el m\'etodo env\'ia \ct{subclassResponsibility}).  Podemos usarlo para
identificar todos los m\'etodos abstractos de una clase abstracta.
\needlines{4}
\begin{code}{}
[:aClass| aClass methodDict keys select: [:aMethod |
  (aClass>>aMethod) isAbstract ]] value: Number
  --> an IdentitySet(#storeOn:base: #printOn:base: #+ #- #* #/ ...)
\end{code}
Advierte como este c\'odigo env\'ia el mensaje \ct{>>} a una clase para
obtener el m\'etodo compilado de un selector dado.

% As a slightly more complex example, we can browse

Para pasear por los sends a super dentro de una jerarqu\'ia dada, por
ejemplo dentro de la jerarqu\'ia de Collection, podemos realizar una
consulta m\'as sofisticada:
\begin{code}{}
class := Collection.
SystemNavigation default
  browseMessageList: (class withAllSubclasses gather: [:each |
    each methodDict associations
      select: [:assoc | assoc value sendsToSuper]
      thenCollect: [:assoc | MethodReference class: each selector: assoc key]])
  name: 'Supersends of ' , class name , ' and its subclasses'
\end{code}
Nota como navegamos desde las clases a los diccionarios de m\'etodos,
hasta los m\'etodos compilados para identificar los m\'etodos en los
cuales estamos interesados.  El \ct{MethodReference} es un proxy
liviano para un m\'etodo compilado; muchas herramientas utilizan estos
proxys.  Hay un m\'etodo de facilitaci\'on llamado
\clsmthind{CompiledMethod}{methodReference} que retorna la referencia
de m\'etodo de un m\'etodo compilado.
\begin{code}{@TEST}
(Object>>#=) methodReference methodSymbol --> #=
\end{code}

%======================================
\section{Entornos de navegaci\'on}

A\'un cuando \clsind{SystemNavigation} ofrece algunas maneras
program\'aticas que resultan \'utiles a la hora de consultar y navegar por
el c\'odigo del sistema mediante, hay otro m\'etodo mejor.  El
\ind{Refactoring Browser}, que est\'a integrado en \pharo, proporciona
tanto una v\'ia interactiva como una program\'atica para realizar
consultas complejas.

Supongamos que queremos averiguar cu\'ales de los m\'etodos dentro de la
jerarqu\'ia \lct{Collection} env\'ian un mensaje a \super que sea diferente
del selector del m\'etodo.  Esto se considera un mal \ind{olor de
  c\'odigo} [code smell], porque el send a \super normalmente deber\'ia
poder reemplazarse por un send a \self. (Pi\'ensalo por un momento: la
\emph{necesidad} de \super se debe a que lo utilizamos para extender
el m\'etodo que estamos sobrecargando; ¡todos los otros m\'etodos
heredados se pueden acceder mediante mensajes a \self!

El navegador de refactoreo [refactoring browser] nos proporciona una
manera elegante de restringir la consulta s\'olo a las clases y m\'etodos
en los cuales estamos interesados.


En \figref{sendDifferentSuper} podemos ver que hay 19 m\'etodos con esas
caracer\'isticas dentro de la jerarqu\'ia \ct{Collection}, entre los
cuales est\'a \ct{Collection>>>printNameOn:}, que env\'ia el mensaje
\ct{super printOn:}.
\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{sendDifferentSuper}
        \caption{C\'omo encontrar m\'etodos que env\'ian un mensaje a \super diferente.\figlabel{sendDifferentSuper}}
\end{figure}

Los entornos de navegaci\'on tambi\'en se pueden crear program\'aticamente.
A continuaci\'on, por ejemplo, vamos a crear un nuevo
\clsind{BrowserEnvironment} para \clsind{Collection} y sus subclases,
seleccionaremos los m\'etodos que env\'ian mensajes a \super y abriremos
el entorno resultante.
\needlines{4}
\begin{code}{}
((BrowserEnvironment new forClasses: (Collection withAllSubclasses))
        selectMethods: [:method | method sendsToSuper])
        label: 'Collection methods sending super';
        open.
\end{code}{}

Puedes notar c\'omo esta forma es considerablemente m\'as compacta que la
anterior, cuando usamos \ct{SystemNavigation}.

Por \'ultimo, podemos buscar aquellos m\'etodos que env\'ian un \super
diferente en forma program\'atica como se muestra a continuaci\'on:
\needlines{6}
\begin{code}{}
((BrowserEnvironment new forClasses: (Collection withAllSubclasses))
        selectMethods: [:method |
                method sendsToSuper
                and: [(method parseTree superMessages includes: method selector) not]])
        label: 'Collection methods sending different super';
        open
\end{code}

En este caso solicitamos a cada m\'etodo compilado su \'arbol sint\'actico
(del Refactoring Browser) para ver cu\'ales de los mensajes a \super
difieren del selector del m\'etodo.  Para ver qu\'e se puede hacer con los
\'arboles sint\'acticos, echa una mirada al protocolo \prot{querying} de
la clase \ct{RBProgramNode}.

%======================================
\section{C\'omo acceder al contexto de tiempo de ejecuci\'on}

Ya hemos visto como las capacidades de reflexi\'on de \st nos permiten
consultar y explorar objetos, clases y m\'etodos.  ¿Y qu\'e podemos hacer
con el entorno de ejecuci\'on?

%-----------------------------------------------------------------
\subsection{Contexto de los m\'etodos}

De hecho, el contexto de tiempo de ejecuci\'on de un m\'etodo que est\'a
corriendo reside en la m\'aquina virtual --- ¡ni siquiera est\'a en la
imagen!  Por otro lado, el \ind{debugger} obviamente tiene acceso a
esta informaci\'on, y podemos explorar con facilidad el contexto de
tiempo de ejecuci\'on, al igual que hacemos con cualquier otro objeto.
¿C\'omo puede ser esto posible?

En realidad, no hay nada de magia en el depurador.  El secreto es la
seudovariable \pvind{thisContext}, que ya hemos visto antes, aunque
s\'olo de pasada.  Cuando se referencia a \ct{thisContext} dentro de un
m\'etodo en ejecuci\'on, se reifica el contexto completo de ejecuci\'on de
dicho m\'etodo y a ese objeto se lo deja accesible a la imagen en la
forma de una serie de objetos \clsind{MethodContext} encadenados.

Podemos hacer unos experimentos on este mecanismo.

\dothis{Cambia la definici\'on de \ct{Integer>>>factorial}, para ello
  inserta la expresi\'on subrayada que se muestra m\'as abajo:}

\mthindex{Object}{halt}
\begin{code}{}
Integer>>>factorial
        "Answer the factorial of the receiver."
        self = 0 ifTrue: [!\underline{thisContext explore. self halt.}! ^ 1].
        self > 0 ifTrue: [^ self * (self - 1) factorial].
        self error: 'Not valid for negative integers'
\end{code}

\dothis{Ahora eval\'ua \ct{3 factorial} en un espacio de trabajo.
  Deber\'ias ver tanto una ventana de depurador como un explorador, tal
  como se muestra en \figref{exploringThisContext}.}

\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{exploringThisContext}
        \caption{ C\'omo explorar
          \lct{thisContext}.\figlabel{exploringThisContext}}
\end{figure}

¡Bienvenido al depurador del pobre!
Si navegas ahora por la clase del objeto explorado (eval\'ua \ct{self browse}
en el panel inferior del explorador) vas a descubrir que es
una instancia de la clase \lct{MethodContext}, tal como cada uno de
los \ct{sender} en la cadena.

% All of these objects have been created dynamically in the image by
% the \st virtual machine at the point where \ct{thisContext} was
% referred to in the \ct{factorial} method. \lr{Not actually. In all
%   the currently available VMs the context objects are created with
%   every method activation, no matter if they are accessed using
%   \ct{thisContext} or not.}

\ct{thisContext} no est\'a pensado para usarse en la programaci\'on
cotidiana, pero es esencial en la implementaci\'on de herramientas tales
como los depuradores, y para acceder a la informaci\'on de la pila de
llamadas.  Puedes evaluar la siguiente expresi\'on para descubrir cu\'ales
m\'etodos utilizan a \ct{thisContext}:

\begin{code}{}
SystemNavigation default browseMethodsWithSourceString: 'thisContext'
\end{code}

Como puedes ver, una de las aplicaciones m\'as comunes es para descubrir
el remitente de un mensaje.  A continuaci\'on se muestra una aplicaci\'on
t\'ipica:
\begin{code}{}
Object>>>subclassResponsibility
        "This message sets up a framework for the behavior of the class' subclasses.
        Announce that the subclass should have implemented this message."

        self error: 'My subclass should have overridden ', thisContext sender selector printString
\end{code}

Por convenci\'on, los m\'etodos en \st que env\'ian \ct{self subclassResponsibility}
se consideran abstractos.  Ahora bien, ¿c\'omo
hace \clsmthind{Object}{subclassResponsibility} para proporcionar un
mensaje de error \'util que indique cu\'al de los m\'etodos abstractos ha
sido invocado?  Muy simple, preguntando cu\'al es el \ct{thisContext}
del remitente.

\lr{I think co-routines and continuations should at least mentioned
  here. Another very practical application that is simple and could be
  shown here is the ``escaper''. Store the current context into a temp
  or inst-var \ct{target := thisContext} and jump back to that stack
  frame at a later point in time using \ct{target return: 123}.}
\sd{lukas maybe we should have another chapter showing such kind of
  beasts. I would love to read it.  Showing how to use block to build
  exception and such a kind of point. I think that this chapter should
  be an introduction may be we should have a Reflection applied
  chapter} \lr{I would love to help writing such a chapter}
%-----------------------------------------------------------------
\subsection{Puntos de interrupci\'on inteligentes}

\mthindex{Object}{halt}

La manera a la \st de crear un punto de interrupci\'on [breakpoint]
consiste en evaluar \ct{self halt} en una posici\'on interesante de un
m\'etodo.  Esto hace que \ct{thisContext} se reifique y que se abra una
ventana de \ind{debugger} sobre el punto de interrupci\'on.
Desafortunadamente, esto plantea problemas para los m\'etodos
intensamente usados en el sistema.

Supongamos, por ejemplo, que deseamos explorar la ejecuci\'on de
\ct{OrderedCollection>>>add:}.  Resulta problem\'atico configurar un
punto de interrupci\'on en este m\'etodo.

\dothis{Toma una imagen \emph{fresca} y configura los siguientes
  puntos de interrupci\'on:}
\needlines{3}
\begin{code}{}
OrderedCollection>>>add: newObject
        !\underline{self halt.}!
        ^self addLast: newObject
\end{code}

¡La imagen se congela de inmediato!  Ni siquiera aparece una ventana
del navegador.  El problema se aclara cuando comprendemos que
(\textsc{I}) el sistema usa a \ct{OrderedCollection>>>add:} en muchas
partes, y por lo tanto el punto de interrupci\'on se dispara un momento
despu\'es de aceptar el cambio, y adem\'as (\textsc{II}) \emph{el propio
  depurador} env\'ia \ct{add:} a una instancia de
\ct{OrderedCollection}, lo cual impide que se abra la ventana del
depurador.  Lo que necesitamos es una forma de \emph{hacer un halt
  condicional} s\'olo si nos encontramos en un contexto que sea de
nuestro inter\'es.  Esto es exactamente lo que ofrece
\clsmthind{Object}{haltIf:}.

Supongamos que s\'olo queremos un halt si \ct{add:} es enviado desde,
digamos, el contexto de \ct{OrderedCollectionTest>>>testAdd}.

\dothis{Levanta una imagen fresca de nuevo, y configura el siguiente
  punto de interrupci\'on:}
\begin{code}{}
OrderedCollection>>>add: newObject
        !\underline{self haltIf: \#testAdd.}!
        ^self addLast: newObject
\end{code}

Esta vez la imagen no se congela.  Prueba de correr el
\ct{OrderedCollectionTest}.  (Lo puedes encontrar en la categor\'ia
\scat{CollectionsTests-Sequenceable}.) 

¿C\'omo funciona esto?  Echemos una mirada a
\clsmthind{Object}{haltIf:}: 
\begin{code}{}
Object>>>haltIf: condition
        | cntxt |
        condition isSymbol ifTrue: [
                "only halt if a method with selector symbol is in callchain"
                cntxt := thisContext.
                [cntxt sender isNil] whileFalse: [
                        cntxt := cntxt sender.
                        (cntxt selector = condition) ifTrue: [Halt signal]. ].
                ^self.
        ].
        ...
\end{code}

Para cada contexto, desde \ct!thisContext!, \ct!haltIf:! hacia arriba
en la pila de ejecuci\'on, se comprueba si el nombre del m\'etodo que hace
la llamada es el mismo s\'imbolo que el recibido como par\'ametro.  Si se
da el caso, se levanta una excepci\'on, que de manera predeterminada
apremia al depurador.

Tambi\'en se puede proporcionar un valor booleano o un bloque booleano
como argumento de \ct{haltIf:}, pero esos casos son sencillos y no
utilizan a \ct{thisContext}.

%======================================
\section{C\'omo interceptar los mensajes no definidos}
\seclabel{msgnotunderstood}

Hasta ahora utilizamos las capacidades de reflexi\'on computacional de
\st principalmente para consultar y explorar objetos, clases, m\'etodos
y la pila de tiempo de ejecuci\'on.  Ahora veremos c\'omo usar nuestro
conocimiento de la estructua del sistema \st para interceptar mensajes
y modificar comportamiento al momento de ejecuci\'on.

Cuando un objeto recibe un mensaje, revisa primero en el diccionario
de m\'etodos de su clase para encontrar el m\'etodo correspondiente que
responda al mensaje.  Si no existe un m\'etodo tal, contin\'ua revisando
hacia arriba en la jeraqu\'ia de clases, hasta que llega a \ct{Object}.
Si no se encuentra ning\'un m\'etodo para ese mensaje, el objeto \emph{se
  env\'ia a s\'i mismo} el mensaje \ct{doesNotUnderstand:} con el selector
del mensaje como su argumento.  El proceso se inicia de nuevo, hasta
que se encuentra a \clsmthind{Object}{doesNotUnderstand:} y se lanza
el depurador.

¿Pero qu\'e sucede si \ct{doesNotUnderstand:} est\'a sobrecargado en una
de las subclases de \ct{Object} en la ruta que se revisa?  Como
veremos, \'esta es una manera conveniente de realizar ciertas clases de
comportamiento muy din\'amico.  Un objeto que no responde [does not
understand] a un mensaje puede sobrecargar \ct{doesNotUnderstand:}
para proporcionar una estrategia alternativa para responder al mensaje
de marras.

Hay dos aplicaciones muy comunes de esta t\'ecnica: (1) para implementar
\ind{proxies livianos} [\ind{lightweight proxies}] para los objetos, y
(2) para compilar o cargar c\'odigo faltante.

%-----------------------------------------------------------------
\subsection{Proxies livianos}

En el primer caso, vamos a a introducir un «\ind{objeto m\'inimo}»
[\ind{minimal object}] para que act\'ue como proxy a favor de un objeto
existente.  Como el proxy pr\'acticamente no implementa m\'etodos propios,
cualquier mensaje que se le env\'ie ser\'a interceptado por
\ct{doesNotUnderstand:}.  Al implementar este mensaje, el proxy puede
realizar una acci\'on especial antes de delegar el mensaje al objeto
real del cual es un proxy.

Veamos ahora c\'omo puede implementarse esta idea\footnote{Tambi\'en
  puedes cargar \pkg{PBE-Reflection} desde
  \url{http://www.squeaksource.com/PharoByExample/}}.

Definimos el \ct{LoggingProxy} como se muestra a continuaci\'on:
\begin{code}{}
ProtoObject subclass: #LoggingProxy
        instanceVariableNames: 'subject invocationCount'
        classVariableNames: ''
        poolDictionaries: ''
        category: 'PBE-Reflection'
\end{code}
Creamos la subclase de \ct{ProtoObject}, en lugar de hacerlo desde
\ct{Object} porque no queremos que nuestro proxy herede ¡m\'as de 400
m\'etodos! de \ct{Object}.

\begin{code}{}
Object methodDict size --> 408
\end{code}

Nuestro proxy tiene dos variables de instancia: \ct{subject} es el
sujeto de quien es proxy, y \ct{count} con la cantidad de mensajes que
ha interceptado.  Inicializamos las dos variables de instancia y
proporcionamos un accesor para la cuenta de mensajes.  Inicialmente la
variable \ct{subject} apunta al proxy mismo.
\begin{code}{}
LoggingProxy>>>initialize
        invocationCount := 0.
        subject := self.
\end{code}

\begin{code}{}
LoggingProxy>>>invocationCount
        ^ invocationCount
\end{code}

Ahora interceptamos todos los mensajes no definidos, los escribimos en
el Transcript, actualizamos la cuenta de mensajes, y reenviamos el
mensaje al sujeto real.
\begin{code}{}
LoggingProxy>>>doesNotUnderstand: aMessage
        Transcript show: 'performing ', aMessage printString; cr.
        invocationCount := invocationCount + 1.
        ^ aMessage sendTo: subject
\end{code}

Aqu\'i va un poquito de magia.  Creamos un nuevo objeto \ct{Point} y un
nuevo \ct{LoggingProxy}, y luego hacemos que el proxy se transforme
(\mthind{ProtoObject}{become:}) en el objeto punto:
\seeindex{\ct{become:}}{\ct{ProtoObject>>>become:}}
\begin{code}{}
point := 1@2.
LoggingProxy new !\underline{become:}! point.
\end{code}

Esto tiene el efecto de intercambiar todas las referencias en la
imagen que apuntaban al punto y ahora apuntan al proxy, y viceversa.
Lo m\'as importante: ¡ahora la variable de instancia \ct{subject} va a
referirse al punto!

\begin{code}{}
point invocationCount --> 0
point + (3@4)             --> 4@6
point invocationCount --> 1
\end{code}

Esto funciona muy bien en la mayor\'ia de los casos, pero hay algunas
desventajas: 
\begin{code}{}
point class --> LoggingProxy
\end{code}

Resulta curioso que el m\'etodo \ct{class} no est\'a implementado ni
siquiera en \ct{ProtoObject} sino en \ct{Object}, ¡del cual no hereda
\ct{LoggingProxy}!  La respuesta a este acertijo es que \ct{class}
nunca se env\'ia como mensaje, sino que la respuesta la da directamente
la m\'aquina virtual.\footnote{\ct{yourself} tampoco se env\'ia,
  verdaderamente.  Hay otros mensajes que pueden ser interpretados
  directamente por la m\'aquina virtual, que dependen del receptor,
  entre ellos est\'an:
\ct{+- < > <= >= = ~= * / \ ==}
\ct{@ bitShift: // bitAnd: bitOr:}
\ct{at: at:put: size}
\ct{next nextPut: atEnd}
\ct{blockCopy: value value: do: new new: x y}.
Hay selectores que nunca se env\'ian, porque el compilador los compila
en l\'inea y los transforma a bytecodes de comparaci\'on y salto:
\ct{ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:}
\ct{and: or:}
\ct{whileFalse: whileTrue: whileFalse whileTrue}
\ct{to:do: to:by:do:}
\ct{caseOf: caseOf:otherwise:}
\ct{ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:}
Si sobrecargamos \ct{mustBeBoolean} en el receptor se pueden
interceptar los intentos de enviar esos mensajes a objetos que no son
booleanos y continuar la ejecuci\'on sobre un valor booleano v\'alido.
Otra forma de hacerlo es capturar la excepci\'on
\ct{NonBooleanReceiver}}% NB: Notes by Lukas Renggli 

A\'un si podemos ignorar tales env\'ios especiales de mensajes, exite otro
problema fundamental que no se puede sobrellevar mediante este
enfoque:  los env\'ios a \self no pueden interceptarse:
\begin{code}{}
point := 1@2.
LoggingProxy new become: point.
point invocationCount --> 0
point rect: (3@4)        --> 1@2 corner: 3@4
point invocationCount --> 1
\end{code}

Nuestro proxy ha sido estafado por dos env\'ios a \self en el
m\'etodo \ct{rect:}
\begin{code}{}
Point>>>rect: aPoint
        ^ Rectangle  origin: (self min: aPoint) corner: (self max: aPoint)
\end{code}

A\'un cuando los proxies pueden interceptar mensajes mediante el uso de
esta t\'ecnica, uno debe ser conciente de las limitaciones inherentes al
utilizar un proxy.  En \secref{wrapper} veremos otro enfoque, m\'as
general, para interceptar mensajes.

%-----------------------------------------------------------------
\subsection{C\'omo generar los m\'etodos faltantes}

La otra aplicaci\'on m\'as popular de la intercepci\'on de mensajes no
definidos es la carga o generaci\'on din\'amica de los m\'etodos faltantes.
Considere una biblioteca muy extensa de clases que tiene muchos
m\'etodos.  En lugar de cargar la biblioteca completa, podemos cargar un
empalme para cada clase de la biblioteca.  Los empalmes saben
d\'onde encontrar el c\'odigo fuente de todos sus m\'etodos.  Los
empalmes simplemente interceptan todos los mensajes no entendidos y cargan din\'amicamente los m\'etodos faltantes a medida que son necesarios.  En alg\'un momento posterior se puede desactivar este comportamiento, y grabar el c\'odigo cargado como el m\'inimo subconjunto necesario para la aplicaci\'on cliente.

% \on{Stef sez: check ObjectOut -- I looked, but this seems to be very
%   old. Depends on SqueakPage.}

Vamos a estudiar una variante simple de esta t\'ecnica donde tenemos una
clase que agrega autom\'aticamente los accesores para sus variables de
instancia cuando sean necesarios:
% \lr{the last statement should return the result of the message,
%   otherwise you cannot proceed with the debugger}
% \alex{all redefinition of doesNotUnderstand: includes a return
%   statement. However, I do not see your comment lukas, I tried to
%   insert a 'self halt' in the method, I was able to proceed. I added
%   the return in the function}
% \lr{Of course it depends on the exact circumstances. If you perform
%   a message on self that returns self it does not matter, but in any
%   other case a forgotten return can introduce strange side
%   effects. There was no return in the listing below, but now there
%   is and the problem is solved.}

\begin{code}{}
DynamicAcccessors>>>doesNotUnderstand: aMessage
        | messageName |
        messageName := aMessage selector asString.
        (self class instVarNames includes: messageName)
                ifTrue: [
                        self class compile: messageName, String cr, ' ^ ', messageName.
                        ^ aMessage sendTo: self ].
        ^ super doesNotUnderstand: aMessage
\end{code}
Cualquier mensaje no definido se intercepta aqu\'i.  Si existe una
variable de instancia con el mismo nombre del mensaje, entonces
solicitamos a nuestra clase que compile un accesor para esa variable
de instancia y reenviamos el mensaje.

Supongamos que la clase \ct{DynamicAcccessors} tiene una variable de
instancia (sin inicializar) llamada \ct{x} pero la misma no tiene un
accesor predefinido.  Entonces el c\'odigo siguiente va a generar el
accesor din\'amicamente y a recuperar su valor:\needlines{2}
\begin{code}{}
myDA := DynamicAccessors new.
myDA x --> nil
\end{code}

Vayamos paso a paso para ver lo que sucede la primera vez que se env\'ia
el mensaje \ct{x} a nuestro objeto (mira \figref{DynamicAccessors}).

\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{DynamicAccessors}
        \caption{Creaci\'on din\'amica de Accessors.\figlabel{DynamicAccessors}}
        % \alex{not sure whether the figure is highly necessary. The code is rather simple and the figure complete to follow in my opinion.}}
        % \on{trust me, it is useful to see all the steps.}
\end{figure}

(1) Enviamos \ct{x} a \ct{myDA}, (2) el mensaje se busca desde la
clase hacia arriba en la jerarqu\'ia, y (3) no se lo encuentra all\'i.
(4) Esto genera un \ct{self doesNotUnderstand: #x} que se env\'ia de
vuelta al objeto, (5) lo que dispara una nueva b\'usqueda.  Esta vez, se
encuentra a \ct{doesNotUnderstand:} inmediatamente en
\ct{DynamicAccessors}, (6) el cual pide a su clase que compile la
cadena \ct{'x ^ x'}.  El m\'etodo \ct{compile} se busca hacia arriba
(7), y (8) finalmante se encuantra en \ct{Behavior}, el cual (9--10)
agrega el nuevo m\'etodo compilado al diccionario de m\'etodos de
\ct{DynamicAccessors}.  Por \'ultimo, (11--13) el mensaje se reenv\'ia, y
esta vez se lo encuentra.

La misma t\'ecnica se puede usar para generar setters para las variables
de instancia, u otros tipos de c\'odigo basado en plantillas, como los
m\'etodos de visita de un Visitor.

Se puede advertir el uso de \clsmthind{Object}{perform:} en el paso
(13), que se puede utilizar para enviar mensajes compuestos al momento
de ejecuci\'on:
\begin{code}{@TEST}
5 perform: #factorial                                             --> 120
6 perform: ('fac', 'torial') asSymbol                       --> 720
4 perform: #max: withArguments: (Array with: 6) --> 6
\end{code}

%======================================
\section{Los objetos como m\'etodos wrappers}
\seclabel{wrapper}

Ya hemos visto que los m\'etodos compilados son objetos ordinarios en
\st, y que admiten ciertos m\'etodos para permitir que el programador
consulte el sistema de tiempo de ejecuci\'on.  Lo que tal vez cause un
poco de sorpresa es que \emph{cualquier objeto}  puede jugar el rol de
un m\'etodo compilado.  Todo lo que debe hacer es responder al mensaje
\ct{run:with:in:} y otros pocos m\'as mensajes importantes.

\dothis{Define una clase vac\'ia \ct{Demo}.  Eval\'ua \ct{Demo new
    answer42} y nota c\'omo se dispara el error usual ``Message Not
  Understood''.}


Ahora vamos a instalar un objeto llano de \st en el diccionario de
m\'etodos de nuestra clase \ct{Demo}.


\dothis{Eval\'ua \lct{Demo methodDict at: \#answer42 put:
    ObjectsAsMethodsExample new.} Ahora intenta obtener de nuevo el resultado de \ct{Demo new
  answer42}.  Esta vez obtenemos la respuesta \ct{42}.}

Si echamos una mirada a la clase \clsind{ObjectsAsMethodsExample}
vamos a encontrar los siguientes m\'etodos:

%\alex{I would prefer having return 42 in the run:with:in: method, and not having answer42 defined in ObjectsAsMethodsExample, this could be confusing I imagine}
%\on{ObjectsAsMethodsExample is part of the standard pharo image -- it is not in PBE-Reflection}
\needlines{5}
\begin{code}{}
answer42
        ^42

run: oldSelector with: arguments in: aReceiver
        ^self perform: oldSelector withArguments: arguments
\end{code}

Cuando nuestra instancia de \ct{Demo} recibe el mensaje \ct{answer42},
la b\'usqueda del m\'etodo procede como es usual, sin embargo, la m\'aquina
virtual detecta que en lugar de un m\'etodo compilado hay un objeto
ordinario tratando de ocupar su lugar.

La VM enviar\'a a este objeto un nuevo mensaje \ct{run:with:in:} con el
selector del m\'etodo original, los argumentos y el receptor como sus
argumentos.
Como  \ct{ObjectsAsMethodsExample} implementa este m\'etodo, intercepta
el mensaje y lo delega a s\'i mismo.


Ahora podemos eliminar el m\'etodo extraño con:
\begin{code}{}
Demo methodDict removeKey: #answer42 ifAbsent: []
\end{code}

Si miramos con atenci\'on en \ct{ObjectsAsMethodsExample}, veremos que
su superclase tambi\'en implementa los m\'etodos \ct{flushcache},
\ct{methodClass:} y \lct{selector:}, pero que est\'an todos vac\'ios.
Estos mensajes se pueden enviar a los m\'etodos compilados, y por lo
tanto deben ser implementados por cualquier objeto que pretenda
hacerse pasar por un m\'etodo compilado.  (\ct{flushcache} es el m\'etodo
m\'as importante que se debe implementar; los otros pueden llegar a ser
necesarios pero eso depende de si el m\'etodo se instala mediante
\clsmthind{Behavior}{addSelector:withMethod:} o directamente mediante
la utilizaci\'on de \clsmthind{MethodDictionary}{at:put:}.)


%-------------------------------------------------------------------------
\subsection{Usando m\'etodos wrappers para realizar pruebas de cobertura}

Los m\'etodos wrappers son una t\'ecnica bastante conocida para interceptar mensajes \cite{Bran98a}. En la implementaci\'on original\footnote{http://www.squeaksource.com/MethodWrappers.html}, un m\'etodo wrapper es una instancia de la subclase \ct{CompiledMethod}. Al instalarlo, el m\'etodo wrapper puede realizar acciones especiales antes o despu\'es de invocar al m\'etodo original. Cuando se desinstala, el m\'etodo original es devuelto a su correcta posici\'on en el diccionario de m\'etodos.

En Pharo, los \ind{m\'etodos wrappers} pueden ser implementados m\'as facilmente al implementar \ct{run:with:in:} como instancia de la la subclase \ct{CompiledMethod}. De hecho, existe una implementaci\'on ligera de objetos como m\'etodos wrappers\footnote{http://www.squeaksource.com/ObjectsAsMethodsWrap.html}, pero esto no forma parte de Pharo estandar al momento de escribir esto.

Sin embargo, el Pharo Test Runner usa precisamente esta t\'ecnica para evaluar la cobertura de los test. Hechemos un vistazo al funcionamiento de esto:

El punto de entrada para la prueba de cobertura es el m\'etodo \clsmthind{TestRunner}{runCoverage}:
\begin{code}{}
TestRunner>>>runCoverage
        | packages methods |
        ... "identify methods to check for coverage"
        self collectCoverageFor: methods
\end{code}

El m\'etodo \clsmthind{TestRunner}{collectCoverageFor:} claramente ilustra el algoritmo que chequea la cobertura:
\begin{code}{}
TestRunner>>>collectCoverageFor: methods
        | wrappers suite |
        wrappers := methods collect: [ :each | TestCoverage on: each ].
        suite := self
                reset;
                suiteAll.
        [ wrappers do: [ :each | each install ].
          [ self runSuite: suite ] ensure: [ wrappers do: [ :each | each uninstall ] ] ] valueUnpreemptively.
        wrappers := wrappers reject: [ :each | each hasRun ].
        wrappers isEmpty
                ifTrue:
                        [ UIManager default inform: 'Congratulations. Your tests cover all code under analysis.' ]
                ifFalse: ...
\end{code}
Un wrapper es creado por cada m\'etodo a ser chequeado y cada wrapper se instala. Al correr la prueba, todos los wrappers son desintalados. Finalmente el usuario obtiene la informaci\'on acerca de cuales m\'etodos no han estado cubiertos.

C\'omo hace el wrapper su trabajo? El wrapper \ct{TestCoverage} tiene tres variables de instacia \ct{hasRun}, \ct{reference} and \ct{method}.
Se inicializan as\'i:
\begin{code}{}
TestCoverage class>>>on: aMethodReference
        ^ self new initializeOn: aMethodReference

TestCoverage>>>initializeOn: aMethodReference
        hasRun := false.
        reference := aMethodReference.
        method := reference compiledMethod
\end{code}

La instalaci\'on y desinstalaci\'on de los m\'etodos simplemente actualiza el diccionario de m\'etodos en la forma obvia:
\begin{code}{}
TestCoverage>>>install
        reference actualClass methodDictionary
                at: reference methodSymbol
                put: self

TestCoverage>>>uninstall
        reference actualClass methodDictionary
                at: reference methodSymbol
                put: method
\end{code}
\noindent
y el m\'etodo \ct{run:with:in:} simplemente actualiza la variable \ct{hasRun} ,desinstala el wrapper (una vez que la cobertura haya sido verificada), y reenv\'ia el mensaje al m\'etodo original
\begin{code}{}
run: aSelector with: anArray in: aReceiver
        self mark; uninstall.
        ^ aReceiver withArgs: anArray executeMethod: method

mark
        hasRun := true
\end{code}
(Dele un vistazo a \clsmthind{ProtoObject}{withArgs:executeMethod:} para ver c\'omo  un m\'etodo desplazado de su diccionario de m\'etodos puede ser invocado.)

Esto es todo lo que hay que hacer!

Los m\'etodos wrappers puede ser usados para realizar cualquier tipo de comportamiento adecuado antes o despu\'es de la normal operaci\'on de un m\'etodo. Aplicaciones t\'ipicas son en instrumentaci\'on (recolectando estad\'isticas sobre invocaciones de los patrones de m\'etodos), chequeo de pre- y post- condiciones,
y en memoization (opcionalmente haciendo cache de valores computados por los m\'etodos).

%======================================
\section{Pragmas}

Un \emphind{pragma} es una anotaci\'on que espec\'ifica informaci\'on espec\'ifica sobre un programa, pero que no est\'a envuelto en su ejecuci\'on. Los Pragmas no afectan directamente la operaci\'on del m\'etodo que anotan. Los Pragmas tienen variados usos, como ser:

\begin{itemize}
\item Informaci\'on del compilador: Los \indmain{pragmas} pueden ser usados para hacer que un m\'etodo llame a una funci\'on primitiva. Esta funci\'on tiene que estar definida por la m\'aquina virtual o ser un pluggin externo.

\item Procesamiento en tiempo de ejecuci\'on: Algunos pragmas est\'an disponibles para ser examinados en tiempo de ejecuci\'on.
\end{itemize}

Los pragmas pueden ser aplicados a la declaraci\'on de m\'etodos de un programa solamente. Un m\'etodo puede declarar uno o m\'as pragmas y todos los pragmas deben estar declarados anteriormente a cualquier sentencia Smalltalk. Cada pragma es efectivamente un mensaje est\'atico enviado con argumentos literales.

Brevemente mencionamos pragmas cuando introdujimos primitivas al comienzo de este cap\'itulo. Una primitiva no es m\'as qu una declaraci\'on de pragma. Considere \ct{<primitive: 73>} que est\'a contenida en \ct{instVarAt:}. El selector de pragma es \ct{primitive:} y su argumento es un inmediato valor literal \ct{73}.

El compilador es probablemente el mayor usuario de pragmas. SUnit es otra herramienta que hace uso de las anotaciones. SUnit es capaz de estimar la cobertura de una aplicaci\'on desde una unidad de prueba. Uno puede querer excluir algunos m\'etodos de la cobertura. Este es el caso del m\'etodo \ct{documentation} en la clase \ct{SplitJointTest}:  

\begin{code}{}
SplitJointTest class>>>documentation
        <ignoreForCoverage>
        "self showDocumentation"

        ^ 'This package provides function.... "
\end{code}

Simplemente anotando un m\'etodo con el pragma \ct!<ignoreForCoverage>! uno puede controlar el alcance de la cobertura

%Beside the compiler, Lint is a heavy user of pragmas. Lint is a static code analyzer that flags suspicious, non-portable constructs and code that is likely to contain bugs. It may happen that a method needs to be excluded from Lint analysis. This is the case here:

%\begin{code}{}
%MorphObjectOut>>>doesNotUnderstand: aMessage
%       "Bring in the object, install, then resend aMessage"
%       "Transcript show: thisContext sender selector; cr."
%       "useful for debugging"
%
%       ! \textbf{<lint: 'Unnecessary "= true"' rationale: 'recursionFlag may be nil' author: 'stephane.ducasse'>}!
%       ...
%\end{code}

%One of the pragmas used by Lint to filter out methods is \ct{lint:rationale:author:}.

Como instancias de la clase \clsind{Pragma}, los pragmas son objetos de primera clase. Un m\'etodo compilado responde al mensaje \mthind{CompiledMethod}{pragmas}. Este m\'etodo devuelve un arreglo de pragmas.

\begin{code}{@TEST}
(SplitJoinTest class >> #showDocumentation) pragmas
  --> an Array(<ignoreForCoverage>)
(Float>>#+) pragmas --> an Array(<primitive: 41>)
\end{code}


Los m\'etodos que definene una consulta particular pueden ser devueltos desde la clase. La class-side \ct!SplitJoinTest! contiene algunos m\'etodos anotados con \ct!<ignoreForCoverage>!:

\begin{code}{@TEST}
Pragma allNamed: #ignoreForCoverage in: SplitJoinTest class  --> an Array(<ignoreForCoverage> <ignoreForCoverage> <ignoreForCoverage>)
\end{code}

Una variante de \ct{allNamed:in:} puede ser encontrada en la class-side de \ct{Pragma}.

Un pragma conoce en cual m\'etodo esta definido (usando \ct{method}), el nombre del m\'etodo (\ct{selector}) la clase que contiene el m\'etodo (\ct{methodClass}), su n\'umero de argumentos (\ct{numArgs}), acerca de los literales que el pragma tiene por argumentos (\ct{hasLiteral:} y \ct{hasLiteralSuchThat:}).

\lr{Tipicamente los pragmas son realizados sobre un objeto it\'erprete que entienda el mensaje del pragma.}

%======================================
\section{Resumen del cap\'itulo}

Reflexi\'on se refiere a la habilidad de consultar, examinar e incluso modificar metaobjetos tanto del sistema en ejecuci\'on como objetos ordinarios.

\begin{itemize}
\item El Inspector usa \ct{instVarAt:} y m\'etodos realacionados para consultar y modificar variables de instancia ``privadas'' de los objetos.
\item Envie \ct{Behavior>>>allInstances} para consultar instancias de una clase.
\item Los mensajes \ct{class}, \ct{isKindOf:}, \ct{respondsTo:} \etc  son \'utiles para obtener m\'etricas o construir herramientas de desarrollo, pero deben ser evitados en aplicaciones regulares: Violan el encapsulamiento de los objetos y hacen su c\'odigo dif\'icil de entender y mantener
\item \ct{SystemNavigation} es una clase \'util para explotar muchas \'utiles consultas sobre la navegaci\'on e inspecci\'on de la jerarqu\'ia de \ct class. Por ejemplo, use \ct {SystemNavigation default browseMethodsWithSourceString: 'pharo'.} para encontrar y ver todos los m\'etodos con una determinada cadena de caracteres. (Es lento, pero completo!)
\item Cada clase de \st apunta a una instancia del \ct{MethodDictionary} el cual mapea selectores a instancias de \ct{CompiledMethod}. Un m\'etodo compilado conoce su propia clase, cerrando el c\'irculo.
\item \ct{MethodReference} es un proxy ligero para un m\'etodo compilado, proveyendo conveniententemen m\'etodos adicionales y es usado por muchas herramientas de \st .
\item \ct{BrowserEnvironment}, es parte de la infraestructura del Refactoring Browser, ofrece una interfaz m\'as refinada que \ct{SystemNavigation} para consultas el sistema, desde el resultado de una consulta, puede ser usado como el alcance de una nueva consulta. Tanto la GUI y las intefaces programables est\'an disponibles.
\item \ct{thisContext} es una pseudo-variable que reifica la pila de ejecuci\'on de la m\'aquina virtual. Es mayormente usada por el depurador para construir din\'amicamente una vista interactiva de la pila. Es tambi\'en \'util para determinar din\'amicamente el remitente de un mensaje.
\item Los puntos de ruptura inteligentes pueden ser ajustados usando \ct{haltIf:}, tomando un selector de m\'etodo como su argumento. \ct{haltIf:} se detiene solo si el m\'etodo se\~nalado es un remitente en la pila de ejecuci\'on.
\item Una manera com\'un de interceptar mensajes enviados a un determinado destino es usando un ``objeto m\'inimo'' como proxy del destino. El proxy implementa tan pocos m\'etodos como le es posible y atrapa todos los mensajes enviados por la implementaci\'on de \ct{doesNotunderstand:}. Tambi\'en puede ser usado para realizar algunas acciones adiciones y reci\'en entonces enviar el mensajes al destino original.
\item Enviar \ct{become:} para intercambiar las referencias de dos objetos , tal como un proxy y su destino.
\item Cuidado, algunos mensajes, como  \ct{class} y \ct{yourself} nunca son realmenten enviados, pero son interceptados por la m\'aquina virtual. Otros, como \ct{+}, \ct{ifTrue:} y \ct{-} pueden ser directamente interceptados o introducidos por la m\'aquina virtual dependiendo del receptor.
\item Otro uso t\'ipico para la sobreescritura de \ct{doesNotUnderstand:} es la carga  lenta o la compilaci\'on de m\'etodos perdidos.
\item \ct{doesNotUnderstand:} no puede atrapar \self-sends.
\item Una forma m\'as rigurosa de interceptar mensajes es usar un objeto como un m\'etodo wrapper. Este tipo de objeto es instalado en el diccionario de m\'etodos en lugar de un m\'etodo compilado.  Deber\'ia implementar \ct{run:with:in:}, el cual es enviado por la m\'aquina virtual cuando detecta un objeto ordinario en lugar de un m\'etodo compilado en el diccionario de m\'etodos. Esta t\'ecnica es usada por SUnit Test Runner para recoger informaci\'on sobre la cobertura.
\end{itemize}

%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=========================================================

%Other stuff:
%- anonymous classes (uses compile: and primitiveChangeClassTo:) ???
%- collect direct senders; class collaborations
%- Object primitiveChangeClassTo: become: and becomeForward: (see tests and slides with minimal object example)
%- PointerFinder?
%- anonymous classes (see slides) ?

%Test  Coverage using ObjectsAsMethodsWrap package:
%\begin{code}{}
%category := 'SCGPier'.
%w := (ObjectAsOneTimeMethodWrapper installOnClassCategory: category).
%tr := TestRunner new.
%ToolBuilder open: tr.
%[tr
%       categoryAt: (tr categoryList indexOf: 'SCGPier') put: true;
%       selectAllClasses;
%       runAll.]
%ensure: [[w do: [:each| each uninstall ]] valueUnpreemptively].
%((w select: [:each | each executed not ])
%       collect: [:each | each wrappedClass name, '>>', each selector name ]) explore.
%\end{code}


%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: "../PBE1.tex"
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "castellano8"
%%% End:
