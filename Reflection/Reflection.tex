% $Author$
% $Date$
% $Revision$

% HISTORY: [see also Metaprogramming2.tex]
% 2007-05-22 - Damien Pollet started (translation from French article by ...?)
% 2008-01-15 - Alex added text
% 2008-12-15 - Oscar revised
% 2009-03-24 - Stef started new chapter (acttalk ... see separate file)
% 2009-06-01 - Oscar started to revise again and add new material
% 2009-06-08 - Lukas -- unsent messages
% 2009-06-15 - Oscar completed revision
% 2009-06-16 _ Stef comments
% 2009-06-17 - Alexandre completed revision
% 2009-06-19 - Lukas comments
% 2009-07-07 - Oscar migrated to Pharo; fixed broken tests
% 2009-08-16 - Oscar indexing and cleaning up loose ends

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
        \documentclass[a4paper,10pt,twoside]{book}
        \usepackage[
                papersize={6.13in,9.21in},
                hmargin={.75in,.75in},
                vmargin={.75in,1in},
                ignoreheadfoot
        ]{geometry}
        \input{../common.tex}
        \pagestyle{headings}
        \setboolean{lulu}{true}
% --------------------------------------------
% A4:
%       \documentclass[a4paper,11pt,twoside]{book}
%       \input{../common.tex}
%       \usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
        \begin{document}
        % \renewcommand{\nnbb}[2]{} % Disable editorial comments
        \sloppy
\fi

%=================================================================
\chapter{Reflexión}\chalabel{reflection}

\indexmain{reflection}
\st es un lenguaje de programación con reflexión computacional.
En pocas palabras, quiere decir que los programas son capaces de
«reflexionar» sobre su propia ejecución y estructura.
% \lr{not only on execution, also on the static model}
% pp 301 cesar
En un sentido más técnico, esto significa que
los \emphind{metaobjetos} del sistema en tiempo de ejecución
pueden \emph{reificarse} como objetos ordinarios, a los cuales se
puede consultar e inspeccionar.  Los metaobjetos en \st son las
clases, metaclases, diccionarios de métodos, métodos compilados, la
pila al momento de ejecución, y otros.  Esta forma de reflexión
también se denomina \emphind{introspección}, y muchos lenguajes
modernos de programación la permiten.

\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{reflect}
        \caption{Reificación y reflexión.\figlabel{reflect}} % \lr{not referenced, not sure if I understand it}
\end{figure}

En el sentido contrario, en \st resulta posible modificar los
metaobjetos reificados y \emph{reflejar} esos cambios de vuelta al
sistema en ejecución (puedes verlo en la \figref{reflect}).  Esta
actividad también se denomina \emph{intercesión}. La intercesión está
presente principalmente en los lenguajes de programación dinámicos
mientras que los lenguajes estáticos sólo la admiten en un grado muy
limitado.

Un programa que manipula otros programas (o se manipula a sí mismo) es
un \emphind{metaprograma}.  Para que un lenguaje de programación sea
capaz de reflexión computacional debe permitir tanto la
\ind{introspección} como la \ind{intercesión}.  La introspección es la
capacidad de \emph{examinar} las estructuras de datos que definen el
lenguaje, como los objetos, clases, métodos y la pila de ejecución.
La intercesión es la capacidad de \emph{modificar} dichas estructuras,
o sea, de alterar la semántica del lenguaje y el comportamiento del
programa desde el interior del propio programa.  La \emph{reflexión
  estructural} examina y modifica la estructura del sistema de tiempo
de ejecución y la \emphind{reflexión de comportamiento} modifica la
interpretación de esas estructuras.

En este capítulo nos enfocaremos principalmente en la \ind{reflexión
  estructural}. Vamos a explorar muchos ejemplos prácticos que
ilustrarán como \st permite la introspección y la metaprogramación.

%======================================
\section{Introspección}

Mediante el inspector, puedes mirar dentro de un objeto, cambiar los
valores de sus variables de instancia, e incluso enviarle mensajes.

\dothis{Evalúa el siguiente código en un workspace:}
\begin{code}{| w |}
w := Workspace new.
w openLabel: 'My workspace'.
w inspect.
\end{code}

Esto va a abrir un segundo workspace y un inspector.  El inspector
muestra el estado interno de este nuevo espacio de trabajo, lista sus
variables de instancia en la parte izquierda (\ct!dependents!,
\ct!contents!, \ct!bindings!, \ldots) y en la parte derecha se ve el
valor de la variable de instancia seleccionada.  La variable de
instancia \ct!contents! representa lo que se muestra en el área de
texto del espacio de trabajo, así que si lo seleccionas, la parte
derecha va a mostrar una cadena vacía.

\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{workspaceInspector}
        \caption{Inspección de un \ct!Workspace!.\figlabel{workspaceInspector}}
\end{figure}

\dothis{Ahora escribe \ct!'hello'! en lugar de esa cadena vacía, y
  luego \emph{ac\'eptala}.}

El valor de la variable \ct!contents! va a cambiar, pero la ventana
del espacio de trabajo no se percata de ello, así que no se vuelve a
regenerar lo que muestra.  Para que se refresque el contenido en la
ventana, evalúa \ct!self contentsChanged!  en la parte inferior del
inspector.

%-----------------------------------------------------------------
\subsection{Cómo se accede a las variables de instancia}


¿Cómo funciona el inspector?  En \st, todas las variables de instancia
son protegidas.  En teoría, es imposible accederlas desde otro objeto
si la clase no define sus accesores.  En la práctica, el
inspector puede acceder a las variables de instancia sin necesidad de
accesores, porque usa las capacidades de reflexión computacional de
\st.  En \st, las clases definen variables de instancia o bien
mediante un nombre o bien mediante un índice numérico.  El inspector
usa métodos definidos en la clase \ct!Object! para accederlas:
\lct{instVarAt: \emph{index}} y \lct{instVarNamed: \emph{aString}} se
usan para acceder al valor de la variable de instancia en la posición
\lct{\emph{index}} o aquella cuyo nombre es \lct{\emph{aString}},
respectivamente; para asignar nuevos valores a esas variables de
instancia utiliza \ct!instVarAt:put:! y \ct!instVarNamed:put:!.
\mthindex{Object}{instVarAt:} \mthindex{Object}{instVarNamed:}
\mthindex{Object}{instVarAt:put:} \mthindex{Object}{instVarNamed:put:}

Por ejemplo, puedes cambiar el valor asociado a \ct!w! en el primer
espacio de trabajo mediante la evaluación de:
\begin{code}{}
w instVarNamed: 'contents' put: 'howdy!'; contentsChanged
\end{code}

\important{\emph{Precaución:} Aunque estos métodos resultan útiles
  para construir herramientas de desarrollo, es una mala idea usarlos
  para desarrollar aplicaciones convencionales: estos métodos de
  reflexión computacional violan los límites de la encapsulación de
  los objetos y por lo tanto pueden hacer que tu código sea mucho más
  difícil de comprender y mantener.}
  % \lr{Why? The access does not show up when looking for all
  %   readers/writers in the code browser.}

Tanto \ct!instVarAt:! como \ct!instVarAt:put:! son \ind{métodos
  primitivos}, lo que significa que están implementados como
operaciones primitivas de la máquina virtual de \pharo.  Si revisas el
código de esos métodos verás la sintaxis especial \ind{pragma}
\ct!<primitive: N>! donde \ct!N! es un entero.
% \lr{actually this is the syntax of pragmas (method annotations),
%   \ct!primitive:! is just a special kind of pragma}

\needlines{5}
\begin{code}{}
Object>>>instVarAt: index
        "Primitive. Answer a fixed variable in an object. ..."
        !\textbf{<primitive: 73>}!
        "Access beyond fixed variables."
        ^self basicAt: index - self class instSize
\end{code}

En el caso más usual no se ejecuta el código que sigue a la invocación
de la primitiva.  Sólo se ejecuta si la primitiva falla.  En este caso
específico, si tratamos de acceder una variable que no existe entonces
se ejecuta el código que sigue a la primitiva.  De este modo se
permite también que el debugger se inicie sobre métodos primitivos.
Aunque es posible modificar el código de los métodos primitivos, debes
entender que es una actividad de alto riesgo para la estabilidad de tu
sistema \pharo.

\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{allInstanceVariables}
        \caption{Vista de todas las variables de instancia de un \ct!Workspace!.\figlabel{allInstanceVariables}}
\end{figure}

La \figref{allInstanceVariables} muestra cómo pueden verse los valores
de las variables de instancia de una instancia arbitraria (\ct!w!) de
la clase \ct!Workspace!.  El método \ct!allInstVarNames! retorna todos
los nombres de las variables de instancia de una clase dada.

De manera similar, es posible conseguir las instancias que tienen
ciertas propiedades específicas.  Por ejemplo, para obtener todas las
instancias de la clase \ct!SketchMorph! cuya variable de instancia
\ct!owner! está asociada al morph mundo (o sea, las imágenes que se
muestran en este momento), prueba la siguiente expresión:
\begin{code}{}
SketchMorph allInstances select: [:c | (c instVarNamed: 'owner') isWorldMorph]
\end{code}

%-----------------------------------------------------------------
\subsection{Cómo recorrer las variables de instancia}

\mthindex{Object}{instanceVariableValues}
Consideremos el mensaje \ct!instanceVariableValues!, que devuelve una
colección de todos los valores de variables de instancia definidos en
dicha clase, sin tener en cuenta las variables de instancia
heredadas.  Por ejemplo:
\begin{code}{@TEST}
(1@2) instanceVariableValues --> an OrderedCollection(1 2)
\end{code}

El método está implementado en \ct{Object} como se muestra a
continuación:
\needlines{9}
\begin{code}{}
Object>>>instanceVariableValues
        "Answer a collection whose elements are the values of those instance variables of the receiver which were added by the receiver's class."
        | c |
        c := OrderedCollection new.
        self class superclass instSize + 1
                to: self class instSize
                do: [ :i | c add: (self instVarAt: i)].
        ^ c
\end{code}

Este método itera sobre los índices de las variables de instancia que
están definidas en la clase; el primer valor corresponde al primer
índice no usado por la superclase.  (El método \ct!instSize! retorna
la cantidad de variables de instancia nominadas que define una clase)

%-----------------------------------------------------------------
\subsection{Cómo consultar clases e interfaces}

Tods las herramientas de desarrollo de \pharo (code browser,
debugger, inspector\ldots) utilizan las características de reflexión
computacional que hemos visto hasta ahora.

Se muestran a continuación otros mensajes que pueden resultar útiles
para construir herramientas de desarrollo:

\lct{isKindOf: \emph{aClass}} retorna true si el receptor es una
instancia de \lct{\emph{aClass}} o una de sus superclases.  Por
ejemplo:
\begin{code}{@TEST}
1.5 class                     --> Float
1.5 isKindOf: Number --> true
1.5 isKindOf: Integer   --> false
\end{code}
\mthindex{Object}{class}
\mthindex{Object}{isKindOf:}

\lct{respondsTo: \emph{aSymbol}} returna true si el receptor tiene un
método cuyo selector es \lct{\emph{aSymbol}}.
Por ejemplo:
\needlines{3}
\begin{code}{@TEST}
1.5 respondsTo: #floor      --> true    "pues Number implementa floor"
1.5 floor                            --> 1
Exception respondsTo: #, --> true    "las clases de exception se pueden agrupar"
\end{code}
\mthindex{Object}{respondsTo:}

\important{\emph{Precaución:} Aunque estas características resultan
  especialmente útiles para escribir herramientas de desarrollo,
  normalmente no son apropiadas para escribir aplicaciones típicas.
  Cuando uno consulta a un objeto para saber su clase o para saber
  a cuáles mensajes responde, estamos en presencia de señales típicas
  que apuntan a problemas de diseño, pues estas consultas violan el
  principio de encapsulación.  Las herramientas de desarrollo, sin
  embargo, no son aplicaciones normales, pues su dominio es el del
  software en sí mismo.  Por ello, estas herramientas tienen derecho a
  indagar profundamente en los detalles internos del código.}

% There also exist mechanisms for introspecting on various parts of
% the run-time system, such as the process scheduler, the memory
% manager and so on. For now we will focus on navigating through
% objects, classes and methods, and we will look more closely at rest
% of the runtime system in an other chapter.  \on{let's not mention
%   this if we don't actually write such a chapter!}

%-----------------------------------------------------------------
\subsection{Métricas de código}

Veamos cómo podemos usar las características de introspección de \st
para extraer rápidamente algunas métricas de código.  Las
\ind{métricas} de código miden aspectos tales como la profundidad de
la jerarquía de herencia, la cantidad directa e indirecta de
subclases, la cantidad de métodos o de variables de instancia en cada
clase, o la cantidad de métodos o variables de instancia definidos
localmente.  A continuación se muestran unas métricas para la clase
\ct!Morph!, que es la superclase de todos los objetos gráficos en
\pharo, y que revelan que se trata de una clase enorme, y que es la
raíz de una enorme jerarquía. ¡Tal vez está necesitada de un poco de
refactoring!

\mthindex{Behavior}{allSuperclasses}
\mthindex{Behavior}{allSelectors}
\mthindex{Behavior}{allInstVarNames}
\mthindex{Behavior}{selectors}
\mthindex{Behavior}{instVarNames}
\mthindex{Behavior}{subclasses}
\mthindex{Behavior}{allSubclasses}
\mthindex{ClassDescription}{linesOfCode}
\begin{code}{}
Morph allSuperclasses size.  -->       2 "profundidad de la herencia"
Morph allSelectors size.        --> 1378 "cantidad de metodos"
Morph allInstVarNames size. -->      6 "cantidad de variables de instancia"
Morph selectors size.             -->  998 "cantidad de nuevos metodos"
Morph instVarNames size.     -->      6 "cantidad de nuevas variables"
Morph subclasses size.          -->    45 "cantidad de subclases directas"
Morph allSubclasses size.      -->  326 "total de subclases"
Morph linesOfCode.               --> 5968 "cantidad total de lineas de codigo"
\end{code}

Una de las métricas más interesantes en el dominio de los lenguajes
orientados a objetos es la cantidad de métodos que extienden métodos
heredados desde la superclase.  Ella nos informa de la relación entre
la clase y sus superclases.  En las siguientes secciones veremos cómo
aprovechar nuestro conocimiento de la estructura de tiempo de
ejecución para responder estas cuestiones.

%======================================
\section{Cómo navegar por el código}

En \st, todo es un objeto.  En particular, las clases son objetos que
nos proporcionan mecanismos útiles para navegar entre sus instancias.
La mayoría de los mensajes que vamos a estudiar están implementados en
\ct{Behavior} y por lo tanto todas las clases responden a ellos.

Como ya vimos antes, puedes obtener una instancia de una clase dada si
le envías el mensaje \ct!#someInstance!.
\mthindex{Behavior}{someInstance}
\begin{code}{@TEST} % Possibly fragile!
Point someInstance --> 0@0
\end{code}

Además, puedes obtener todas las instancias con \ct!#allInstances!, y
la cantidad de instancias activas en memoria con \ct!#instanceCount!.

\alex{In a Pharo0.1-10342dev09.96.3, I have "ByteString instanceCount
  --> 63607"}
\mthindex{Behavior}{allInstances}
\mthindex{Behavior}{instanceCount}
\mthindex{Behavior}{allSubInstances}
\begin{code}{} % Cannot test this
ByteString allInstances        --> #('collection' 'position'  ...)
ByteString instanceCount    --> 104565
String allSubInstances size -->  101675
\end{code}

Estas características pueden resultar muy útiles al depurar una
aplicación, porque puedes solicitar a una clase que enumere aquellos
de sus métodos que exhiben ciertas propiedades.
\begin{itemize}
\item \mthind{Behavior}{whichSelectorsAccess:} retorna la lista de
  todos los selectores de métodos que leen o escriben la variable de
  instancia nombrada por el argumento
\item \mthind{Behavior}{whichSelectorsStoreInto:} retorna los
  selectores de métodos que modifican el valor de una variable de
  instancia dada
\item \mthind{Behavior}{whichSelectorsReferTo:} retorna los selectores
  de métodos que envían un dado mensaje
\item \mthind{Behavior}{crossReference} asocia cada mensaje con el
  conjunto de métodos que lo envían.
\end{itemize}

\begin{code}{} % TOO FRAGILE TO TEST
Point whichSelectorsAccess: 'x'    --> an IdentitySet(#'\\' #= #scaleBy: ...)
Point whichSelectorsStoreInto: 'x' --> an IdentitySet(#setX:setY: ...)
Point whichSelectorsReferTo: #+  --> an IdentitySet(#rotateBy:about: ...)
Point crossReference --> an Array(
                an Array('*' an IdentitySet(#rotateBy:about: ...))
                an Array('+' an IdentitySet(#rotateBy:about: ...))
                ...)
\end{code}

Los siguientes mensajes tienen en cuenta a la herencia:

\begin{itemize}
\item \mthind{Behavior}{whichClassIncludesSelector:} retorna la
  superclase que implementa el mensaje dado
\item \mthind{Behavior}{unreferencedInstanceVariables} retorna la
  lista de variables de instancia que no se usan en la clase del
  receptor ni en sus subclases.
\end{itemize}

\begin{code}{@TEST}
Rectangle whichClassIncludesSelector: #inspect --> Object
Rectangle unreferencedInstanceVariables            --> #()
\end{code}

\clsind{SystemNavigation} es una fachada [facade] que incluye varios
métodos útiles para consultar y navegar a través del código fuente del
sistema.  \ct{SystemNavigation} \mthind{SystemNavigation
  class}{default} retorna una instancia que puedes usar para navegar
por el sistema.  Por ejemplo:

\mthindex{SystemNavigation}{allClassesImplementing:}
\begin{code}{@TEST}
SystemNavigation default allClassesImplementing: #yourself --> {Object}
\end{code}

Los siguientes mensajes se explican solos:

\mthindex{SystemNavigation}{allSentMessages}
\mthindex{SystemNavigation}{allUnsentMessages}
\mthindex{SystemNavigation}{allUnimplementedCalls}
\begin{code}{}
SystemNavigation default allSentMessages size          --> 24930
SystemNavigation default allUnsentMessages size      --> 6431
SystemNavigation default allUnimplementedCalls size --> 270
\end{code}

Que un mensaje esté implementado y que nadie lo envíe no es
necesariamente una señal de un mensaje inútil, pues puede ser que se
lo envíe implícitamente (por ejemplo, mediante \ct{perform:}).  Los
mensajes que se envían pero no están implementados son más
problemáticos, porque los métodos que envían esos mensajes van a
fallar en tiempo de ejecución.  Son la señal de una implementación sin
terminar, APIs obsoletas o bibliotecas faltantes.

\mthindex{SystemNavigation}{allCallsOn:}
\ct!SystemNavigation default allCallsOn: #Point! retorna todos los
mensajes enviados explícitamente a \ct!Point! como receptor.

Todas estas características están integradas en el entorno de
programación de \pharo, en particular en los navegadores de código.
Como ya conocerás, hay atajos de teclado convenientes para navegar por
todos los i\underline{m}plementors (\short{m}) y se\underline{n}ders
(\short{n}) de un mensaje dado.  Lo que tal vez no resulte tan
conocido es que hay muchas consultas preparadas que están
implementadas como métodos de la clase \ct{SystemNavigation} en el
protocolo \prot{browsing}.  Por ejemplo, puedes encontrar
programáticamente todos los implementadores del mensaje \ct{ifTrue:}
mediante la evaluación de:
\mthindex{SystemNavigation}{browseAllImplementorsOf:}
\begin{code}{}
SystemNavigation default browseAllImplementorsOf: #ifTrue:
\end{code}

\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{implementors}
        \caption{Implementadores de \ct!\#ifTrue:!.\figlabel{implementors}}
\end{figure}

Los métodos \ct{browseAllSelect:} y
\lct{browseMethodsWithSourceString:} son particularmente útiles.  A
continuación se muestran dos manera diferentes de revisar todos los
métodos en el sistema que envían mensajes a super (la primera es más
bien por fuerza bruta; la segunda es mejor y elimina algunos falsos
positivos):
\mthindex{SystemNavigation}{browseMethodsWithSourceString:}
\mthindex{SystemNavigation}{browseAllSelect:}
\begin{code}{}
SystemNavigation default browseMethodsWithSourceString: 'super'.
SystemNavigation default browseAllSelect: [:method | method sendsToSuper ].
\end{code}

%======================================
\section{Clases, dicionarios de métodos y métodos}

Como las clases son objetos, podemos inspeccionarlas o explorarlas
como a cualquier otro objeto.

\mthindex{Object}{explore}
\dothis{Evalúa \ct{Point explore}.}

En \figref{CompiledMethod}, el \ind{explorer} muestra la estructura de
la clase \clsind{Point}.  Puedes ver que la clase almacena sus métodos
en un diccionario, indexados por su selector.  El selector \ct{#*}
apunta al \ind{bytecode} descompilado de \ct!Point>>>*!.

\begin{figure}[ht]\centering
        \includegraphics[width=.5\linewidth]{CompiledMethod}
        \caption{Explorer:la clase \ct!Point! y el bytecode de su método \ct!\#*!.\figlabel{CompiledMethod}}
\end{figure}

Vamos a considerar la relación entre clases y métodos.  En
\figref{MethodsAsObjects} vemos que las clases y metaclases tienen en
común a la superclase \ct{Behavior}.  Aquí es donde se define a
\mthind{Behavior}{new}, entre otros métodos para las clases.  Cada
clase tiene un diccionario de métodos, el cual mapea selectores de
métodos en \ind{métodos compilados}.  Cada método compilado conoce la
clase en la cual está instalado.  En \figref{CompiledMethod} podemos
ver incluso que esto se almacena en una asociacion en \ct{literal5}.

\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{MethodsAsObjects}
        \caption{Clases, diccionarios de métodos y métodos compilados\figlabel{MethodsAsObjects}}
\end{figure}

Podemos aprovechar las relaciones entre clases y métodos para realizar
consultas sobre el sistema.  Por ejemplo, para descubrir cuáles
métodos han sido recientemente incorporados por una dada clase (o sea,
métodos que no sobrecargan métodos de las superclases) podemos navegar
desde la clase al dicionario de métodos como se muestra a
continuación:
\mthindex{Behavior}{methodDict}
\begin{code}{}
[:aClass| aClass methodDict keys select: [:aMethod |
  (aClass superclass canUnderstand: aMethod) not ]] value: SmallInteger
  --> an IdentitySet(#threeDigitName #printStringBase:nDigits: ...)
\end{code}

El método compilado no almacena solamente los bytecodes del método.
Es un objeto que proporciona muchos métodos útiles para consultar el
sistema.  Uno de tales métodos es \ct{isAbstract} (que nos indica si
el método envía \ct{subclassResponsibility}).  Podemos usarlo para
identificar todos los métodos abstractos de una clase abstracta.
\needlines{4}
\begin{code}{}
[:aClass| aClass methodDict keys select: [:aMethod |
  (aClass>>aMethod) isAbstract ]] value: Number
  --> an IdentitySet(#storeOn:base: #printOn:base: #+ #- #* #/ ...)
\end{code}
Advierte como este código envía el mensaje \ct{>>} a una clase para
obtener el método compilado de un selector dado.

% As a slightly more complex example, we can browse

Para pasear por los sends a super dentro de una jerarquía dada, por
ejemplo dentro de la jerarquía de Collection, podemos realizar una
consulta más sofisticada:
\begin{code}{}
class := Collection.
SystemNavigation default
  browseMessageList: (class withAllSubclasses gather: [:each |
    each methodDict associations
      select: [:assoc | assoc value sendsToSuper]
      thenCollect: [:assoc | MethodReference class: each selector: assoc key]])
  name: 'Supersends of ' , class name , ' and its subclasses'
\end{code}
Nota como navegamos desde las clases a los diccionarios de métodos,
hasta los métodos compilados para identificar los métodos en los
cuales estamos interesados.  El \ct{MethodReference} es un proxy
liviano para un método compilado; muchas herramientas utilizan estos
proxys.  Hay un método de facilitación llamado
\clsmthind{CompiledMethod}{methodReference} que retorna la referencia
de método de un método compilado.
\begin{code}{@TEST}
(Object>>#=) methodReference methodSymbol --> #=
\end{code}

%======================================
\section{Entornos de navegación}

Aún cuando \clsind{SystemNavigation} ofrece algunas maneras
programáticas que resultan útiles a la hora de consultar y navegar por
el código del sistema mediante, hay otro método mejor.  El
\ind{Refactoring Browser}, que está integrado en \pharo, proporciona
tanto una vía interactiva como una programática para realizar
consultas complejas.

Supongamos que queremos averiguar cuáles de los métodos dentro de la
jerarquía \lct{Collection} envían un mensaje a \super que sea diferente
del selector del método.  Esto se considera un mal \ind{olor de
  código} [code smell], porque el send a \super normalmente debería
poder reemplazarse por un send a \self. (Piénsalo por un momento: la
\emph{necesidad} de \super se debe a que lo utilizamos para extender
el método que estamos sobrecargando; ¡todos los otros métodos
heredados se pueden acceder mediante mensajes a \self!

El navegador de refactoreo [refactoring browser] nos proporciona una
manera elegante de restringir la consulta sólo a las clases y métodos
en los cuales estamos interesados.


En \figref{sendDifferentSuper} podemos ver que hay 19 métodos con esas
caracerísticas dentro de la jerarquía \ct{Collection}, entre los
cuales está \ct{Collection>>>printNameOn:}, que envía el mensaje
\ct{super printOn:}.
\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{sendDifferentSuper}
        \caption{Cómo encontrar métodos que envían un mensaje a \super diferente.\figlabel{sendDifferentSuper}}
\end{figure}

Los entornos de navegación también se pueden crear programáticamente.
A continuación, por ejemplo, vamos a crear un nuevo
\clsind{BrowserEnvironment} para \clsind{Collection} y sus subclases,
seleccionaremos los métodos que envían mensajes a \super y abriremos
el entorno resultante.
\needlines{4}
\begin{code}{}
((BrowserEnvironment new forClasses: (Collection withAllSubclasses))
        selectMethods: [:method | method sendsToSuper])
        label: 'Collection methods sending super';
        open.
\end{code}{}

Puedes notar cómo esta forma es considerablemente más compacta que la
anterior, cuando usamos \ct{SystemNavigation}.

Por último, podemos buscar aquellos métodos que envían un \super
diferente en forma programática como se muestra a continuación:
\needlines{6}
\begin{code}{}
((BrowserEnvironment new forClasses: (Collection withAllSubclasses))
        selectMethods: [:method |
                method sendsToSuper
                and: [(method parseTree superMessages includes: method selector) not]])
        label: 'Collection methods sending different super';
        open
\end{code}

En este caso solicitamos a cada método compilado su árbol sintáctico
(del Refactoring Browser) para ver cuáles de los mensajes a \super
difieren del selector del método.  Para ver qué se puede hacer con los
árboles sintácticos, echa una mirada al protocolo \prot{querying} de
la clase \ct{RBProgramNode}.

%======================================
\section{Cómo acceder al contexto de tiempo de ejecución}

Ya hemos visto como las capacidades de reflexión de \st nos permiten
consultar y explorar objetos, clases y métodos.  ¿Y qué podemos hacer
con el entorno de ejecución?

%-----------------------------------------------------------------
\subsection{Contexto de los métodos}

De hecho, el contexto de tiempo de ejecución de un método que está
corriendo reside en la máquina virtual --- ¡ni siquiera está en la
imagen!  Por otro lado, el \ind{debugger} obviamente tiene acceso a
esta información, y podemos explorar con facilidad el contexto de
tiempo de ejecución, al igual que hacemos con cualquier otro objeto.
¿Cómo puede ser esto posible?

En realidad, no hay nada de magia en el depurador.  El secreto es la
seudovariable \pvind{thisContext}, que ya hemos visto antes, aunque
sólo de pasada.  Cuando se referencia a \ct{thisContext} dentro de un
método en ejecución, se reifica el contexto completo de ejecución de
dicho método y a ese objeto se lo deja accesible a la imagen en la
forma de una serie de objetos \clsind{MethodContext} encadenados.

Podemos hacer unos experimentos on este mecanismo.

\dothis{Cambia la definición de \ct{Integer>>>factorial}, para ello
  inserta la expresión subrayada que se muestra más abajo:}

\mthindex{Object}{halt}
\begin{code}{}
Integer>>>factorial
        "Answer the factorial of the receiver."
        self = 0 ifTrue: [!\underline{thisContext explore. self halt.}! ^ 1].
        self > 0 ifTrue: [^ self * (self - 1) factorial].
        self error: 'Not valid for negative integers'
\end{code}

\dothis{Ahora evalúa \ct{3 factorial} en un espacio de trabajo.
  Deberías ver tanto una ventana de depurador como un explorador, tal
  como se muestra en \figref{exploringThisContext}.}

\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{exploringThisContext}
        \caption{ Cómo explorar
          \lct{thisContext}.\figlabel{exploringThisContext}}
\end{figure}

¡Bienvenido al depurador del pobre!
Si navegas ahora por la clase del objeto explorado (evalúa \ct{self browse}
en el panel inferior del explorador) vas a descubrir que es
una instancia de la clase \lct{MethodContext}, tal como cada uno de
los \ct{sender} en la cadena.

% All of these objects have been created dynamically in the image by
% the \st virtual machine at the point where \ct{thisContext} was
% referred to in the \ct{factorial} method. \lr{Not actually. In all
%   the currently available VMs the context objects are created with
%   every method activation, no matter if they are accessed using
%   \ct{thisContext} or not.}

\ct{thisContext} no está pensado para usarse en la programación
cotidiana, pero es esencial en la implementación de herramientas tales
como los depuradores, y para acceder a la información de la pila de
llamadas.  Puedes evaluar la siguiente expresión para descubrir cuáles
métodos utilizan a \ct{thisContext}:

\begin{code}{}
SystemNavigation default browseMethodsWithSourceString: 'thisContext'
\end{code}

Como puedes ver, una de las aplicaciones más comunes es para descubrir
el remitente de un mensaje.  A continuación se muestra una aplicación
típica:
\begin{code}{}
Object>>>subclassResponsibility
        "This message sets up a framework for the behavior of the class' subclasses.
        Announce that the subclass should have implemented this message."

        self error: 'My subclass should have overridden ', thisContext sender selector printString
\end{code}

Por convención, los métodos en \st que envían \ct{self subclassResponsibility}
se consideran abstractos.  Ahora bien, ¿cómo
hace \clsmthind{Object}{subclassResponsibility} para proporcionar un
mensaje de error útil que indique cuál de los métodos abstractos ha
sido invocado?  Muy simple, preguntando cuál es el \ct{thisContext}
del remitente.

\lr{I think co-routines and continuations should at least mentioned
  here. Another very practical application that is simple and could be
  shown here is the ``escaper''. Store the current context into a temp
  or inst-var \ct{target := thisContext} and jump back to that stack
  frame at a later point in time using \ct{target return: 123}.}
\sd{lukas maybe we should have another chapter showing such kind of
  beasts. I would love to read it.  Showing how to use block to build
  exception and such a kind of point. I think that this chapter should
  be an introduction may be we should have a Reflection applied
  chapter} \lr{I would love to help writing such a chapter}
%-----------------------------------------------------------------
\subsection{Puntos de interrupción inteligentes}

\mthindex{Object}{halt}

La manera a la \st de crear un punto de interrupción [breakpoint]
consiste en evaluar \ct{self halt} en una posición interesante de un
método.  Esto hace que \ct{thisContext} se reifique y que se abra una
ventana de \ind{debugger} sobre el punto de interrupción.
Desafortunadamente, esto plantea problemas para los métodos
intensamente usados en el sistema.

Supongamos, por ejemplo, que deseamos explorar la ejecución de
\ct{OrderedCollection>>>add:}.  Resulta problemático configurar un
punto de interrupción en este método.

\dothis{Toma una imagen \emph{fresca} y configura los siguientes
  puntos de interrupción:}
\needlines{3}
\begin{code}{}
OrderedCollection>>>add: newObject
        !\underline{self halt.}!
        ^self addLast: newObject
\end{code}

¡La imagen se congela de inmediato!  Ni siquiera aparece una ventana
del navegador.  El problema se aclara cuando comprendemos que
(\textsc{I}) el sistema usa a \ct{OrderedCollection>>>add:} en muchas
partes, y por lo tanto el punto de interrupción se dispara un momento
después de aceptar el cambio, y además (\textsc{II}) \emph{el propio
  depurador} envía \ct{add:} a una instancia de
\ct{OrderedCollection}, lo cual impide que se abra la ventana del
depurador.  Lo que necesitamos es una forma de \emph{hacer un halt
  condicional} sólo si nos encontramos en un contexto que sea de
nuestro interés.  Esto es exactamente lo que ofrece
\clsmthind{Object}{haltIf:}.

Supongamos que sólo queremos un halt si \ct{add:} es enviado desde,
digamos, el contexto de \ct{OrderedCollectionTest>>>testAdd}.

\dothis{Levanta una imagen fresca de nuevo, y configura el siguiente
  punto de interrupción:}
\begin{code}{}
OrderedCollection>>>add: newObject
        !\underline{self haltIf: \#testAdd.}!
        ^self addLast: newObject
\end{code}

Esta vez la imagen no se congela.  Prueba de correr el
\ct{OrderedCollectionTest}.  (Lo puedes encontrar en la categoría
\scat{CollectionsTests-Sequenceable}.) 

¿Cómo funciona esto?  Echemos una mirada a
\clsmthind{Object}{haltIf:}: 
\begin{code}{}
Object>>>haltIf: condition
        | cntxt |
        condition isSymbol ifTrue: [
                "only halt if a method with selector symbol is in callchain"
                cntxt := thisContext.
                [cntxt sender isNil] whileFalse: [
                        cntxt := cntxt sender.
                        (cntxt selector = condition) ifTrue: [Halt signal]. ].
                ^self.
        ].
        ...
\end{code}

Para cada contexto, desde \ct!thisContext!, \ct!haltIf:! hacia arriba
en la pila de ejecución, se comprueba si el nombre del método que hace
la llamada es el mismo símbolo que el recibido como parámetro.  Si se
da el caso, se levanta una excepción, que de manera predeterminada
apremia al depurador.

También se puede proporcionar un valor booleano o un bloque booleano
como argumento de \ct{haltIf:}, pero esos casos son sencillos y no
utilizan a \ct{thisContext}.

%======================================
\section{Cómo interceptar los mensajes no definidos}
\seclabel{msgnotunderstood}

Hasta ahora utilizamos las capacidades de reflexión computacional de
\st principalmente para consultar y explorar objetos, clases, métodos
y la pila de tiempo de ejecución.  Ahora veremos cómo usar nuestro
conocimiento de la estructua del sistema \st para interceptar mensajes
y modificar comportamiento al momento de ejecución.

Cuando un objeto recibe un mensaje, revisa primero en el diccionario
de métodos de su clase para encontrar el método correspondiente que
responda al mensaje.  Si no existe un método tal, continúa revisando
hacia arriba en la jeraquía de clases, hasta que llega a \ct{Object}.
Si no se encuentra ningún método para ese mensaje, el objeto \emph{se
  envía a sí mismo} el mensaje \ct{doesNotUnderstand:} con el selector
del mensaje como su argumento.  El proceso se inicia de nuevo, hasta
que se encuentra a \clsmthind{Object}{doesNotUnderstand:} y se lanza
el depurador.

¿Pero qué sucede si \ct{doesNotUnderstand:} está sobrecargado en una
de las subclases de \ct{Object} en la ruta que se revisa?  Como
veremos, ésta es una manera conveniente de realizar ciertas clases de
comportamiento muy dinámico.  Un objeto que no responde [does not
understand] a un mensaje puede sobrecargar \ct{doesNotUnderstand:}
para proporcionar una estrategia alternativa para responder al mensaje
de marras.

Hay dos aplicaciones muy comunes de esta técnica: (1) para implementar
\ind{proxies livianos} [\ind{lightweight proxies}] para los objetos, y
(2) para compilar o cargar código faltante.

%-----------------------------------------------------------------
\subsection{Proxies livianos}

En el primer caso, vamos a a introducir un «\ind{objeto mínimo}»
[\ind{minimal object}] para que actúe como proxy a favor de un objeto
existente.  Como el proxy prácticamente no implementa métodos propios,
cualquier mensaje que se le envíe será interceptado por
\ct{doesNotUnderstand:}.  Al implementar este mensaje, el proxy puede
realizar una acción especial antes de delegar el mensaje al objeto
real del cual es un proxy.

Veamos ahora cómo puede implementarse esta idea\footnote{También
  puedes cargar \pkg{PBE-Reflection} desde
  \url{http://www.squeaksource.com/PharoByExample/}}.

Definimos el \ct{LoggingProxy} como se muestra a continuación:
\begin{code}{}
ProtoObject subclass: #LoggingProxy
        instanceVariableNames: 'subject invocationCount'
        classVariableNames: ''
        poolDictionaries: ''
        category: 'PBE-Reflection'
\end{code}
Creamos la subclase de \ct{ProtoObject}, en lugar de hacerlo desde
\ct{Object} porque no queremos que nuestro proxy herede ¡más de 400
métodos! de \ct{Object}.

\begin{code}{}
Object methodDict size --> 408
\end{code}

Nuestro proxy tiene dos variables de instancia: \ct{subject} es el
sujeto de quien es proxy, y \ct{count} con la cantidad de mensajes que
ha interceptado.  Inicializamos las dos variables de instancia y
proporcionamos un accesor para la cuenta de mensajes.  Inicialmente la
variable \ct{subject} apunta al proxy mismo.
\begin{code}{}
LoggingProxy>>>initialize
        invocationCount := 0.
        subject := self.
\end{code}

\begin{code}{}
LoggingProxy>>>invocationCount
        ^ invocationCount
\end{code}

Ahora interceptamos todos los mensajes no definidos, los escribimos en
el Transcript, actualizamos la cuenta de mensajes, y reenviamos el
mensaje al sujeto real.
\begin{code}{}
LoggingProxy>>>doesNotUnderstand: aMessage
        Transcript show: 'performing ', aMessage printString; cr.
        invocationCount := invocationCount + 1.
        ^ aMessage sendTo: subject
\end{code}

Aquí va un poquito de magia.  Creamos un nuevo objeto \ct{Point} y un
nuevo \ct{LoggingProxy}, y luego hacemos que el proxy se transforme
(\mthind{ProtoObject}{become:}) en el objeto punto:
\seeindex{\ct{become:}}{\ct{ProtoObject>>>become:}}
\begin{code}{}
point := 1@2.
LoggingProxy new !\underline{become:}! point.
\end{code}

Esto tiene el efecto de intercambiar todas las referencias en la
imagen que apuntaban al punto y ahora apuntan al proxy, y viceversa.
Lo más importante: ¡ahora la variable de instancia \ct{subject} va a
referirse al punto!

\begin{code}{}
point invocationCount --> 0
point + (3@4)             --> 4@6
point invocationCount --> 1
\end{code}

Esto funciona muy bien en la mayoría de los casos, pero hay algunas
desventajas: 
\begin{code}{}
point class --> LoggingProxy
\end{code}

Resulta curioso que el método \ct{class} no está implementado ni
siquiera en \ct{ProtoObject} sino en \ct{Object}, ¡del cual no hereda
\ct{LoggingProxy}!  La respuesta a este acertijo es que \ct{class}
nunca se envía como mensaje, sino que la respuesta la da directamente
la máquina virtual.\footnote{\ct{yourself} tampoco se envía,
  verdaderamente.  Hay otros mensajes que pueden ser interpretados
  directamente por la máquina virtual, que dependen del receptor,
  entre ellos están:
\ct{+- < > <= >= = ~= * / \ ==}
\ct{@ bitShift: // bitAnd: bitOr:}
\ct{at: at:put: size}
\ct{next nextPut: atEnd}
\ct{blockCopy: value value: do: new new: x y}.
Hay selectores que nunca se envían, porque el compilador los compila
en l\'inea y los transforma a bytecodes de comparación y salto:
\ct{ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:}
\ct{and: or:}
\ct{whileFalse: whileTrue: whileFalse whileTrue}
\ct{to:do: to:by:do:}
\ct{caseOf: caseOf:otherwise:}
\ct{ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:}
Si sobrecargamos \ct{mustBeBoolean} en el receptor se pueden
interceptar los intentos de enviar esos mensajes a objetos que no son
booleanos y continuar la ejecución sobre un valor booleano válido.
Otra forma de hacerlo es capturar la excepción
\ct{NonBooleanReceiver}}% NB: Notes by Lukas Renggli 

Aún si podemos ignorar tales envíos especiales de mensajes, exite otro
problema fundamental que no se puede sobrellevar mediante este
enfoque:  los envíos a \self no pueden interceptarse:
\begin{code}{}
point := 1@2.
LoggingProxy new become: point.
point invocationCount --> 0
point rect: (3@4)        --> 1@2 corner: 3@4
point invocationCount --> 1
\end{code}

Nuestro proxy ha sido estafado por dos envíos a \self en el
método \ct{rect:}
\begin{code}{}
Point>>>rect: aPoint
        ^ Rectangle  origin: (self min: aPoint) corner: (self max: aPoint)
\end{code}

Aún cuando los proxies pueden interceptar mensajes mediante el uso de
esta técnica, uno debe ser conciente de las limitaciones inherentes al
utilizar un proxy.  En \secref{wrapper} veremos otro enfoque, más
general, para interceptar mensajes.

%-----------------------------------------------------------------
\subsection{Cómo generar los métodos faltantes}

La otra aplicación más popular de la intercepción de mensajes no
definidos es la carga o generación dinámica de los métodos faltantes.
Considere una biblioteca muy extensa de clases que tiene muchos
métodos.  En lugar de cargar la biblioteca completa, podemos cargar un
empalme para cada clase de la biblioteca.  Los empalmes saben
dónde encontrar el código fuente de todos sus métodos.  Los
empalmes simplemente interceptan todos los mensajes no entendidos y cargan dinámicamente los métodos faltantes a medida que son necesarios.  En algún momento posterior se puede desactivar este comportamiento, y grabar el código cargado como el mínimo subconjunto necesario para la aplicación cliente.

% \on{Stef sez: check ObjectOut -- I looked, but this seems to be very
%   old. Depends on SqueakPage.}

Vamos a estudiar una variante simple de esta técnica donde tenemos una
clase que agrega automáticamente los accesores para sus variables de
instancia cuando sean necesarios:
% \lr{the last statement should return the result of the message,
%   otherwise you cannot proceed with the debugger}
% \alex{all redefinition of doesNotUnderstand: includes a return
%   statement. However, I do not see your comment lukas, I tried to
%   insert a 'self halt' in the method, I was able to proceed. I added
%   the return in the function}
% \lr{Of course it depends on the exact circumstances. If you perform
%   a message on self that returns self it does not matter, but in any
%   other case a forgotten return can introduce strange side
%   effects. There was no return in the listing below, but now there
%   is and the problem is solved.}

\begin{code}{}
DynamicAcccessors>>>doesNotUnderstand: aMessage
        | messageName |
        messageName := aMessage selector asString.
        (self class instVarNames includes: messageName)
                ifTrue: [
                        self class compile: messageName, String cr, ' ^ ', messageName.
                        ^ aMessage sendTo: self ].
        ^ super doesNotUnderstand: aMessage
\end{code}
Cualquier mensaje no definido se intercepta aquí.  Si existe una
variable de instancia con el mismo nombre del mensaje, entonces
solicitamos a nuestra clase que compile un accesor para esa variable
de instancia y reenviamos el mensaje.

Supongamos que la clase \ct{DynamicAcccessors} tiene una variable de
instancia (sin inicializar) llamada \ct{x} pero la misma no tiene un
accesor predefinido.  Entonces el código siguiente va a generar el
accesor dinámicamente y a recuperar su valor:\needlines{2}
\begin{code}{}
myDA := DynamicAccessors new.
myDA x --> nil
\end{code}

Vayamos paso a paso para ver lo que sucede la primera vez que se envía
el mensaje \ct{x} a nuestro objeto (mira \figref{DynamicAccessors}).

\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{DynamicAccessors}
        \caption{Creaci\'on din\'amica de Accessors.\figlabel{DynamicAccessors}}
        % \alex{not sure whether the figure is highly necessary. The code is rather simple and the figure complete to follow in my opinion.}}
        % \on{trust me, it is useful to see all the steps.}
\end{figure}

(1) Enviamos \ct{x} a \ct{myDA}, (2) el mensaje se busca desde la
clase hacia arriba en la jerarquía, y (3) no se lo encuentra allí.
(4) Esto genera un \ct{self doesNotUnderstand: #x} que se envía de
vuelta al objeto, (5) lo que dispara una nueva búsqueda.  Esta vez, se
encuentra a \ct{doesNotUnderstand:} inmediatamente en
\ct{DynamicAccessors}, (6) el cual pide a su clase que compile la
cadena \ct{'x ^ x'}.  El método \ct{compile} se busca hacia arriba
(7), y (8) finalmante se encuantra en \ct{Behavior}, el cual (9--10)
agrega el nuevo método compilado al diccionario de métodos de
\ct{DynamicAccessors}.  Por último, (11--13) el mensaje se reenvía, y
esta vez se lo encuentra.

La misma técnica se puede usar para generar setters para las variables
de instancia, u otros tipos de código basado en plantillas, como los
métodos de visita de un Visitor.

Se puede advertir el uso de \clsmthind{Object}{perform:} en el paso
(13), que se puede utilizar para enviar mensajes compuestos al momento
de ejecución:
\begin{code}{@TEST}
5 perform: #factorial                                             --> 120
6 perform: ('fac', 'torial') asSymbol                       --> 720
4 perform: #max: withArguments: (Array with: 6) --> 6
\end{code}

%======================================
\section{Los objetos como métodos wrappers}
\seclabel{wrapper}

Ya hemos visto que los métodos compilados son objetos ordinarios en
\st, y que admiten ciertos métodos para permitir que el programador
consulte el sistema de tiempo de ejecución.  Lo que tal vez cause un
poco de sorpresa es que \emph{cualquier objeto}  puede jugar el rol de
un método compilado.  Todo lo que debe hacer es responder al mensaje
\ct{run:with:in:} y otros pocos más mensajes importantes.

\dothis{Define una clase vacía \ct{Demo}.  Evalúa \ct{Demo new
    answer42} y nota cómo se dispara el error usual ``Message Not
  Understood''.}


Ahora vamos a instalar un objeto llano de \st en el diccionario de
métodos de nuestra clase \ct{Demo}.


\dothis{Evalúa \lct{Demo methodDict at: \#answer42 put:
    ObjectsAsMethodsExample new.} Ahora intenta obtener de nuevo el resultado de \ct{Demo new
  answer42}.  Esta vez obtenemos la respuesta \ct{42}.}

Si echamos una mirada a la clase \clsind{ObjectsAsMethodsExample}
vamos a encontrar los siguientes métodos:

%\alex{I would prefer having return 42 in the run:with:in: method, and not having answer42 defined in ObjectsAsMethodsExample, this could be confusing I imagine}
%\on{ObjectsAsMethodsExample is part of the standard pharo image -- it is not in PBE-Reflection}
\needlines{5}
\begin{code}{}
answer42
        ^42

run: oldSelector with: arguments in: aReceiver
        ^self perform: oldSelector withArguments: arguments
\end{code}

Cuando nuestra instancia de \ct{Demo} recibe el mensaje \ct{answer42},
la búsqueda del método procede como es usual, sin embargo, la máquina
virtual detecta que en lugar de un método compilado hay un objeto
ordinario tratando de ocupar su lugar.

La VM enviará a este objeto un nuevo mensaje \ct{run:with:in:} con el
selector del método original, los argumentos y el receptor como sus
argumentos.
Como  \ct{ObjectsAsMethodsExample} implementa este método, intercepta
el mensaje y lo delega a sí mismo.


Ahora podemos eliminar el método extraño con:
\begin{code}{}
Demo methodDict removeKey: #answer42 ifAbsent: []
\end{code}

Si miramos con atención en \ct{ObjectsAsMethodsExample}, veremos que
su superclase también implementa los métodos \ct{flushcache},
\ct{methodClass:} y \lct{selector:}, pero que están todos vacíos.
Estos mensajes se pueden enviar a los métodos compilados, y por lo
tanto deben ser implementados por cualquier objeto que pretenda
hacerse pasar por un método compilado.  (\ct{flushcache} es el método
más importante que se debe implementar; los otros pueden llegar a ser
necesarios pero eso depende de si el método se instala mediante
\clsmthind{Behavior}{addSelector:withMethod:} o directamente mediante
la utilización de \clsmthind{MethodDictionary}{at:put:}.)


%-------------------------------------------------------------------------
\subsection{Usando m\'etodos wrappers para realizar pruebas de cobertura}

Los m\'etodos wrappers son una t\'ecnica bastante conocida para interceptar mensajes \cite{Bran98a}. En la implementaci\'on original\footnote{http://www.squeaksource.com/MethodWrappers.html}, un m\'etodo wrapper es una instancia de la subclase \ct{CompiledMethod}. Al instalarlo, el m\'etodo wrapper puede realizar acciones especiales antes o despu\'es de invocar al m\'etodo original. Cuando se desinstala, el m\'etodo original es devuelto a su correcta posici\'on en el diccionario de m\'etodos.

En Pharo, los \ind{m\'etodos wrappers} pueden ser implementados m\'as facilmente al implementar \ct{run:with:in:} como instancia de la la subclase \ct{CompiledMethod}. De hecho, existe una implementaci\'on ligera de objetos como m\'etodos wrappers\footnote{http://www.squeaksource.com/ObjectsAsMethodsWrap.html}, pero esto no forma parte de Pharo estandar al momento de escribir esto.

Sin embargo, el Pharo Test Runner usa precisamente esta técnica para evaluar la cobertura de los test. Hechemos un vistazo al funcionamiento de esto:

El punto de entrada para la prueba de cobertura es el m\'etodo \clsmthind{TestRunner}{runCoverage}:
\begin{code}{}
TestRunner>>>runCoverage
        | packages methods |
        ... "identify methods to check for coverage"
        self collectCoverageFor: methods
\end{code}

El m\'etodo \clsmthind{TestRunner}{collectCoverageFor:} claramente ilustra el algoritmo que chequea la cobertura:
\begin{code}{}
TestRunner>>>collectCoverageFor: methods
        | wrappers suite |
        wrappers := methods collect: [ :each | TestCoverage on: each ].
        suite := self
                reset;
                suiteAll.
        [ wrappers do: [ :each | each install ].
          [ self runSuite: suite ] ensure: [ wrappers do: [ :each | each uninstall ] ] ] valueUnpreemptively.
        wrappers := wrappers reject: [ :each | each hasRun ].
        wrappers isEmpty
                ifTrue:
                        [ UIManager default inform: 'Congratulations. Your tests cover all code under analysis.' ]
                ifFalse: ...
\end{code}
Un wrapper es creado por cada m\'etodo a ser chequeado y cada wrapper se instala. Al correr la prueba, todos los wrappers son desintalados. Finalmente el usuario obtiene la informaci\'on acerca de cuales m\'etodos no han estado cubiertos.

C\'omo hace el wrapper su trabajo? El wrapper \ct{TestCoverage} tiene tres variables de instacia \ct{hasRun}, \ct{reference} and \ct{method}.
Se inicializan as\'i:
\begin{code}{}
TestCoverage class>>>on: aMethodReference
        ^ self new initializeOn: aMethodReference

TestCoverage>>>initializeOn: aMethodReference
        hasRun := false.
        reference := aMethodReference.
        method := reference compiledMethod
\end{code}

La instalaci\'on y desinstalaci\'on de los m\'etodos simplemente actualiza el diccionario de m\'etodos en la forma obvia:
\begin{code}{}
TestCoverage>>>install
        reference actualClass methodDictionary
                at: reference methodSymbol
                put: self

TestCoverage>>>uninstall
        reference actualClass methodDictionary
                at: reference methodSymbol
                put: method
\end{code}
\noindent
y el m\'etodo \ct{run:with:in:} simplemente actualiza la variable \ct{hasRun} ,desinstala el wrapper (una vez que la cobertura haya sido verificada), y reenv\'ia el mensaje al m\'etodo original
\begin{code}{}
run: aSelector with: anArray in: aReceiver
        self mark; uninstall.
        ^ aReceiver withArgs: anArray executeMethod: method

mark
        hasRun := true
\end{code}
(Dele un vistazo a \clsmthind{ProtoObject}{withArgs:executeMethod:} para ver c\'omo  un m\'etodo desplazado de su diccionario de m\'etodos puede ser invocado.)

Esto es todo lo que hay que hacer!

Los m\'etodos wrappers puede ser usados para realizar cualquier tipo de comportamiento adecuado antes o despu\'es de la normal operaci\'on de un m\'etodo. Aplicaciones t\'ipicas son en instrumentaci\'on (recolectando estad\'isticas sobre invocaciones de los patrones de m\'etodos), chequeo de pre- y post- condiciones,
y en memoization (opcionalmente haciendo cache de valores computados por los m\'etodos).

%======================================
\section{Pragmas}

Un \emphind{pragma} es una anotación que espec\'ifica informaci\'on espec\'ifica sobre un programa, pero que no est\'a envuelto en su ejecuci\'on. Los Pragmas no afectan directamente la operaci\'on del m\'etodo que anotan. Los Pragmas tienen variados usos, como ser:

\begin{itemize}
\item Informaci\'on del compilador: Los \indmain{pragmas} pueden ser usados para hacer que un m\'etodo llame a una funci\'on primitiva. Esta funci\'on tiene que estar definida por la m\'aquina virtual o ser un pluggin externo.

\item Procesamiento en tiempo de ejecuci\'on: Algunos pragmas est\'an disponibles para ser examinados en tiempo de ejecuci\'on.
\end{itemize}

Los pragmas pueden ser aplicados a la declaraci\'on de m\'etodos de un programa solamente. Un m\'etodo puede declarar uno o m\'as pragmas y todos los pragmas deben estar declarados anteriormente a cualquier sentencia Smalltalk. Cada pragma es efectivamente un mensaje est\'atico enviado con argumentos literales.

Brevemente mencionamos pragmas cuando introdujimos primitivas al comienzo de este cap\'itulo. Una primitiva no es m\'as qu una declaraci\'on de pragma. Considere \ct{<primitive: 73>} que est\'a contenida en \ct{instVarAt:}. El selector de pragma es \ct{primitive:} y su argumento es un inmediato valor literal \ct{73}.

El compilador es probablemente el mayor usuario de pragmas. SUnit es otra herramienta que hace uso de las anotaciones. SUnit es capaz de estimar la cobertura de una aplicaci\'on desde una unidad de prueba. Uno puede querer excluir algunos m\'etodos de la cobertura. Este es el caso del m\'etodo \ct{documentation} en la clase \ct{SplitJointTest}:  

\begin{code}{}
SplitJointTest class>>>documentation
        <ignoreForCoverage>
        "self showDocumentation"

        ^ 'This package provides function.... "
\end{code}

Simplemente anotando un m\'etodo con el pragma \ct!<ignoreForCoverage>! uno puede controlar el alcance de la cobertura

%Beside the compiler, Lint is a heavy user of pragmas. Lint is a static code analyzer that flags suspicious, non-portable constructs and code that is likely to contain bugs. It may happen that a method needs to be excluded from Lint analysis. This is the case here:

%\begin{code}{}
%MorphObjectOut>>>doesNotUnderstand: aMessage
%       "Bring in the object, install, then resend aMessage"
%       "Transcript show: thisContext sender selector; cr."
%       "useful for debugging"
%
%       ! \textbf{<lint: 'Unnecessary "= true"' rationale: 'recursionFlag may be nil' author: 'stephane.ducasse'>}!
%       ...
%\end{code}

%One of the pragmas used by Lint to filter out methods is \ct{lint:rationale:author:}.

Como instancias de la clase \clsind{Pragma}, los pragmas son objetos de primera clase. Un m\'etodo compilado responde al mensaje \mthind{CompiledMethod}{pragmas}. Este m\'etodo devuelve un arreglo de pragmas.

\begin{code}{@TEST}
(SplitJoinTest class >> #showDocumentation) pragmas
  --> an Array(<ignoreForCoverage>)
(Float>>#+) pragmas --> an Array(<primitive: 41>)
\end{code}


Los m\'etodos que definene una consulta particular pueden ser devueltos desde la clase. La class-side \ct!SplitJoinTest! contiene algunos m\'etodos anotados con \ct!<ignoreForCoverage>!:

\begin{code}{@TEST}
Pragma allNamed: #ignoreForCoverage in: SplitJoinTest class  --> an Array(<ignoreForCoverage> <ignoreForCoverage> <ignoreForCoverage>)
\end{code}

Una variante de \ct{allNamed:in:} puede ser encontrada en la class-side de \ct{Pragma}.

Un pragma conoce en cual m\'etodo esta definido (usando \ct{method}), el nombre del m\'etodo (\ct{selector}) la clase que contiene el m\'etodo (\ct{methodClass}), su n\'umero de argumentos (\ct{numArgs}), acerca de los literales que el pragma tiene por argumentos (\ct{hasLiteral:} y \ct{hasLiteralSuchThat:}).

\lr{Tipicamente los pragmas son realizados sobre un objeto it\'erprete que entienda el mensaje del pragma.}

%======================================
\section{Resumen del cap\'itulo}

Reflexi\'on se refiere a la habilidad de consultar, examinar e incluso modificar metaobjetos tanto del sistema en ejecuci\'on como objetos ordinarios.

\begin{itemize}
\item El Inspector usa \ct{instVarAt:} y m\'etodos realacionados para consultar y modificar variables de instancia ``privadas'' de los objetos.
\item Envie \ct{Behavior>>>allInstances} para consultar instancias de una clase.
\item Los mensajes \ct{class}, \ct{isKindOf:}, \ct{respondsTo:} \etc  son \'utiles para obtener m\'etricas o construir herramientas de desarrollo, pero deben ser evitados en aplicaciones regulares: Violan el encapsulamiento de los objetos y hacen su c\'odigo dif\'icil de entender y mantener
\item \ct{SystemNavigation} es una clase \'util para explotar muchas \'utiles consultas sobre la navegaci\'on e inspecci\'on de la jerarqu\'ia de \ct class. Por ejemplo, use \ct {SystemNavigation default browseMethodsWithSourceString: 'pharo'.} para encontrar y ver todos los m\'etodos con una determinada cadena de caracteres. (Es lento, pero completo!)
\item Cada clase de \st apunta a una instancia del \ct{MethodDictionary} el cual mapea selectores a instancias de \ct{CompiledMethod}. Un m\'etodo compilado conoce su propia clase, cerrando el c\'irculo.
\item \ct{MethodReference} es un proxy ligero para un m\'etodo compilado, proveyendo conveniententemen m\'etodos adicionales y es usado por muchas herramientas de \st .
\item \ct{BrowserEnvironment}, es parte de la infraestructura del Refactoring Browser, ofrece una interfaz m\'as refinada que \ct{SystemNavigation} para consultas el sistema, desde el resultado de una consulta, puede ser usado como el alcance de una nueva consulta. Tanto la GUI y las intefaces programables est\'an disponibles.
\item \ct{thisContext} es una pseudo-variable que reifica la pila de ejecuci\'on de la m\'aquina virtual. Es mayormente usada por el depurador para construir din\'amicamente una vista interactiva de la pila. Es tambi\'en \'util para determinar din\'amicamente el remitente de un mensaje.
\item Los puntos de ruptura inteligentes pueden ser ajustados usando \ct{haltIf:}, tomando un selector de m\'etodo como su argumento. \ct{haltIf:} se detiene solo si el m\'etodo se\~nalado es un remitente en la pila de ejecuci\'on.
\item Una manera com\'un de interceptar mensajes enviados a un determinado destino es usando un ``objeto m\'inimo'' como proxy del destino. El proxy implementa tan pocos m\'etodos como le es posible y atrapa todos los mensajes enviados por la implementaci\'on de \ct{doesNotunderstand:}. Tambi\'en puede ser usado para realizar algunas acciones adiciones y reci\'en entonces enviar el mensajes al destino original.
\item Enviar \ct{become:} para intercambiar las referencias de dos objetos , tal como un proxy y su destino.
\item Cuidado, algunos mensajes, como  \ct{class} y \ct{yourself} nunca son realmenten enviados, pero son interceptados por la m\'aquina virtual. Otros, como \ct{+}, \ct{ifTrue:} y \ct{-} pueden ser directamente interceptados o introducidos por la m\'aquina virtual dependiendo del receptor.
\item Otro uso t\'ipico para la sobreescritura de \ct{doesNotUnderstand:} es la carga  lenta o la compilaci\'on de m\'etodos perdidos.
\item \ct{doesNotUnderstand:} no puede atrapar \self-sends.
\item Una forma m\'as rigurosa de interceptar mensajes es usar un objeto como un m\'etodo wrapper. Este tipo de objeto es instalado en el diccionario de m\'etodos en lugar de un m\'etodo compilado.  Deber\'ia implementar \ct{run:with:in:}, el cual es enviado por la m\'aquina virtual cuando detecta un objeto ordinario en lugar de un m\'etodo compilado en el diccionario de m\'etodos. Esta t\'ecnica es usada por SUnit Test Runner para recoger informaci\'on sobre la cobertura.
\end{itemize}

%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=========================================================

%Other stuff:
%- anonymous classes (uses compile: and primitiveChangeClassTo:) ???
%- collect direct senders; class collaborations
%- Object primitiveChangeClassTo: become: and becomeForward: (see tests and slides with minimal object example)
%- PointerFinder?
%- anonymous classes (see slides) ?

%Test  Coverage using ObjectsAsMethodsWrap package:
%\begin{code}{}
%category := 'SCGPier'.
%w := (ObjectAsOneTimeMethodWrapper installOnClassCategory: category).
%tr := TestRunner new.
%ToolBuilder open: tr.
%[tr
%       categoryAt: (tr categoryList indexOf: 'SCGPier') put: true;
%       selectAllClasses;
%       runAll.]
%ensure: [[w do: [:each| each uninstall ]] valueUnpreemptively].
%((w select: [:each | each executed not ])
%       collect: [:each | each wrappedClass name, '>>', each selector name ]) explore.
%\end{code}


%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: "../PBE1.tex"
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "castellano8"
%%% End:
