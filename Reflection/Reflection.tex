 $Author$
% $Date$
% $Revision$

% HISTORY: [see also Metaprogramming2.tex]
% 2007-05-22 - Damien Pollet started (translation from French article by ...?)
% 2008-01-15 - Alex added text
% 2008-12-15 - Oscar revised
% 2009-03-24 - Stef started new chapter (acttalk ... see separate file)
% 2009-06-01 - Oscar started to revise again and add new material
% 2009-06-08 - Lukas -- unsent messages
% 2009-06-15 - Oscar completed revision
% 2009-06-16 _ Stef comments
% 2009-06-17 - Alexandre completed revision
% 2009-06-19 - Lukas comments
% 2009-07-07 - Oscar migrated to Pharo; fixed broken tests
% 2009-08-16 - Oscar indexing and cleaning up loose ends

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
        \documentclass[a4paper,10pt,twoside]{book}
        \usepackage[
                papersize={6.13in,9.21in},
                hmargin={.75in,.75in},
                vmargin={.75in,1in},
                ignoreheadfoot
        ]{geometry}
        \input{../common.tex}
        \pagestyle{headings}
        \setboolean{lulu}{true}
% --------------------------------------------
% A4:
%       \documentclass[a4paper,11pt,twoside]{book}
%       \input{../common.tex}
%       \usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
        \begin{document}
        % \renewcommand{\nnbb}[2]{} % Disable editorial comments
        \sloppy
\fi

%=================================================================
\chapter{Reflexión}\chalabel{reflection}

\indexmain{reflection}
\st es un lenguaje de programación con reflexión computacional.
En pocas palabras, quiere decir que los programas son capaces de
«reflexionar» sobre su propia ejecución y estructura.
% \lr{not only on execution, also on the static model}
% pp 301 cesar
En un sentido más técnico, esto significa que
los \emphind{metaobjetos} del sistema en tiempo de ejecución
pueden \emph{reificarse} como objetos ordinarios, a los cuales se
puede consultar e inspeccionar.  Los metaobjetos en \st son las
clases, metaclases, diccionarios de métodos, métodos compilados, la
pila al momento de ejecución, y otros.  Esta forma de reflexión
también se denomina \emphind{introspección}, y muchos lenguajes
modernos de programación la permiten.

\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{reflect}
        \caption{Reificación y reflexión.\figlabel{reflect}} % \lr{not referenced, not sure if I understand it}
\end{figure}

En el sentido contrario, en \st resulta posible modificar los
metaobjetos reificados y \emph{reflejar} esos cambios de vuelta al
sistema en ejecución (puedes verlo en la \figref{reflect}).  Esta
actividad también se denomina \emph{intercesión}. La intercesión está
presente principalmente en los lenguajes de programación dinámicos
mientras que los lenguajes estáticos sólo la admiten en un grado muy
limitado.

Un programa que manipula otros programas (o se manipula a sí mismo) es
un \emphind{metaprograma}.  Para que un lenguaje de programación sea
capaz de reflexión computacional debe permitir tanto la
\ind{introspección} como la \ind{intercesión}.  La introspección es la
capacidad de \emph{examinar} las estructuras de datos que definen el
lenguaje, como los objetos, clases, métodos y la pila de ejecución.
La intercesión es la capacidad de \emph{modificar} dichas estructuras,
o sea, de alterar la semántica del lenguaje y el comportamiento del
programa desde el interior del propio programa.  La \emph{reflexión
  estructural} examina y modifica la estructura del sistema de tiempo
de ejecución y la \emphind{reflexión de comportamiento} modifica la
interpretación de esas estructuras.

Ene ste capítulo nos enfocaremos principalmente en la \ind{reflexión
  estructural}.  Vamos a explorar muchos ejemplos prácticos que
ilustrarán como \st permite la introspección y la metaprogramación.

%======================================
\section{Introspección}

Mediante el inspector, puedes mirar dentro de un objeto, cambiar los
valores de sus variables de instancia, e incluso enciarle mensajes.

\dothis{Evalúa el siguiente código en un workspace:}
\begin{code}{| w |}
w := Workspace new.
w openLabel: 'My workspace'.
w inspect.
\end{code}

Esto va a abrir un segundo workspace y un inspector.  El inspector
muestra el estado interno de este nuevo espacio de trabajo, lista sus
variables de instancia en la parte izquierda (\ct!dependents!,
\ct!contents!, \ct!bindings!, \ldots) y en la parte derecha se ve el
valor de la variable de instancia seleccionada.  La variable de
instancia \ct!contents! representa lo que se muestra en el área de
texto del espacio de trabajo, así que si lo seleccionas, la parte
derecha va a mostrar una cadena vacía.

\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{workspaceInspector}
        \caption{Inspección de un\ct!Workspace!.\figlabel{workspaceInspector}}
\end{figure}

\dothis{Ahora escribe \ct!'hello'! en lugar de esa cadena vacía, y
  luego \emph{accept}ala.}

El valor de la variable \ct!contents! va a cambiar, pero la ventana
del espacio de trabajo no se percata de ello, así que no se vuelve a
regenerar lo que muestra.  Para que se refresque el contenido en la
ventana, evalúa \ct!self contentsChanged!  en la parte inferior del
inspector.

%-----------------------------------------------------------------
\subsection{Cómo se accede a las variables de instancia}


¿Cómo funciona el inspector?  En \st, todas las variables de instancia
son protegidas.  En teoría, es imposible accederlas desde otro objeto
si la clase no define sus accesores.  En la práctica, el
inspectorpuede acceder a las variables de instancia sin necesidad de
accesores, porque usa las capacidades de reflexión computacional de
\st.  En \st, las clases definen variables de instancia o bien
mediante un nombre o bien mediante un índice numérico.  El inspector
usa métodos definidos en la clase \ct!Object! para accederlas:
\lct{instVarAt: \emph{index}} y \lct{instVarNamed: \emph{aString}} se
usan para acceder al valor de la variable de instancia en la posición
\lct{\emph{index}} o aquella cuyo nombre es \lct{\emph{aString}},
respectivamente; para asignar nuevos valores a esas variables de
instancia utiliza \ct!instVarAt:put:! y \ct!instVarNamed:put:!.
\mthindex{Object}{instVarAt:} \mthindex{Object}{instVarNamed:}
\mthindex{Object}{instVarAt:put:} \mthindex{Object}{instVarNamed:put:}

Por ejemplo, puedes cambiar el valor asociado a \ct!w! en el primer
espacio de trabajo mediante la evaluación de:
\begin{code}{}
w instVarNamed: 'contents' put: 'howdy!'; contentsChanged
\end{code}

\important{\emph{Precaución:} Aunque estos métodos resultan útiles
  para construir herramientas de desarrollo, es una mala idea usarlos
  para desarrollar aplicaciones convencionales: estos métodos de
  reflexión computacional violan los límites de la encapsulación de
  los objetos y por lo tanto pueden hacer que tu código sea mucho más
  difícil de comprender y mantener.}
  % \lr{Why? The access does not show up when looking for all
  %   readers/writers in the code browser.}

Tanto \ct!instVarAt:! como \ct!instVarAt:put:! son \ind{métodos
  primitivos}, lo que significa que están implementados como
operaciones primitivas de la máquina virtual de \pharo.  Si revisas el
código de esos métodos verás la sintaxis especial \ind{pragma}
\ct!<primitive: N>! donde \ct!N! es un entero.
% \lr{actually this is the syntax of pragmas (method annotations),
%   \ct!primitive:! is just a special kind of pragma}

\needlines{5}
\begin{code}{}
Object>>>instVarAt: index
        "Primitive. Answer a fixed variable in an object. ..."
        !\textbf{<primitive: 73>}!
        "Access beyond fixed variables."
        ^self basicAt: index - self class instSize
\end{code}

En el caso más usual no se ejecuta el código que sigue a la invocación
de la primitiva.  Sólo se ejecuta si la primitiva falla.  En este caso
específico, si tratamos de acceder una variable que no existe entonces
se ejecuta el código que sigue a la primitiva.  De este modo se
permite también que el debugger se inicie sobre métodos primitivos.
Aunque es posible modificar el código de los métodos primitivos, debes
entender que es una actividad de alto riesgo para la estabilidad de tu
sistema \pharo.

\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{allInstanceVariables}
        \caption{Vista de todas las variables de instancia de un \ct!Workspace!.\figlabel{allInstanceVariables}}
\end{figure}

La \figref{allInstanceVariables} muestra cómo pueden verse los valores
de las variables de instancia de una instancia arbitraria (\ct!w!) de
la clase \ct!Workspace!.  El método \ct!allInstVarNames! retorna todos
los nombres de las variables de instancia de una dada clase.

De manera similar, es posible conseguir las instancias que tienen
ciertas propiedades específicas.  Por ejemplo, para obtener todas las
instancias de la clase \ct!SketchMorph! cuya variable de instancia
\ct!owner! está asociada al morph mundo (o sea, las imágenes que se
muestran en este momento), prueba la siguiente expresión:
\begin{code}{}
SketchMorph allInstances select: [:c | (c instVarNamed: 'owner') isWorldMorph]
\end{code}

%-----------------------------------------------------------------
\subsection{Cómo recorrer las variables de instancia}

\mthindex{Object}{instanceVariableValues}
Consideremos el mensaje \ct!instanceVariableValues!, que devuelve una
colección de todos los valores de variables de instancia definidos en
dicha clase, sin tener en cuenta las variables de instancia
heredadas.  Por ejemplo:
\begin{code}{@TEST}
(1@2) instanceVariableValues --> an OrderedCollection(1 2)
\end{code}

El método está implementado en \ct{Object} como se muestra a
continuación:
\needlines{9}
\begin{code}{}
Object>>>instanceVariableValues
        "Answer a collection whose elements are the values of those instance variables of the receiver which were added by the receiver's class."
        | c |
        c := OrderedCollection new.
        self class superclass instSize + 1
                to: self class instSize
                do: [ :i | c add: (self instVarAt: i)].
        ^ c
\end{code}

Este método itera sobre los índices de las variables de instancia que
están definidas en la clase; el primer valor corresponde al primer
índice no usado por la superclase.  (El método \ct!instSize! retorna
la cantidad de variables de instancia nominadas que define una clase.)

%-----------------------------------------------------------------
\subsection{Cómo consultar clases e interfaces}

Tods las herramientas de desarrollo de \pharo (code browser,
debugger, inspector\ldots) utilizan las características de reflexión
computacional que hemos visto hasta ahora.

Se muestran a continuación otros mensajes que pueden resultar útiles
para construir herramientas de desarrollo:

\lct{isKindOf: \emph{aClass}} returna true si el receptor es una
instancia de \lct{\emph{aClass}} o una de sus superclases.  Por
ejemplo:
\begin{code}{@TEST}
1.5 class                     --> Float
1.5 isKindOf: Number --> true
1.5 isKindOf: Integer   --> false
\end{code}
\mthindex{Object}{class}
\mthindex{Object}{isKindOf:}

\lct{respondsTo: \emph{aSymbol}} returna true si el receptor tiene un
método cuyo selector es \lct{\emph{aSymbol}}.
Por ejemplo:
\needlines{3}
\begin{code}{@TEST}
1.5 respondsTo: #floor      --> true    "pues Number implementa floor"
1.5 floor                            --> 1
Exception respondsTo: #, --> true    "las clases de exception se pueden agrupar"
\end{code}
\mthindex{Object}{respondsTo:}

\important{\emph{Precaución:} Aunque estas características resultan
  especialmente útiles para escribir herramientas de desarrollo,
  normalmente no son apropiadas para escribir aplicaciones típicas.
  Cuando uno consulta a un objeto para saber su clase o para saber
  a cuáles mensajes responde, estamos en presencia de señales típicas
  que apuntan a problemas de diseño, pues estas consultas violan el
  principio de encapsulación.  Las herramientas de desarrollo, sin
  embargo, no son aplicaciones normales, pues su dominio es el del
  software en sí mismo.  Por ello, estas herramientas tienen derecho a
  indagar profundamente en los detalles internos del código.}

% There also exist mechanisms for introspecting on various parts of
% the run-time system, such as the process scheduler, the memory
% manager and so on. For now we will focus on navigating through
% objects, classes and methods, and we will look more closely at rest
% of the runtime system in an other chapter.  \on{let's not mention
%   this if we don't actually write such a chapter!}

%-----------------------------------------------------------------
\subsection{Métricas de código}

Veamos cómo podemos usar las características de introspección de \st
para extraer rápidamente algunas métricas de código.  Las
\ind{métricas} de código miden aspectos tales como la profundidad de
la jerarquía de herencia, la cantidad directa e indirecta de
subclases, la cantidad de métodos o de variables de instancia en cada
clase, o la cantidad de métodos o variables de instancia definidos
localmente.  A continuación se muestran unas métricas para la clase
\ct!Morph!, que es la superclase de todos los objetos gráficos en
\pharo, y que revelan que se trata de una clase enorme, y que es la
raíz de una enorme jerarquía. ¡Tal vez está necesitada de un poco de
refactoring!

\mthindex{Behavior}{allSuperclasses}
\mthindex{Behavior}{allSelectors}
\mthindex{Behavior}{allInstVarNames}
\mthindex{Behavior}{selectors}
\mthindex{Behavior}{instVarNames}
\mthindex{Behavior}{subclasses}
\mthindex{Behavior}{allSubclasses}
\mthindex{ClassDescription}{linesOfCode}
\begin{code}{}
Morph allSuperclasses size.  -->       2 "profundidad de la herencia"
Morph allSelectors size.        --> 1378 "cantidad de metodos"
Morph allInstVarNames size. -->      6 "cantidad de variables de instancia"
Morph selectors size.             -->  998 "cantidad de nuevos metodos"
Morph instVarNames size.     -->      6 "cantidad de nuevas variables"
Morph subclasses size.          -->    45 "cantidad de subclases directas"
Morph allSubclasses size.      -->  326 "total de subclases"
Morph linesOfCode.               --> 5968 "cantidad total de lineas de codigo"
\end{code}

Una de las métricas más interesantes en el dominio de los lenguajes
orientados a objetos es la cantidad de métodos que extienden métodos
heredados desde la superclase.  Ella nos informa de la relación entre
la clase y sus superclases.  En las siguientes secciones veremos cómo
aprovechar nuestro conocimiento de la estructura de tiempo de
ejecución para responder estas cuestiones.

%======================================
\section{Cómo navegar por el código}

En \st, todo es un objeto.  En particular, las clases son objetos que
nos proporcionan mecanismos útiles para navegar entre sus instancias.
La mayoría de los mensajes que vamos a estudiar están implementados en
\ct{Behavior} y por lo tanto todas las clases responden a ellos.

Como ya vimos antes, puedes obtener una instancia de una clase dada si
le envías el mensaje \ct!#someInstance!.
\mthindex{Behavior}{someInstance}
\begin{code}{@TEST} % Possibly fragile!
Point someInstance --> 0@0
\end{code}

Además, puedes obtener todas las instancias con \ct!#allInstances!, y
la cantidad de instancias activas en memoria con \ct!#instanceCount!.

\alex{In a Pharo0.1-10342dev09.96.3, I have "ByteString instanceCount
  --> 63607"}
\mthindex{Behavior}{allInstances}
\mthindex{Behavior}{instanceCount}
\mthindex{Behavior}{allSubInstances}
\begin{code}{} % Cannot test this
ByteString allInstances        --> #('collection' 'position'  ...)
ByteString instanceCount    --> 104565
String allSubInstances size -->  101675
\end{code}

Estas características pueden resultar muy útiles al depurar una
aplicación, porque puedes solicitar a una clase que enumere aquellos
de sus métodos que exhiben ciertas propiedades.
\begin{itemize}
\item \mthind{Behavior}{whichSelectorsAccess:} returna la lista de
  todos los selectores de métodos que leen o escriben la variable de
  instancia nombrada por el argumento
\item \mthind{Behavior}{whichSelectorsStoreInto:} returna los
  selectores de métodos que modifican el valor de una variable de
  instancia dada
\item \mthind{Behavior}{whichSelectorsReferTo:} returna los selectores
  de métodos que envían un dado mensaje
\item \mthind{Behavior}{crossReference} asocia cada mensaje con el
  conjunto de métodos que lo envían.
\end{itemize}

\begin{code}{} % TOO FRAGILE TO TEST
Point whichSelectorsAccess: 'x'    --> an IdentitySet(#'\\' #= #scaleBy: ...)
Point whichSelectorsStoreInto: 'x' --> an IdentitySet(#setX:setY: ...)
Point whichSelectorsReferTo: #+  --> an IdentitySet(#rotateBy:about: ...)
Point crossReference --> an Array(
                an Array('*' an IdentitySet(#rotateBy:about: ...))
                an Array('+' an IdentitySet(#rotateBy:about: ...))
                ...)
\end{code}

Los siguientes mensajes tienen en cuenta a la herencia:

\begin{itemize}
\item \mthind{Behavior}{whichClassIncludesSelector:} returna la
  superclase que implementa el mensaje dado
\item \mthind{Behavior}{unreferencedInstanceVariables} returna la
  lista de variables de instancia que no se usan en la clase del
  receptor ni en sus subclases.
\end{itemize}

\begin{code}{@TEST}
Rectangle whichClassIncludesSelector: #inspect --> Object
Rectangle unreferencedInstanceVariables            --> #()
\end{code}

\clsind{SystemNavigation} es un ***facade*** que incluye varios
métodos útiles para consultar y navegar a través del código fuente del
sistema.  \ct{SystemNavigation} \mthind{SystemNavigation
  class}{default} returna una instancia que puedes usar para navegar
por el sistema.  Por ejemplo:

\mthindex{SystemNavigation}{allClassesImplementing:}
\begin{code}{@TEST}
SystemNavigation default allClassesImplementing: #yourself --> {Object}
\end{code}

Los siguientes mensajes se explican solos:

\mthindex{SystemNavigation}{allSentMessages}
\mthindex{SystemNavigation}{allUnsentMessages}
\mthindex{SystemNavigation}{allUnimplementedCalls}
\begin{code}{}
SystemNavigation default allSentMessages size          --> 24930
SystemNavigation default allUnsentMessages size      --> 6431
SystemNavigation default allUnimplementedCalls size --> 270
\end{code}

Que un mensaje esté implementado y que nadie lo envíe no es
necesariamwnte una señal de un mensaje inútil, pues puede ser que se
lo envíe implícitamente (por ejemplo, mediante \ct{perform:}).  Los
mensajes que se envían pero no están implementados son más
problemáticos, porque los métodos que envían esos mensajes van a
fallar en tiempo de ejecución.  Son la señal de una implementación sin
terminar, APIs obsoletas o bibliotecas faltantes.

\mthindex{SystemNavigation}{allCallsOn:}
\ct!SystemNavigation default allCallsOn: #Point! returna todos los
mensajes enviados explícitamente a \ct!Point! como receptor.

Todas estas características están integradas en el entorno de
programación de \pharo, en particular en los navegadores de código.
Como ya conocerás, hay atajos de teclado convenientes para navegar por
todos los i\underline{m}plementors (\short{m}) y se\underline{n}ders
(\short{n}) de un mensaje dado.  Lo que tal vez no resulte tan
conocido es que hay muchas consultas preparadas que están
implementadas como métodos de la clase \ct{SystemNavigation} en el
protocolo \prot{browsing}.  Por ejemplo, puedes encontrar
programáticamente todos los implementadores del mensaje \ct{ifTrue:}
mediante la evaluación de:
\mthindex{SystemNavigation}{browseAllImplementorsOf:}
\begin{code}{}
SystemNavigation default browseAllImplementorsOf: #ifTrue:
\end{code}

\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{implementors}
        \caption{Implementadores de \ct!\#ifTrue:!.\figlabel{implementors}}
\end{figure}

Los métodos \ct{browseAllSelect:} y
\lct{browseMethodsWithSourceString:} son particularmente útiles.  A
continuación se muestran dos manera diferentes de revisar todos los
métodos en el sistema que envían mensajes a super (la primera es más
bien por fuerza bruta; la segunda es mejor y elimina algunos falsos
positivos):
\mthindex{SystemNavigation}{browseMethodsWithSourceString:}
\mthindex{SystemNavigation}{browseAllSelect:}
\begin{code}{}
SystemNavigation default browseMethodsWithSourceString: 'super'.
SystemNavigation default browseAllSelect: [:method | method sendsToSuper ].
\end{code}

%======================================
\section{Clases, dicionarios de métodos y métodos}

Como las clases son objetos, podemos inspeccionarlas o explorarlas
como a cualquier otro objeto.

\mthindex{Object}{explore}
\dothis{Evalúa \ct{Point explore}.}

En \figref{CompiledMethod}, el \ind{explorer} muestra la estructura de
la clase \clsind{Point}.  Puedes ver que la clase almacena sus métodos
en un diccionario, indexados por su selector.  El selector \ct{#*}
apunta al \ind{bytecode} descompilado de \ct!Point>>>*!.

\begin{figure}[ht]\centering
        \includegraphics[width=.5\linewidth]{CompiledMethod}
        \caption{Explorer:la clase \ct!Point! y el bytecode de su método \ct!\#*!.\figlabel{CompiledMethod}}
\end{figure}

Vamos a considerar la relación entre clases y métodos.  En
\figref{MethodsAsObjects} vemos que las clases y metaclases tienen en
común a la superclase \ct{Behavior}.  Aquí es donde se define a
\mthind{Behavior}{new}, entre otros métodos para las clases.  Cada
clase tiene un diccionario de métodos, el cual mapea selectores de
métodos en \ind{métodos compilados}.  Cada método compilado conoce la
clase en la cual está instalado.  En \figref{CompiledMethod} podemos
ver incluso que esto se almacena en una asociacion en \ct{literal5}.

\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{MethodsAsObjects}
        \caption{Clases, diccionarios de métodos y métodos compilados\figlabel{MethodsAsObjects}}
\end{figure}

Podemos aprovechar las relaciones entre clases y métodos para realizar
consultas sobre el sistema.  Por ejemplo, para descubrir cuáles
métodos han sido recientemente incorporados por una dada clase (o sea,
métodos que no sobrecargan métodos de las superclases) podemos navegar
desde la clase al dicionario de métodos como se muestra a
continuación:
\mthindex{Behavior}{methodDict}
\begin{code}{}
[:aClass| aClass methodDict keys select: [:aMethod |
  (aClass superclass canUnderstand: aMethod) not ]] value: SmallInteger
  --> an IdentitySet(#threeDigitName #printStringBase:nDigits: ...)
\end{code}

EL método compilado no almacena solamente los bytecodes del método.
Es un objeto que proporciona muchos métodos útiles para co0nsultar el
sistema.  Uno de tales métodos es \ct{isAbstract} (que nos indica si
el método envía \ct{subclassResponsibility}).  Podemos usarlo para
ideentificar todos los métodos abstractos de una clase abstracta.
\needlines{4}
\begin{code}{}
[:aClass| aClass methodDict keys select: [:aMethod |
  (aClass>>aMethod) isAbstract ]] value: Number
  --> an IdentitySet(#storeOn:base: #printOn:base: #+ #- #* #/ ...)
\end{code}
Advierte como este código envía el mensaje \ct{>>} a una clase para
obtener el método compilado de un selector dado.

% As a slightly more complex example, we can browse

Para pasear por los sends a super dentro de una dada jerarquía, por
ejemplo dentro de la jerarquía de Collection, podemos realizar una
consulta más sofisticada:
\begin{code}{}
class := Collection.
SystemNavigation default
  browseMessageList: (class withAllSubclasses gather: [:each |
    each methodDict associations
      select: [:assoc | assoc value sendsToSuper]
      thenCollect: [:assoc | MethodReference class: each selector: assoc key]])
  name: 'Supersends of ' , class name , ' and its subclasses'
\end{code}
Nota como navegamos desde las clases a los diccionarios de métodos,
hasta los métodos compilados para identificar los métodos en los
cuales estamos interesados.  El \ct{MethodReference} es un proxy
liviano para un método compilado; muchas herramientas utilizan estos
proxys.  Hay un método de facilitación llamado
\clsmthind{CompiledMethod}{methodReference} que retorna la referencia
de método de un método compilado.
\begin{code}{@TEST}
(Object>>#=) methodReference methodSymbol --> #=
\end{code}

%======================================
\section{Entornos de navegación}

Aún cuando \clsind{SystemNavigation} ofrece algunas maneras
programáticas que resultan útiles a la hora de consultar y navegar por
el código del sistema mediante, hay otro método mejor.  El
\ind{Refactoring Browser}, que está integrado en \pharo, proporciona
tanto una vía interactiva como una programática para realizar
consultas complejas.

Supongamos que queremos averiguar cuáles de los métodos dentro de la
jerarquía \lct{Collection}envían un mensaje a \super que sea diferente
del selector del método.  Esto se considera un mal \ind{olor de
  código} [code smell], porque el send a \super normalmente debería
poder reemplazarse por un send a \self. (Piénsalo por un momento: la
\emph{necesidad} de \super se debe a que lo utilizamos para extender
el método que estamos sobrecargando; ¡todos los otros métodos
heredados se pueden acceder mediante mensajes a \self!

El navegador de refactoreo [refactoring browser] nos proporciona una
manera elegante de restringir la consulta sólo a las clases y métodos
en los cuales estamos interesados.


En \figref{sendDifferentSuper} podemos ver que hay 19 métodos con esas
caracerísticas dentro de la jerarquía \ct{Collection}, entre los
cuales está \ct{Collection>>>printNameOn:}, que envía el mensaje
\ct{super printOn:}.
\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{sendDifferentSuper}
        \caption{Cómo encontrar métodos que envían un mensaje a \super diferente.\figlabel{sendDifferentSuper}}
\end{figure}

Los entornos de navegación también se pueden crear programáticamente.
A continuación, por ejemplo, vamos a crear un nuevo
\clsind{BrowserEnvironment} para \clsind{Collection} y sus subclases,
seleccionaremos los métodos que envían mensajes a \super y abriremos
el entorno resultante.
\needlines{4}
\begin{code}{}
((BrowserEnvironment new forClasses: (Collection withAllSubclasses))
        selectMethods: [:method | method sendsToSuper])
        label: 'Collection methods sending super';
        open.
\end{code}{}

Puedes notar cómo esta forma es considerablemente más compacta que la
anterior, cuando usamos \ct{SystemNavigation}.

Por último, podemos buscar aquellos métodos que envían un \super
diferente en forma programática como se muestra a continuación:
\needlines{6}
\begin{code}{}
((BrowserEnvironment new forClasses: (Collection withAllSubclasses))
        selectMethods: [:method |
                method sendsToSuper
                and: [(method parseTree superMessages includes: method selector) not]])
        label: 'Collection methods sending different super';
        open
\end{code}

En este caso solicitamos a cada método compilado su árbol sintáctico
(del Refactoring Browser) para ver cuáles de los mensajes a \super
difieren del selector del método.  Para ver qué se puede hacer con los
árboles sintácticos, echa una mirada al protocolo \prot{querying} de
la clase \ct{RBProgramNode}.

%======================================
\section{Cómo acceder al contexto de tiempo de ejecución}

Ya hemos visto como las capacidades de reflexión de \st nos permiten
consultar y explorar objetos, clases y métodos.  ¿Y qué podemos hacer
con el entorno de ejecución?

%-----------------------------------------------------------------
\subsection{Contexto de los métodos}

De hecho, el contexto de tiempo de ejecución de un método que está
corriendo reside en la máquina virtual --- ¡ni siquiera está en la
imagen!  Por otro lado, el \ind{debugger} obviamente tiene acceso a
esta información, y podemos explorar con facilidad el contexto de
tiempo de ejecución, al igual que hacemos con cualquier otro objeto.
¿Cómo puede ser esto posible?

En realidad, no hay nada de magia en el depurador.  El secreto es la
seudovariable \pvind{thisContext}, que ya hemos visto antes, aunque
sólo de pasada.  Cuando se referencia a \ct{thisContext} dentro de un
método en ejecución, se reifica el contexto completo de ejecución de
dicho método y a ese objeto se lo deja accesible a la imagen en la
forma de una serie de objetos \clsind{MethodContext} encadenados.

Podemos hacer unos experimentos on este mecanismo.

\dothis{Cambia la definición de \ct{Integer>>>factorial}, para ello
  inserta la expresión subrayada que se muestra más abajo:}

\mthindex{Object}{halt}
\begin{code}{}
Integer>>>factorial
        "Answer the factorial of the receiver."
        self = 0 ifTrue: [!\underline{thisContext explore. self halt.}! ^ 1].
        self > 0 ifTrue: [^ self * (self - 1) factorial].
        self error: 'Not valid for negative integers'
\end{code}

\dothis{Ahora evalúa \ct{3 factorial} en un espacio de trabajo.
  Deberías ver tanto una ventana de depurador como un explorador, tal
  como se muestra en \figref{exploringThisContext}.}

\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{exploringThisContext}
        \caption{ Cómo explorar
          \lct{thisContext}.\figlabel{exploringThisContext}}
\end{figure}

¡Bienvenido al depurador del pobre!
Si navegas ahora por la clase del objeto explorado (evalúa \ct{self browse}
en el panel inferior del explorador) vas a descubrir que es
una instancia de la clase \lct{MethodContext}, tal como cada uno de
los \ct{sender} en la cadena.

% All of these objects have been created dynamically in the image by
% the \st virtual machine at the point where \ct{thisContext} was
% referred to in the \ct{factorial} method. \lr{Not actually. In all
%   the currently available VMs the context objects are created with
%   every method activation, no matter if they are accessed using
%   \ct{thisContext} or not.}

\ct{thisContext} no está pensado para usarse en la programación
cotidiana, pero es esencial en la implementación de herramientas tales
como los depuradores, y para acceder a la información de la pila de
llamadas.  Puedes evaluar la siguiente expresión para descubrir cuáles
métodos utilizan a \ct{thisContext}:

\begin{code}{}
SystemNavigation default browseMethodsWithSourceString: 'thisContext'
\end{code}

Como pudes ver, una de las aplicaciones más comunes es para descubrir
el enviador de un mensaje.  A continuación se muestra una aplicación
típica:
\begin{code}{}
Object>>>subclassResponsibility
        "This message sets up a framework for the behavior of the class' subclasses.
        Announce that the subclass should have implemented this message."

        self error: 'My subclass should have overridden ', thisContext sender selector printString
\end{code}

Por convención, los métodos en \st que envían \ct{self subclassResponsibility}
se consideran abstractos.  Ahora bien, ¿cómo
hace \clsmthind{Object}{subclassResponsibility} para proporcionar un
mensaje de error útil que indique cuál de los métodos abstractos ha
sido invocado?  Muy simple, preguntando cuál es el \ct{thisContext}
del enviador.

\lr{I think co-routines and continuations should at least mentioned
  here. Another very practical application that is simple and could be
  shown here is the ``escaper''. Store the current context into a temp
  or inst-var \ct{target := thisContext} and jump back to that stack
  frame at a later point in time using \ct{target return: 123}.}
\sd{lukas maybe we should have another chapter showing such kind of
  beasts. I would love to read it.  Showing how to use block to build
  exception and such a kind of point. I think that this chapter should
  be an introduction may be we should have a Reflection applied
  chapter} \lr{I would love to help writing such a chapter}
%-----------------------------------------------------------------
\subsection{Puntos de interrupción inteligentes}

\mthindex{Object}{halt}

La manela a la \st de crear un punto de interrupción [breakpoint]
consiste en evaluar \ct{self halt} en una posición interesante de un
método.  Esto hace que \ct{thisContext} se reifique y que se abra una
ventana de \ind{debugger} sobre el punto de interrupción.
Desafortunadamente, esto plantea problemas para los métodos
intensamente usados en el sistema.

Supongamos, por ejemplo, que deseamos explorar la ejecución de
\ct{OrderedCollection>>>add:}.  Resulta problemático configurar un
punto de interrupción en este método.

\dothis{Toma una imagen \emph{fresca} y configura los siguientes
  puntos de interrupción:}
\needlines{3}
\begin{code}{}
OrderedCollection>>>add: newObject
        !\underline{self halt.}!
        ^self addLast: newObject
\end{code}

¡La imagen se congela de inmediato!  Ni siquiera aparece una ventana
del navegador.  El problema se aclara cuando comprendemos que
(\textsc{I}) el sistema usa a \ct{OrderedCollection>>>add:} en muchas
partes, y por lo tanto el punto de interrupción se dispara un momento
después de aceptar el cambio, y además (\textsc{II}) \emph{el propio
  depurador} envía \ct{add:} a una instancia de
\ct{OrderedCollection}, lo cual impide que se abra la ventana del
depurador.  Lo que necesitamos es una forma de \emph{hacer un halt
  condicional} sólo si nos encontramos en un contexto que sea de
nuestro interés.  Esto es exactamente lo que ofrece
\clsmthind{Object}{haltIf:}.

Supongamos que sólo queremos un halt si \ct{add:} es enviado desde,
digamos, el contexto de \ct{OrderedCollectionTest>>>testAdd}.

\dothis{Levanta una imagen fresca de nuevo, y configura el siguiente
  punto de interrupción:}
\begin{code}{}
OrderedCollection>>>add: newObject
        !\underline{self haltIf: \#testAdd.}!
        ^self addLast: newObject
\end{code}

Esta vez la imagen no se congela.  Prueba de correr el
\ct{OrderedCollectionTest}.  (Lo puedes encontrar en la categoría
\scat{CollectionsTests-Sequenceable}.) 

¿Cómo funciona esto?  Echemos una mirada a
\clsmthind{Object}{haltIf:}: 
\begin{code}{}
Object>>>haltIf: condition
        | cntxt |
        condition isSymbol ifTrue: [
                "only halt if a method with selector symbol is in callchain"
                cntxt := thisContext.
                [cntxt sender isNil] whileFalse: [
                        cntxt := cntxt sender.
                        (cntxt selector = condition) ifTrue: [Halt signal]. ].
                ^self.
        ].
        ...
\end{code}

Para cada contexto, desde \ct!thisContext!, \ct!haltIf:! hacia arriba
en la pila de ejecución, se comprueba si el nombre del método que hace
la llamada es el mismo símbolo que el recibido como parámetro.  Si se
da el caso, se levanta una excepción, que de manera predeterminada
***summons*** el depurador.

También se puede proporcionar un valor booleano o un bloque booleano
como argumento de \ct{haltIf:}, pero esos casos son sencillos y no
utilizan a \ct{thisContext}.

%======================================
\section{Cómo interceptar los mensajes no definidos}
\seclabel{msgnotunderstood}

Hasta ahora utilizamos las capacidades de reflexión computacional de
\st principalmente para consultar y explorar objetos, clases, métodos
y la pila de tiempo de ejecución.  Ahora veremos cómo usar nuestro
conocimiento de la estructua del sistema \st para interceptar mensajes
y modificar comportamiento al momento de ejecución.

Cuando un objeto recibe un mensaje, revisa primero en el diccionario
de métodos de su clase para encontrar el método correspondiente que
responda al mensaje.  Si no existe un método tal, continúa revisando
hacia arriba en la jeraquía de clases, hasta que llega a \ct{Object}.
Si no se encuentra ningún método para ese mensaje, el objeto \emph{se
  envía a sí mismo} el mensaje \ct{doesNotUnderstand:} con el selector
del mensaje como su argumento.  El proceso se inicia de nuevo, hasta
que se encuentra a \clsmthind{Object}{doesNotUnderstand:} y se lanza
el depurador.

¿Pero qué sucede si \ct{doesNotUnderstand:} está sobrecargado en una
de las subclases de \ct{Object} en la ruta que se revisa?  Como
veremos, ésta es una manera conveniente de realizar ciertas clases de
comportamiento muy dinámico.  Un objeto que no responde [does not
understand] a un mensaje puede sobrecargar \ct{doesNotUnderstand:}
para proporcionar una estrategia alternativa para responder al mensaje
de marras.

Hay dos aplicaciones muy comunes de esta técnica: (1) para implementar
\ind{proxies livianos} [\ind{lightweight proxies}] para los objetos, y
(2) para compilar o cargar código faltante.

%-----------------------------------------------------------------
\subsection{Proxies livianos}

En el primer caso, vamos a a introducir un «\ind{objeto mínimo}»
[\ind{minimal object}] para que actúe como proxy a favor de un objeto
existente.  Como el proxy prácticamente no implementa métodos propios,
cualquier mensaje que se le envíe será interceptado por
\ct{doesNotUnderstand:}.  Al implementar este mensaje, el proxy puede
realizar una acción especial antes de delegar el mensaje al objeto
real del cual es un proxy.

Veamos ahora cómo puede implementarse esta idea\footnote{También
  puedes cargar \pkg{PBE-Reflection} desde
  \url{http://www.squeaksource.com/PharoByExample/}}.

Definimos el \ct{LoggingProxy} como se muestra a continuación:
\begin{code}{}
ProtoObject subclass: #LoggingProxy
        instanceVariableNames: 'subject invocationCount'
        classVariableNames: ''
        poolDictionaries: ''
        category: 'PBE-Reflection'
\end{code}
Creamos la subclase de \ct{ProtoObject}, en lugar de hacerlo desde
\ct{Object} porque no queremos que nuestro proxy herede ¡más de 400
métodos! de \ct{Object}.

\begin{code}{}
Object methodDict size --> 408
\end{code}

Nuestro proxy tiene dos variables de instancia: \ct{subject} es el
sujeto de quien es proxy, y \ct{count} con la cantidad de mensajes que
ha interceptado.  Inicializamos las dos variables de instancia y
proporcionamos un accesor para la cuenta de mensajes.  Inicialmente la
variable \ct{subject} apunta al proxy mismo.
\begin{code}{}
LoggingProxy>>>initialize
        invocationCount := 0.
        subject := self.
\end{code}

\begin{code}{}
LoggingProxy>>>invocationCount
        ^ invocationCount
\end{code}

Ahora interceptamos todos los mensajes no definidos, los escribimos en
el Transcript, actualizamos la cuenta de mensajes, y reenviamos el
mensaje al sujeto real.
\begin{code}{}
LoggingProxy>>>doesNotUnderstand: aMessage
        Transcript show: 'performing ', aMessage printString; cr.
        invocationCount := invocationCount + 1.
        ^ aMessage sendTo: subject
\end{code}

Aquí va un poquito de magia.  Creamos un nuevo objeto \ct{Point} y un
nuevo \ct{LoggingProxy}, y luego hacemos que el proxy se transforme
(\mthind{ProtoObject}{become:}) en el objeto punto:
\seeindex{\ct{become:}}{\ct{ProtoObject>>>become:}}
\begin{code}{}
point := 1@2.
LoggingProxy new !\underline{become:}! point.
\end{code}

Esto tiene el efecto de intercambiar todas las referencias en la
imagen que apuntaban al punto y ahora apuntan al proxy, y viceversa.
Lo más importante: ¡ahora la variable de instancia \ct{subject} va a
referirse al punto!

\begin{code}{}
point invocationCount --> 0
point + (3@4)             --> 4@6
point invocationCount --> 1
\end{code}

Esto funciona muy bien en la mayoría de los casos, pero hay algunas
desventajas: 
\begin{code}{}
point class --> LoggingProxy
\end{code}

Resulta curioso que el método \ct{class} no está implementado ni
siquiera en \ct{ProtoObject} sino en \ct{Object}, ¡del cual no hereda
\ct{LoggingProxy}!  La respuesta a este ***riddle*** es que \ct{class}
nunca se envía como mensaje, sino que la respuesta la da directamente
la máquina virtual.\footnote{\ct{yourself} tampoco se envía,
  verdaderamente.  Hay otros mensajes que pueden ser interpretados
  directamente por la máquina virtual, que dependen del receptor,
  entre ellos están:
\ct{+- < > <= >= = ~= * / \ ==}
\ct{@ bitShift: // bitAnd: bitOr:}
\ct{at: at:put: size}
\ct{next nextPut: atEnd}
\ct{blockCopy: value value: do: new new: x y}.
Hay selectores que nunca se envían, porque el compilador los compila
***inline*** y los transforma a bytecodes de comparación y salto:
\ct{ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:}
\ct{and: or:}
\ct{whileFalse: whileTrue: whileFalse whileTrue}
\ct{to:do: to:by:do:}
\ct{caseOf: caseOf:otherwise:}
\ct{ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:}
Si sobrecargamos \ct{mustBeBoolean} en el receptor se pueden
interceptar los intentos de enviar esos mensajes a objetos que no son
booleanos y continuar la ejecución sobre un valor booleano válido.
Otra forma de hacerlo es capturar la excepción
\ct{NonBooleanReceiver}}% NB: Notes by Lukas Renggli 

Aún si podemos ignorar tales envíos especiales de mensajes, exite otro
problema fundamental que no se puede ***overcome*** mediante este
enfoque:  los envíos a \self no pueden interceptarse:
\begin{code}{}
point := 1@2.
LoggingProxy new become: point.
point invocationCount --> 0
point rect: (3@4)        --> 1@2 corner: 3@4
point invocationCount --> 1
\end{code}

Nuestro proxy ***has been cheated out*** de dos envíos a \self en el
método \ct{rect:}
\begin{code}{}
Point>>>rect: aPoint
        ^ Rectangle  origin: (self min: aPoint) corner: (self max: aPoint)
\end{code}

Aún cuando los proxies pueden interceptar mensajes mediante el uso de
esta técnica, uno debe ser conciente de las limitaciones inherentes al
utilizar un proxy.  En \secref{wrapper} veremos otro enfoque, más
general, para interceptar mensajes.

%-----------------------------------------------------------------
\subsection{Cómo generar los métodos faltantes}

La otra aplicación más popular de la intercepción de mensajes no
definidos es la carga o generación dinámica de los métodos faltantes.
Considere una biblioteca muy extensa de clases que tiene muchos
métodos.  En lugar de cargar la biblioteca completa, podemos cargar un
***stub*** para cada clase de la biblioteca.  Los ***stubs*** saben
dónde encontrar el código fuente de todos sus métodos.  Los
***stubs*** simplemente interceptan todos los mensajes ***does not
understand*** y cargan dinámicamente los métodos faltantes a medida
que son necesarios.  En algún momento posterior se puede desactivar
este comportamiento, y grabar el código cargado como el mínimo
subconjunto necesario para la aplicación cliente.

% \on{Stef sez: check ObjectOut -- I looked, but this seems to be very
%   old. Depends on SqueakPage.}

Vamos a estudiar una variante simple de esta técnica donde tenemos una
clase que agrega automáticamente los accesores para sus variables de
instancia cuando sean necesarios:
% \lr{the last statement should return the result of the message,
%   otherwise you cannot proceed with the debugger}
% \alex{all redefinition of doesNotUnderstand: includes a return
%   statement. However, I do not see your comment lukas, I tried to
%   insert a 'self halt' in the method, I was able to proceed. I added
%   the return in the function}
% \lr{Of course it depends on the exact circumstances. If you perform
%   a message on self that returns self it does not matter, but in any
%   other case a forgotten return can introduce strange side
%   effects. There was no return in the listing below, but now there
%   is and the problem is solved.}

\begin{code}{}
DynamicAcccessors>>>doesNotUnderstand: aMessage
        | messageName |
        messageName := aMessage selector asString.
        (self class instVarNames includes: messageName)
                ifTrue: [
                        self class compile: messageName, String cr, ' ^ ', messageName.
                        ^ aMessage sendTo: self ].
        ^ super doesNotUnderstand: aMessage
\end{code}
Cualquier mensaje no definido se intercepta aquí.  Si existe una
variable de instancia con el mismo nombre del mensaje, etonces
solicitamos a nuestra clase que compile un accesor para esa variable
de instancia y reenviamos el mensaje.

Supongamos que la clase \ct{DynamicAcccessors} tiene una variable de
instancia (sin inicializar) llamada \ct{x} pero la misma no tiene un
accesor predefinido.  Entonces el código siguiente va a generar el
accesor dinámicamente y a recuperar su valor:\needlines{2}
\begin{code}{}
myDA := DynamicAccessors new.
myDA x --> nil
\end{code}

Vayamos paso a paso para ver lo que sucede la primera vez que se envía
el mensaje \ct{x} a nuestro objeto (mira \figref{DynamicAccessors}).

\begin{figure}[ht]\centering
        \includegraphics[width=\linewidth]{DynamicAccessors}
        \caption{Dynamically creating accessors.\figlabel{DynamicAccessors}}
        % \alex{not sure whether the figure is highly necessary. The code is rather simple and the figure complete to follow in my opinion.}}
        % \on{trust me, it is useful to see all the steps.}
\end{figure}

(1) Enviamos \ct{x} a \ct{myDA}, (2) el mensaje se busca desde la
clase hacia arriba en la jerarquía, y (3) no se lo encuentra allí.
(4) Esto genera un \ct{self doesNotUnderstand: #x} que se envía de
vuelta al objeto, (5) lo que dispara una nueva búsqueda.  Esta vez, se
encuentra a \ct{doesNotUnderstand:} inmediatamente en
\ct{DynamicAccessors}, (6) el cual pide a su clase que compile la
cadena \ct{'x ^ x'}.  El método \ct{compile} se busca hacia arriba
(7), y (8) finalmante se encuantra en \ct{Behavior}, el cual (9--10)
agrega el nuevo método compilado al diccionario de métodos de
\ct{DynamicAccessors}.  Por último, (11--13) el mensaje se reenvía, y
esta vez se lo encuentra.

La misma técnica se puede usar para generar setters para las variables
de instancia, u otros tipos de código basado en plantillas, como los
métodos de visita de un Visitor.

Se puede advertir el uso de \clsmthind{Object}{perform:} en el paso
(13), que se puede utilizar para enviar mensajes compuestos al momento
de ejecución:
\begin{code}{@TEST}
5 perform: #factorial                                             --> 120
6 perform: ('fac', 'torial') asSymbol                       --> 720
4 perform: #max: withArguments: (Array with: 6) --> 6
\end{code}

%======================================
\section{Los objetos disfrazados de métodos}
\seclabel{wrapper}

Ya hemos visto que los métodos compilados son objetos ordinarios en
\st, y que admiten ciertos métodos para permitir que el programador
consulte el sistema de tiempo de ejecución.  Lo que tal vez cause un
poco de sorpresa es que \emph{cualquier objeto}  puede jugar el rol de
un método compilado.  Todo lo que debe hacer es responder al mensaje
\ct{run:with:in:} y otros pocos más mensajes importantes.

\dothis{Define una clase vacía \ct{Demo}.  Evalúa \ct{Demo new
    answer42} y nota cómo se dispara el error usual ``Message Not
  Understood''.}


Ahora vamos a instalar un objeto llano de \st en el diccionario de
métodos de nuestra clase \ct{Demo}.


\dothis{Evalúa \lct{Demo methodDict at: \#answer42 put:
    ObjectsAsMethodsExample new.}

Ahora intenta obtener de nuevo el resultado de \ct{Demo new
  answer42}.  Esta vez obtenemos la respuesta \ct{42}.

Si echamos una mirada a la clase \clsind{ObjectsAsMethodsExample}
vamos a encontrar los siguientes métodos:

%\alex{I would prefer having return 42 in the run:with:in: method, and not having answer42 defined in ObjectsAsMethodsExample, this could be confusing I imagine}
%\on{ObjectsAsMethodsExample is part of the standard pharo image -- it is not in PBE-Reflection}
\needlines{5}
\begin{code}{}
answer42
        ^42

run: oldSelector with: arguments in: aReceiver
        ^self perform: oldSelector withArguments: arguments
\end{code}

Cuando nuestra instancia de \ct{Demo} recibe el mensaje \ct{answer42},
la búsqueda del método procede como es usual, sin embargo, ka máquina
virtual detecta que en lugar de un método compilado hay un objeto
ordinario tratando de ocupar su lugar.

La VM enviará a este objeto un nuevo mensaje \ct{run:with:in:} con el
selector del método original, los argumentos y el receptor como sus
argumentos.
Como  \ct{ObjectsAsMethodsExample} implementa este método, intercepta
el mensaje y lo delega a sí mismo.


Ahora podemos eliminar el método extraño con:
\begin{code}{}
Demo methodDict removeKey: #answer42 ifAbsent: []
\end{code}

Si miramos con atención en \ct{ObjectsAsMethodsExample}, veremos que
su superclase también implementa los métodos \ct{flushcache},
\ct{methodClass:} y \lct{selector:}, pero que están todos vacíos.
Estos mensajes se pueden enviar a los métodos compilados, y por lo
tanto deben ser implementados por cualquier objeto que pretenda
hacerse pasar por un método compilado.  (\ct{flushcache} es el método
más importante que se debe implementar; los otros pueden llegar a ser
necesarios pero eso depende de si el método se instala mediante
\clsmthind{Behavior}{addSelector:withMethod:} o directamente mediante
la utilización de \clsmthind{MethodDictionary}{at:put:}.)


%-------------------------------------------------------------------------
\subsection{Cómo usar los objetos disfrazados para hacer  test coverage}

% -------- FIXME: seguir desde aca -------------------------------

Method wrappers are a well-known technique for intercepting messages \cite{Bran98a}.
In the original implementation\footnote{http://www.squeaksource.com/MethodWrappers.html}, a method wrapper is an instance of a subclass of \ct{CompiledMethod}. When installed, a method wrapper can perform special actions before or after invoking the original method.
When uninstalled, the original method is returned to its rightful position in the method dictionary.

In Pharo, \ind{method wrappers} can be implemented more easily by implementing \ct{run:with:in:} instead of by subclassing \ct{CompiledMethod}. In fact, there exists a lightweight implementation of objects as method wrappers\footnote{http://www.squeaksource.com/ObjectsAsMethodsWrap.html}, but it is not part of standard Pharo at the time of this writing.

Nevertheless, the Pharo Test Runner uses precisely this technique to evaluate test coverage.
Let's have a quick look at how it works.

The entry point for test coverage is the method \clsmthind{TestRunner}{runCoverage}:
\begin{code}{}
TestRunner>>>runCoverage
        | packages methods |
        ... "identify methods to check for coverage"
        self collectCoverageFor: methods
\end{code}

The method \clsmthind{TestRunner}{collectCoverageFor:} clearly illustrates the coverage checking algorithm:
\begin{code}{}
TestRunner>>>collectCoverageFor: methods
        | wrappers suite |
        wrappers := methods collect: [ :each | TestCoverage on: each ].
        suite := self
                reset;
                suiteAll.
        [ wrappers do: [ :each | each install ].
          [ self runSuite: suite ] ensure: [ wrappers do: [ :each | each uninstall ] ] ] valueUnpreemptively.
        wrappers := wrappers reject: [ :each | each hasRun ].
        wrappers isEmpty
                ifTrue:
                        [ UIManager default inform: 'Congratulations. Your tests cover all code under analysis.' ]
                ifFalse: ...
\end{code}
A wrapper is created for each method to be checked, and each wrapper is installed.
The tests are run, and all wrappers are uninstalled.
Finally the user obtains feedback concerning the methods that have not been covered.

How does the wrapper itself work?
The \ct{TestCoverage} wrapper has three instance variables, \ct{hasRun}, \ct{reference} and \ct{method}.
They are initialized as follows:
\begin{code}{}
TestCoverage class>>>on: aMethodReference
        ^ self new initializeOn: aMethodReference

TestCoverage>>>initializeOn: aMethodReference
        hasRun := false.
        reference := aMethodReference.
        method := reference compiledMethod
\end{code}

The install and uninstall methods simply update the method dictionary in the obvious way:
\begin{code}{}
TestCoverage>>>install
        reference actualClass methodDictionary
                at: reference methodSymbol
                put: self

TestCoverage>>>uninstall
        reference actualClass methodDictionary
                at: reference methodSymbol
                put: method
\end{code}
\noindent
and the \ct{run:with:in:} method simply updates the \ct{hasRun} variable, uninstalls the wrapper (since coverage has been verified), and resends the message to the original method
\begin{code}{}
run: aSelector with: anArray in: aReceiver
        self mark; uninstall.
        ^ aReceiver withArgs: anArray executeMethod: method

mark
        hasRun := true
\end{code}
(Have a look at \clsmthind{ProtoObject}{withArgs:executeMethod:} to see how a method displaced from its method dictionary can be invoked.)

That's all there is to it!

Method wrappers can be used to perform any kind of suitable behaviour before or after the normal operation of a method.  Typical applications are instrumentation (collecting statistics about the calling patterns of methods), checking optional pre- and post-conditions, and memoization (optionally cacheing computed values of methods).

%======================================
\section{Pragmas}

A \emphind{pragma} is an annotation that specifies data about a program, but is not involved in the execution of the program. Pragmas have no direct effect on the operation of the method they annotate.
Pragmas have a number of uses, among them:
\begin{itemize}
\item Information for the compiler: \indmain{pragmas} can be used by the compiler to make a method call a primitive function. This function has to be defined by the virtual machine or by an external plugging.
\item Runtime processing: Some pragmas are available to be examined at runtime.
\end{itemize}

Pragmas can be applied to a program's method declarations only. A method may declare one or more pragmas, and the pragmas have to be declared prior any Smalltalk statement. Each pragma is in effect a static message send with literal arguments.

We briefly saw pragmas when we introduced primitives earlier in this chapter. A primitive is nothing more than a pragma declaration.
Consider \ct{<primitive: 73>} as contained in \ct{instVarAt:}. The pragma's selector is \ct{primitive:} and its arguments is an immediate literal value, \ct{73}.

The compiler is probably the bigger user of pragmas. SUnit is another tool that makes use of annotations. SUnit is able to estimate the coverage of an application from a test unit. One may want to exclude some methods from the coverage. This is the case of the \ct!documentation! method in \ct!SplitJointTest class!:

\begin{code}{}
SplitJointTest class>>>documentation
        <ignoreForCoverage>
        "self showDocumentation"

        ^ 'This package provides function.... "
\end{code}

By simply annotating a method with the pragma \ct!<ignoreForCoverage>! one can control the scope of the coverage.

%Beside the compiler, Lint is a heavy user of pragmas. Lint is a static code analyzer that flags suspicious, non-portable constructs and code that is likely to contain bugs. It may happen that a method needs to be excluded from Lint analysis. This is the case here:

%\begin{code}{}
%MorphObjectOut>>>doesNotUnderstand: aMessage
%       "Bring in the object, install, then resend aMessage"
%       "Transcript show: thisContext sender selector; cr."
%       "useful for debugging"
%
%       ! \textbf{<lint: 'Unnecessary "= true"' rationale: 'recursionFlag may be nil' author: 'stephane.ducasse'>}!
%       ...
%\end{code}

%One of the pragmas used by Lint to filter out methods is \ct{lint:rationale:author:}.

As instances of the class \clsind{Pragma}, pragmas are first class objects. A compiled method answers to the message \mthind{CompiledMethod}{pragmas}. This method returns an array of pragmas.

\begin{code}{@TEST}
(SplitJoinTest class >> #showDocumentation) pragmas
  --> an Array(<ignoreForCoverage>)
(Float>>#+) pragmas --> an Array(<primitive: 41>)
\end{code}

Methods defining a particular query may be retrieved from a class. The class side of \ct!SplitJoinTest! contains some methods annotated with \ct!<ignoreForCoverage>!:

\begin{code}{@TEST}
Pragma allNamed: #ignoreForCoverage in: SplitJoinTest class  --> an Array(<ignoreForCoverage> <ignoreForCoverage> <ignoreForCoverage>)
\end{code}

A variant of \ct{allNamed:in:} may be found on the class side of \ct{Pragma}.

A pragma knows in which method it is defined (using \ct{method}), the name of the method (\ct{selector}), the class that contains the method (\ct{methodClass}), its number of arguments (\ct{numArgs}), about the literals the pragma has for arguments (\ct{hasLiteral:} and \ct{hasLiteralSuchThat:}).

\lr{Typically pragmas are performed on an interpreter object that understands the pragma message.}

%======================================
\section{Chapter summary}

Reflection refers to the ability to query, examine and even modify the metaobjects of the run-time system as ordinary objects.

\begin{itemize}
\item The Inspector uses \ct{instVarAt:} and related methods to query and modify ``private'' instance variables of objects.
\item Send \ct{Behavior>>>allInstances} to query instances of a class.
\item The messages \ct{class}, \ct{isKindOf:}, \ct{respondsTo:} \etc  are useful for gathering metrics or building development tools, but they should be avoided in regular applications: they violate the encapsulation of objects and make your code harder to understand and maintain.
\item \ct{SystemNavigation} is a utility class holding many useful queries for navigation and browsing the \ct class hierarchy. For example, use \ct{SystemNavigation default browseMethodsWithSourceString: 'pharo'.} to find and browse all methods with a given source string. (Slow, but thorough!)
\item Every \st class points to an instance of \ct{MethodDictionary} which maps selectors to instances of \ct{CompiledMethod}. A compiled method knows its class, closing the loop.
\item \ct{MethodReference} is a leightweight proxy for a compiled method, providing additional convenience methods, and used by many \st tools.
\item \ct{BrowserEnvironment}, part of the Refactoring Browser infrastructure, offers a more refined interface than \ct{SystemNavigation} for querying the system, since the result of a query can be used as a the scope of a new query. Both GUI and programmatic interfaces are available.
\item \ct{thisContext} is a pseudo-variable that reifies the run-time stack of the virtual machine. It is mainly used by the debugger to dynamically construct an interactive view of the stack. It is also especially useful for dynamically determining the sender of a message.
\item Intelligent breakpoints can be set using \ct{haltIf:}, taking a method selector as its argument. \ct{haltIf:} halts only if the named method occurs as a sender in the run-time stack.
\item A common way to intercept messages sent to a given target is to use a ``minimal object'' as a proxy for that target. The proxy implements as few methods as possible, and traps all message sends by implementing \ct{doesNotunderstand:}. It can then perform some additional action and then forward the message to the original target.
\item Send \ct{become:} to swap the references of two objects, such as a proxy and its target.
\item Beware, some messages, like \ct{class} and \ct{yourself} are never really sent, but are interpreted by the VM.  Others, like \ct{+}, \ct{-} and \ct{ifTrue:} may be directly interpreted or inlined by the VM depending on the receiver.
\item Another typical use for overriding \ct{doesNotUnderstand:} is to lazily load or compile missing methods.
\item \ct{doesNotUnderstand:} cannot trap \self-sends.
\item A more rigorous way to intercept messages is to use an object as a method wrapper. Such an object is installed in a method dictionary in place of a compiled method. It should implement \ct{run:with:in:} which is sent by the VM when it detects an ordinary object instead of a compiled method in the method dictionary. This technique is used by the SUnit Test Runner to collect coverage data.
\end{itemize}

%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=========================================================

%Other stuff:
%- anonymous classes (uses compile: and primitiveChangeClassTo:) ???
%- collect direct senders; class collaborations
%- Object primitiveChangeClassTo: become: and becomeForward: (see tests and slides with minimal object example)
%- PointerFinder?
%- anonymous classes (see slides) ?

%Test  Coverage using ObjectsAsMethodsWrap package:
%\begin{code}{}
%category := 'SCGPier'.
%w := (ObjectAsOneTimeMethodWrapper installOnClassCategory: category).
%tr := TestRunner new.
%ToolBuilder open: tr.
%[tr
%       categoryAt: (tr categoryList indexOf: 'SCGPier') put: true;
%       selectAllClasses;
%       runAll.]
%ensure: [[w do: [:each| each uninstall ]] valueUnpreemptively].
%((w select: [:each | each executed not ])
%       collect: [:each | each wrappedClass name, '>>', each selector name ]) explore.
%\end{code}


%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: "../PBE1.tex"
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "castellano8"
%%% End:
