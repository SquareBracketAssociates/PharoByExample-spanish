% $Author$
% $Date$
% $Revision$
% $Id$

% HISTORY:
% 2006-10-24 - Stef started
% 2006-12-01 - Oscar edit
% 2006-12-02 - Andrew edit
% 2007-05-04 - Oscar first draft
% 2007-07-04 - Stef review
% 2009-12-18 - Rafa starts spanish translation

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
%	\renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
\chapter{Sintaxis en dos palabras}
\luq{¿Qué tal 'Sintaxis en resumen' o 'Sintaxis en pocas palabras'?}
\chalabel{syntax}

\pharo, como la mayoría de los dialectos de \st modernos, adopta una sintaxis muy similar a la de \st-80.
La \ind{sintaxis} está diseñada para que el texto del programa pueda leerse como una especie de inglés macarrónico: \luq{¿o mejor lengua franca del inglés?}

\begin{code}{}
(Smalltalk includes: Class) ifTrue: [ Transcript show: Class superclass ]
\end{code}

\noindent
La sintaxis de \pharo es mínima.
Esencialmente, sólo hay sintaxis para el \emph{envío de mensajes} (es decir, expresiones).
Las expresiones se construyen a partir de un número muy pequeño de elementos primitivos.
Hay sólo 6 palabras clave y no existe sintaxis para las estructuras de control o la declaración de nuevas clases.
En su lugar, casi todo se consigue enviando mensajes a objetos.
Por ejemplo, en lugar de una estructura de control if-then-else, \st envía mensajes como \ct{ifTrue:} a objetos \clsind{Boolean}.
Las nuevas (sub)clases se crean enviando un mensaje a sus superclases.

%=================================================================
\section{Elementos sintácticos}

Las expresiones se componen de las siguientes piezas:
(i) seis palabras reservas o \emph{pseudo-variables}: 
\pvind{self}, \pvind{super}, \pvind{nil}, \pvind{true}, \pvind{false} y \pvind{thisContext}; 
(ii) expresiones constantes para \emphind{objetos literales}
incluyendo números, caracteres, cadenas de caracteres, símbolos y \emph{arrays}\luq{¿traduccimos array?};
(iii) declaraciones de variables; 
(iv) asignaciones; 
(v) \ind{bloques} closures \luq{¿traducción?} y
(vi) mensajes.

\seeindex{pseudo-variable}{variable, pseudo}

\begin{table}\centering
	\begin{tabular}{ll}
		\toprule
		Sintaxis & Lo que representa \\
		\midrule
		\lct{puntoInicial}			&	un nombre de variable\\
		\lct{Transcript}			&	un nombre de variable global\\
		\lct{self}				&	una pseudo-variable \\
		\midrule
		\lct{1}				 	&	entero decimal \\
		\lct{2r101}				&	entero binario \\
		\lct{1.5}					&	número en coma flotante \\
        \luq{Usamos coma flotante o punto flotante?} \\
		\lct{2.4e7}				&	notación exponencial \\
		\lct{\$a}					&	el carácter `a' \\
		\lct{'Hola'}				&	la cadena de caracteres ``Hola'' \\
		\lct{\#Hola}				&	el símbolo \lct{\#Hola} \\
		\lct{\#(1 2 3)}			& un array literal \\
		\lct{\{1. 2. 1+2\}}		& un array dinámico \\
		\midrule
		\lct{"un comentario"} 		&	un comentario \\
		\midrule
		\lct{| x y |}				&	declaración de las variables \lct{x} e \lct{y}	\\
		\lct{x := 1}				&	asignar 1 a \lct{x} \\
		\lct{[ x + y ]}			&	un bloque que se evalúa como \lct{x+y} \\
		\lct{<primitive: 1>}		&	primitiva o anotación de la máquina virtual\\
		\midrule
		\lct{3 factorial}			&	mensaje unario \\
		\lct{3+4}					&	mensaje binario \\
		\lct{2 raisedTo: 6 modulo: 10}		&	mensaje de palabra clave \\
		\midrule
		\lct{$\uparrow$ true} 			&	devuelve el valor true	\\
		\lct{Transcript show: 'hola'. Transcript cr }		&	separator de expresiones (\lct{.})	\\
		\lct{Transcript show: 'hola'; cr}					&	mensaje en cascada (\lct{;}) \\
		\bottomrule
	\end{tabular}
	\caption{Sintaxis de \pharo en dos palabras\tablabel{syntax}}
\end{table}

Podemos ver ejemplos de los distintos elementos sintácticos en la \tabref{syntax}.
\begin{description}
\item[Variables locales] \ct{puntoInicial} es un nombre de variable, o identificador.
  Por convenio, los identificadores están formados por palabras en ``\ind{camelCase}'' (es decir, cada palabra excepto la primera comienza con una letra mayúscula).
  La primera letra de una variable de instancia, método, argumento de un bloque o variable temporal debe ser minúscula.
  Esto indica al lector que la variable tiene un alcance privado.

\item[Variables compartidas] Los identificadores que comienzan con letras mayúsculas son variables \subind{variable}{globales}, variables \subind{variable}{de clase}, diccionarios comunes (\subind{variable}{pool} dictionaries) o nombres de clase.
\luq{pool dictionaries?}
		\ct{Transcript} es una variable global, una instancia de la clase \ct{TranscriptStream}.
		\seeindex{variable global}{variable, global}
		\seeindex{diccionario común}{variable, pool}
		\seeindex{variable!de clase}{clase, variable}

\item[El receptor] \pvind{self} es una palabra clave que se refiere al objeto en el que el método actual se está ejecutando. Lo llamamos ``el receptor'' porque normalmente este objeto habrá recibido el mensaje que causó que el método se ejecutara.
		Decimos que \self es una ``\subind{variable}{pseudo}-variable'' ya que no podemos asignarla.

\item[Enteros] Además de los enteros decimales normales como \ct{42}, \pharo también proporciona una \ind{notación científica}.
	\ct{2r101} es \ct{101} en base 2 (es decir, binario), que es igual al número decimal 5.
	\index{literal}
	\index{literal!número}

\item[Números en coma flotante] Pueden especificarse en potencias de base diez: \mbox{\ct{2.4e7}} es $2.4\times 10^7$.
	\index{número en coma flotante}

\item[Caracteres] Un signo dólar introduce un \subind{literal}{carácter} literal: \ct{$a}\ignoredollar$ es el literal para `a'.
  Pueden obtenerse instancias de caracteres no imprimibles enviando los mensajes adecuados a la clase \clsind{Character}, como \ct{Character space}\cmindex{clase Character}{space} y \ct{Character tab}\cmindex{clase Character}{tab}.
		
\item[Cadenas de caracteres] Las comillas simples se utilizan para definir una \subind{literal}cadena literal.
  Si quieres una cadena que contenga una comilla, simplemente se usan dos comillas, como en \ct{'entre ''comillas'' simples'}.
\luq{ejemplo en lugar de 'G''day' ?}

\item[Símbolos] se parecen a las cadenas en que contienen una secuencia de caracteres.
	Sin embargo, al contrario que en una cadena, se garantiza que un símbolo \subind{símbolo}{literal} es único globalmente.
	Sólo existe un objeto símbolo \ct{#Hola}, pero puede haber varios objetos String con el valor \ct{'Hola'}.
		\seeindex{\#@{\textsf{\#}}}{símbolo literal}

\item[Arrays en tiempo de compilación] Se definen mediante \ct{#( )} rodeando literales separados por espacios.
  Dentro de los paréntesis todo debe ser constante en tiempo de compilación.
  Por ejemplo, \ct{#(27 (true false) abc)} es un \subind{literal}{array} \subind{array}{literal} de tres elementos: el entero \ct{27}, el array en tiempo de compilación conteniendo los dos booleanos y el símbolo \ct{#abc} (observa que esto es lo mismo que \ct{#(27 #(true false) #abc)}).

\item[Arrays en tiempo de ejecución] Las llaves \ct|{ }| definen un array (\subind{Array}{dinámico}) en tiempo de ejecución.
  Sus elementos son expresiones separadas por puntos.
  Por lo tanto, \ct|{ 1. 2. 1+2 }| define un array con los elementos 1, 2 y el resultado de evaluar 1+2
  (la notación de llaves es específica de los dialectos de \st \pharo y \squeak. En otros \st{}s tienes que construir explícitamente los arrays dinámicos).

\item[Comentarios] Se encierran entre comillas dobles.
		\ct{"Hola"} es un \ind{comentario}, no una cadena de caracteres, y es ignorado por el compilador de \pharo.
		Los comentarios pueden ocupar varias líneas.

\item[Definiciones de variables locales] Las barras verticales \ct{| |} encierran la \subind{variable}{declaración} de una o más variables locales en un método (y también en un bloque).
		\seeindex{declaración}{declaración de variable}

\item[Asignación] \ct{:=} asigna un objeto a una variable.
%		Sometimes you will see $\leftarrow$ used instead.
%		Unfortunately, since this is not an \textsc{ascii} character, it will appear as an underscore unless
%		you are using a special font.
%		So, \ct{x := 1} is the same as \ct{x _ 1} or \ct{x UNDERSCORE 1}. You should use \ct{:=} since the other representations have been deprecated.
		\index{asignación}
		\seeindex{:=@{\textsf{:=}}}{asignación}
		\seeindex{\_@{\textsf{\_}}}{asignación}
		\seeindex{<-@{$\leftarrow$}}{asignación}

\item[Bloques] Los corchetes \ct{[ ]} definen un \ind{bloque}, conocido también como clausura de bloque o clausura léxica, que es un objeto de primer orden representando una función. Como veremos, los bloques pueden tener argumentos y variables locales.
	\seeindex{[ ]@{\textsf{[ ]}}}{bloque}
	\seeindex{clausura}{bloque}
	\seeindex{clausura léxica}{bloque}

\item[Primitivas] \ct{<primitive: ...>} indica la invocación de una \ind{primitiva} de \ind{máquina virtual.}
	(\ct{<primitive: 1>} es la primitiva de máquina virtual para \ct{SmallInteger>>>+}).
	Cualquier código que siga a la primitiva es ejecutado sólo si la primitiva falla.
	La misma sintaxis se utiliza también para las anotaciones de los métodos.

\item[Mensajes unarios] consisten en una sola palabra (como \ct{factorial}) enviada a un receptor (como \ct{3}).
	\index{mensaje!unario}
	\seeindex{mensaje unario}{mensaje, unario}

\item[Mensajes binarios] son operadores (como \ct{+}) enviados a un receptor y que tienen un único argumento. En \ct{3+4}, el receptor es \ct{3} y el argumento es \ct{4}.
	\index{mensaje!binario}
	\seeindex{mensaje binario}{mensaje, binario}

\item[Mensajes de palabra clave] consisten en varias palabras clave (como \ct{raisedTo:modulo:}), acabando cada una con dos puntos y recibiendo un único argumento.
En la expresión \ct{2 raisedTo: 6 modulo: 10}, el \emphind{selector del mensaje} \ct{raisedTo:modulo:} recibe los dos argumentos \ct{6} y \ct{10}, cada uno siguiente los dos puntos. Enviamos el mensaje al receptor \ct{2}.
	\index{mensaje!palabra clave}
	\seeindex{mensaje de palabra clave}{mensaje, palabra clave}

\item[Retorno de método] \ct{^} se usa para \emphind{retornar} un valor desde un método (debes escribir \verb|^| para obtener el caracter \ct{^}).

\item[Secuencias de sentencias]	Un punto (\ct{.}) es el \emphsubind{sentencia}{separador} de \emph{sentencias}. Poner un punto entre dos expresiones las convierte en sentencias independientes.
	\seeindex{punto}{separador de sentencia}
	\seeindex{\ct{.}}{separador de sentencia}

\item[Cascadas] Los puntos y coma pueden usarse para enviar una \emphind{cascada} de mensajes a un único receptor.  En \ct{Transcript show: 'hola'; cr} primero enviamos el mensaje de palabra clave \ct{show: 'hola'} al receptor \ct{Transcript} y entonces enviamos el mensaje unario \ct{cr} al mismo receptor.
	\seeindex{;}{cascada}

\end{description}

Las clases \ct{Number}, \ct{Character}, \ct{String} y \ct{Boolean} se describen con más detalle en \charef{basic}.

%=================================================================
\section{Pseudo-variables}

En \st existen 6 palabras reservadas or \emph{pseudo-variables}:
\pvind{nil}, \pvind{true},  \pvind{false},  \pvind{self}, \pvind{super} y \pvind{thisContext}.
Se llaman  \subind{variable}{pseudo}-variables porque están predefinidas y no pueden ser asignadas.
\ct{true}, \ct{false} y \ct{nil} son constantes, mientras que los valores de \ct{self}, \ct{super} y \ct{thisContext} varían dinámicamente cuando el código es ejecutado.

\ct{true} y \ct{false} son las únicas instancias de las clases \clsind{Boolean} \clsind{True} y \clsind{False}.
Véase \charef{basic} para más detalles.

\pvind{self} siempre se refiere al receptor del método ejecutándose actualmente.

\ct{super} también se refiere al receptor del mensaje actual, pero cuando envías un mensaje a \super, la búsqueda del método cambia de modo que comienza desde la superclase de la clase que contiene el método que usa \ct{super}.
Para más detalles véase \charef{model}.

\ct{nil} es el objeto indefinido.
Es la única instancia de la clase \clsind{UndefinedObject}. 
Las variables de instancia, variables de clase y variables locales se inicializan a \ct{nil}.

\ct{thisContext} es una pseudo-variable que representa el marco superior de la pila de ejecución.
En otras palabras, representa el \clsind{MethodContext} o \clsind{BlockClosure} actualmente ejecutando.
Normalmente \ct{thisContext} no es de interés para la mayoría de programadores, pero es imprescindible para implementar herramientas de desarrollo como el depurador y también se utiliza para implementar el manejo de excepciones y las continuaciones.

%=================================================================
\section{Envíos de mensajes}

Existen tres tipos de mensajes en \pharo.
\begin{enumerate}
  \item \emph{Unarios} mensajes que no reciben ningún argumento.
  \ct{1 factorial} envía el mensaje \ct{factorial} al objeto \ct{1}.
  \item \emph{Binarios} mensajes que reciben exactamente un argumento.
  	\ct{1 + 2} envía el mensaje \ct{+} con el argumento \ct{2} al objeto \ct{1}.
  \item \emph{De palabra clave} mensajes que reciben un número arbitrario de argumentos.
  	\ct{2 raisedTo: 6 modulo: 10} envía el mensaje que consiste en el selector del mensaje
	\ct{raisedTo:modulo:} y los argumentos \ct{6} y \ct{10} al objeto \ct{2}.
\end{enumerate}





Unary message selectors consist of alphanumeric characters, and start with a lower case letter.
\index{message!unary}

Binary message selectors consist of one or more characters from the following set:
\index{message!binary}
\begin{code}{}
+ - / \ * ~ < > = @ % | & ! ? ,
\end{code}
\noindent
% [\~\!\@\%\&\*\-\+\=\\\|\?\/\>\<\,]
\on{It seems that 3 or more chars work fine, but it is not possible to have more than one ``-'' in a binary selector. Perhaps due to a conflict with parsing negative numbers?}
\ab{That's right; $-$ is weird.}
Keyword message selectors consist of a series of alphanumeric keywords, where each keyword starts with a lower-case letter and ends with a colon.
\index{message!keyword}

Unary messages have the highest precedence, then binary messages, and finally keyword messages, so:
\begin{code}{@TEST}
2 raisedTo: 1 + 3 factorial --> 128
\end{code}
(First we send \ct{factorial} to \ct{3}, then we send \ct{+ 6} to \ct{1}, and finally we send \ct{raisedTo: 7} to \ct{2}.)  
Recall that we use the notation \lct{\emph{expression}}\ct{-->}\lct{\emph{result}} to show the result of evaluating an expression.

Precedence aside, evaluation is strictly from left to right, so
\begin{code}{@TEST}
1 + 2 * 3 --> 9
\end{code}
not \ct{7}.
Parentheses must be used to alter the order of evaluation:
\begin{code}{@TEST}
1 + (2 * 3) --> 7
\end{code}

Message sends may be composed with periods and semi-colons. A period-separated sequence of expressions causes each expression in the series to be evaluated as a \emphind{statement}, one after the other.
\index{statement!separator}

\begin{code}{}
Transcript cr.
Transcript show: 'hello world'.
Transcript cr
\end{code}

\noindent
This will send \ct{cr} to the \glbind{Transcript} object, then send it \ct{show: 'hello world'}, and finally send it another \ct{cr}.

When a series of messages is being sent to the \emph{same} receiver, then this can be expressed more succinctly as a \emphind{cascade}.
The receiver is specified just once, and the sequence of messages is separated by semi-colons:

\begin{code}{}
Transcript cr;
    show: 'hello world';
    cr
\end{code}
This has precisely the same effect as the previous example.

%=================================================================
\section{Method syntax}

Whereas expressions may be evaluated anywhere in \pharo (for example, in a workspace, in a debugger, or in a browser), methods are normally defined in a browser window, or in the debugger.
(Methods can also be filed in from an external medium, but this is not the usual way to program in \pharo.)

Programs are developed one method at a time, in the context of a given class.
(A class is defined by sending a message to an existing class, asking it to create a subclass, so there is no special syntax required for defining classes.)

Here is the method \mthind{String}{lineCount} in the class \clsind{String}.
(The usual convention is to refer to methods as \ct{ClassName>>>methodName}, so we call this method \ct{String>>>lineCount}.)

\needlines{9}
\begin{method}[lineCount]{Line count}
String>>>lineCount
   "Answer the number of lines represented by the receiver,
   where every cr adds one line."
   | cr count |
   cr := Character cr.
   count := 1 min: self size.
   self do:
      [:c | c == cr ifTrue: [count := count + 1]].
   ^ count
\end{method}

Syntactically, a method consists of:
\begin{enumerate}
  \item the method pattern, containing the name (\ie \ct{lineCount}) and any arguments (none in this example);
  \item comments (these may occur anywhere, but the convention is to put one at the top that explains what the method does);
  \item declarations of local variables (\ie \ct{cr} and \ct{count}); and
  \item any number of expressions separated by dots; here there are four.
\end{enumerate}

The evaluation of any expression preceded by a \ct{^} (typed as \verb|^|) will cause the method to exit at that point, returning the value of that expression.
A method that terminates without explicitly returning some expression will implicitly \ind{return} \pvind{self}.
\index{return!implicit}

Arguments and local variables should always start with lower case letters.
Names starting with upper-case letters are assumed to be global variables.
Class names, like \ct{Character}, for example, are simply global variables referring to the object representing that class.

%=================================================================
\section{Block syntax}

Blocks provide a mechanism to defer the evaluation of expressions.
A \ind{block} is essentially an anonymous function. A block is evaluated by sending it the message \mthind{BlockClosure}{value}.
The block answers the value of the last expression in its body, unless there is an explicit return (with \ct{^}), in which case it does not answer any value.
\seeindex{value}{BlockClosure}

\begin{code}{@TEST}
[ 1 + 2 ] value --> 3
\end{code}

Blocks may take parameters, each of which is declared with a leading colon.
A  vertical bar separates the parameter declaration(s) from the body of the block.
To evaluate a block with one parameter, you must send it the message \mthind{BlockClosure}{value:} with one argument.
A two-parameter block must be sent \mthind{BlockClosure}{value:value:}, and so on, up to 4 arguments.

\begin{code}{@TEST}
[ :x | 1 + x ] value: 2 --> 3
[ :x :y | x + y ] value: 1 value: 2 --> 3
\end{code}

If you have a block with more than four parameters, you must use \mthind{BlockClosure}{valueWithArguments:} and pass the arguments in an array.
(A block with a large number of parameters is often a sign of a design problem.)

Blocks may also declare local variables, which are surrounded by vertical bars, just like local variable declarations in a method.
Locals are declared after any arguments:
\index{variable!declaration}

\begin{code}{@TEST}
[ :x :y | | z | z := x+ y. z ] value: 1 value: 2 --> 3
\end{code}

Blocks are actually lexical \emph{closures}, since they can refer to variables of the surrounding environment.
The following block refers to the variable \ct{x} of its enclosing environment:

\begin{code}{@TEST}
| x |
x := 1.
[ :y | x + y ] value: 2 --> 3
\end{code}

Blocks are instances of the class \clsind{BlockClosure}.
This means that they are objects, so they can be assigned to variables and passed as arguments just like any other object.
% For both understandability and performance, it is better for blocks to refer only to their parameters and local variables; blocks that do not refer external variables are optimized by the compiler.
% MARCUS sez: I would just delete the sentence. There is nothing optimized, accessign outer temps is as fast as inner, so the only reason to avoid accessing outer temps would be that the code is easier to understand. But that's a relatively weak argument, I think.
% However, the ability to refer (``capture'') non-local variables can be very powerful when it is needed. 

%\paragraph{Really important.} \^\ acts as an escaping mechanism. 
%Return expressions inside a nested block expression will terminate the enclosing method.
%In the example 

%\begin{script}[detect]{...} when the expression \ct{^\ x@y} is executed, the method \ct{detect:}
% escapes the current iteration and returns it. 

%TwoLevelSet>>detect: aBlock

%   firstLevel keysAndValuesDo: [ :x :v |
%      v do: [ :y | (aBlock value: x@y) ifTrue: [^x@y]]
%   ].
%   ^nil
%\end{script}


%=================================================================
\section{Conditionals and loops in a nutshell}

\st offers no special syntax for control constructs.
Instead, these are typically expressed by sending messages to booleans, numbers and collections, with blocks as arguments.

Conditionals are expressed by sending one of the messages \mthind{Boolean}{ifTrue:}, \mthind{Boolean}{ifFalse:} or \mthind{Boolean}{ifTrue:ifFalse:} to the result of a boolean expression. See \charef{basic} for more about booleans.

\begin{code}{}
(17 * 13 > 220)
   ifTrue: [ 'bigger' ]
   ifFalse: [ 'smaller' ] --> 'bigger'
\end{code}
% ON: Not a test.
% My regex approach cannot handle multi-line expressions :-(

Loops are typically expressed by sending messages to blocks, integers or collections.
Since the exit condition for a loop may be repeatedly evaluated, it should be a block rather than a boolean value.
Here is an example of a very procedural loop:
\index{iteration}
\index{iteration|seealso{Collection, iteration}}
\seeindex{loops}{iteration}
\seeindex{enumeration}{iteration}
\seeindex{control constructs}{iteration}

\begin{code}{@TEST | n |}
n := 1.
[ n < 1000 ] whileTrue: [ n := n*2 ].
n --> 1024
\end{code}
\cmindex{BlockClosure}{whileTrue:}

\noindent
\mthind{BlockClosure}{whileFalse:} reverses the exit condition.
\begin{code}{@TEST | n |}
n := 1.
[ n > 1000 ] whileFalse: [ n := n*2 ].
n --> 1024
\end{code}

\noindent
\mthind{Integer}{timesRepeat:} offers a simple way to implement a fixed iteration:

\begin{code}{@TEST | n |}
n := 1.
10 timesRepeat: [ n := n*2 ].
n --> 1024
\end{code}

We can also send the message \mthind{Number}{to:do:} to a number which then acts as the initial value of a loop counter.
The two arguments are the upper bound, and a block that takes the current value of the loop counter as its argument:

\needlines{4}
\begin{code}{@TEST | result |}
result := String new.
1 to: 10 do: [:n | result := result, n printString, ' '].
result --> '1 2 3 4 5 6 7 8 9 10 '
\end{code}

\damien{I think the previous example that I've just added is clearer than the one which is commented here.}
% \begin{code}{@TEST | n |}
% n := 0.
% 1 to: 10 do: [ :counter | n := n + counter ].
% n --> 55
% \end{code}

\paragraph{High-Order Iterators.}
Collections comprise a large number of different classes, many of which support the same protocol.
The most important messages for iterating over collections include
\mthind{Collection}{do:}, \mthind{Collection}{collect:}, \mthind{Collection}{select:}, \mthind{Collection}{reject:}, \mthind{Collection}{detect:} and \mthind{Collection}{inject:into:}.
These messages define high-level iterators that allow one to write very compact code.

An \clsind{Interval} is a collection that lets one iterate over a sequence of numbers from the starting point to the end.
\ct{1 to: 10} represents the interval from 1 to 10.
Since it is a collection, we can send the message \ct{do:} to it.
The argument is a block that is evaluated for each element of the collection.

\begin{code}{@TEST | result |}
result := String new.
(1 to: 10) do: [:n | result := result, n printString, ' '].
result --> '1 2 3 4 5 6 7 8 9 10 '
\end{code}

\damien{Again, I think the previous example is clearer than the one which is commented here.}
% \begin{code}{@TEST | n |}
% n := 0.
% (1 to: 10) do: [ :element | n := n + element ].
% n --> 55
% \end{code}

\ct{collect:} builds a new collection of the same size, transforming each element.
\begin{code}{@TEST}
(1 to: 10) collect: [ :each | each * each ] --> #(1 4 9 16 25 36 49 64 81 100)
\end{code}

\ct{select:} and \ct{reject:} build new collections, each containing a subset of the elements satisfying (or not) the boolean block condition.
\ct{detect:} returns the first element satisfying the condition.
Don't forget that strings are also collections, so you can iterate over all the characters.

\begin{code}{@TEST}
'hello there' select: [ :char | char isVowel ] --> 'eoee'
'hello there' reject: [ :char | char isVowel ] --> 'hll thr'
'hello there' detect: [ :char | char isVowel ] --> $e
\end{code}

Finally, you should be aware that collections also support a functional-style \emph{fold} operator in the \ct{inject:into:} method.
This lets you generate a cumulative result using an expression that starts with a seed value and injects each element of the collection.
Sums and products are typical examples.
\seeindex{fold}{\ct{Collection>>>inject:into}}

\begin{code}{@TEST}
(1 to: 10) inject: 0 into: [ :sum :each | sum + each ] --> 55
\end{code}

\noindent
This is equivalent to \ct{0+1+2+3+4+5+6+7+8+9+10}.

More about collections can be found in  \charef{collections}.

%=================================================================
\section{Primitives and pragmas}

In \st everything is an object, and everything happens by sending messages.
Nevertheless, at certain points we hit rock bottom.
Certain objects can only get work done by invoking \ind{virtual machine} \ind{primitive}{}s.

For example, the following are all implemented as primitives:
memory allocation (\mthind{Behavior}{new}, \mthind{Behavior}{new:}),
bit manipulation (\mthind{Integer}{bitAnd:}, \mthind{Integer}{bitOr:}, \mthind{Integer}{bitShift:}),
pointer and integer arithmetic (\ct{+}, \ct{-},  \ct{<},  \ct{>}, \ct{*}, \ct{/ }, \ct{=}, \ct{==}...),
and array access (\mthind{Object}{at:}, \mthind{Object}{at:put:}).
\seeindex{new@{\ct{new}}}{\ct{Behavior>>>new}}

Primitives are invoked with the syntax \ct{<primitive: aNumber>}.
A method that invokes such a primitive may also include \st code, which will be evaluated \emph{only} if the primitive fails.

Here we see the code for \cmind{SmallInteger}{+}.
If the primitive fails, the expression \ct{super + aNumber} will be evaluated and returned.

\needlines{6}
\begin{method}[primitive]{A primitive method}
+ aNumber 
  "Primitive. Add the receiver to the argument and answer with the result
  if it is a SmallInteger. Fail if the argument or the result is not a
  SmallInteger  Essential  No Lookup. See Object documentation whatIsAPrimitive."

  <primitive: 1>
  ^ super + aNumber
\end{method}

%The other use of primitives is to optimize some crucial methods. The idea is that the system could work 
%without the primitive but it would be slow. The following method shows that the method \ct{@} is calling the primitive 18. Here the point creation is clearly expressible in \st therefore the code after the primitive is just the creation of a point illustrating what the primitive is actually doing. Note that such a code will be never called except if the primitive would failed which is extremely rare.  

%\begin{method}[xxx]{xxx}
%Integer>>@ y 
%   "Primitive. Answer a Point whose x value is the receiver and whose y 
%   value is the argument. Optional. No Lookup. See Object documentation 
%   whatIsAPrimitive."

%   <primitive: 18>
%   ^Point x: self y: y
%\end{method}


In \pharo, the angle bracket syntax is also used for method annotations called pragmas.
\sd{we should give an example}\ab{Please do!  Is don't know about these.}\damien{it's the third time we talk about pragmas without saying what they are and how to use them.}

%=================================================================
\section{Chapter summary}

\begin{itemize}

\item	\pharo has (only) six reserved identifiers also called \textit{pseudo-variables}: \ct{true}, \ct{false}, \ct{nil}, \ct{self}, \ct{super},  and  \ct{thisContext}.

\item	There are five kinds of literal objects: numbers (\ct{5}, \ct{2.5}, \ct{1.9e15}, \ct{2r111}), characters (\ct{$a}), strings (\ct{'hello'}), symbols (\ct{#hello}), and arrays (\ct{#('hello' #hi)})

\item	Strings are delimited by single quotes, comments by double quotes.
		To get a quote inside a string, double it.

\item	Unlike strings, symbols are guaranteed to be globally unique.

\item	Use \ct{#( ... )} to define a literal array.
		Use \ct|{ ... }| to define a dynamic array.
		Note that 
		\ct{#( 1 + 2 ) size --> 3}, but 
		\ct|{ 1 + 2 } size --> 1|

\item	There are three kinds of messages:
		\emph{unary} (\eg \ct{1 asString}, \ct{Array new}),
		\emph{binary} (\eg \ct{3 + 4}, \ct{'hi' , ' there'}), and
		\emph{keyword} (\eg \ct{'hi' at: 2 put: $o})

\item	A \emph{cascaded} message send is a sequence of messages sent to the same target, separated by semi-colons:
\ct{OrderedCollection new add: #calvin; add: #hobbes; size --> 2}

\item	Local variables are declared with vertical bars.
		Use \ct{:=} for assignment.
		\ct{|x| x:=1}

\item	Expressions consist of message sends, cascades and assignments, possibly grouped with parentheses.
		\emph{Statements} are expressions separated by periods.

\item	Block closures are expressions enclosed in square brackets.
		Blocks may take arguments and can contain temporary variables.
		The expressions in the block are not evaluated until you send the block a 
		\ct{value...} message with the correct number of arguments.\\
		\ct{[:x | x + 2] value: 4 --> 6}.

\item	There is no dedicated syntax for control constructs, just messages that conditionally evaluate blocks.\\
		\ct{(\st includes: Class) ifTrue: [ Transcript show: Class superclass ]}

\end{itemize}

%=================================================================
\ifx\wholebook\relax\else
\end{document}\fi
%=================================================================
%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "spanish"
%%% End:
