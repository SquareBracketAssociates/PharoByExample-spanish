% $Author$
% $Date$
% $Revision$
% $Id$

% HISTORY:
% 2007-10-29 - Oscar started chapter
% 2007-11-30 - Oscar first draft
% 2007-12-07 - Orla Greevy reviewed
% 2007-12-09 - Lukas Renggli reviewed
% 2008-01-11 - Andrew revised
% 2009-04-17 - Fabrizio Perin reviewed
% 2009-04-18 - Jorge Ressia reviewed
% 2009-05-06 - Oscar converted to Pharo; fixed review comments
% 2011-05-29 - Rafael Luque translated to spanish
%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../co	mmon.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
\chapter{Seaside en Ejemplos}
\chalabel{seaside}

\luq{Otras opción posible para el título podría ser: 'Seaside con Ejemplos'}

%=================================================================

\ind{Seaside} es un marco de trabajo para crear aplicaciones web en Smalltalk. Fue desarrollado originalmente por Avi Bryant \index{Bryant, Avi} en 2002; una vez dominado, Seaside hace las aplicaciones web tan fáciles de escribir como las aplicaciones de escritorio.

Dos de las aplicaciones creadas con Seaside más conocidas son \ind{SqueakSource}\footnote{\url{http://SqueakSource.com}} y \ind{Dabble DB}\footnote{\url{http://DabbleDB.com}}.
Seaside es poco común ya que está rigurosamente orientado a objetos: no hay plantillas XHTML, ni complicados controles de flujo a través de páginas web, ni codificación del estado en las URLs. En su lugar, sólo envías mensajes a los objetos. ¡Qué buena idea!

\section{¿Por qué necesitamos Seaside?}

Las aplicaciones web modernas tratan de interactuar con el usuario de la misma manera que las aplicaciones de escritorio: realizan al usuario preguntas y el usuario responde, normalmente rellenando un formulario o pulsando un botón. Pero la web funciona en sentido inverso: el navegador del usuario realiza una petición al servidor y el servidor responde con una nueva página web.

Por lo tanto, los marcos de \ind{desarrollo de aplicaciones web} tienen que tratar con un montón de problemas, siendo el principal de ellos la gestión de este control de flujo ``invertido''.
Por esto, muchas aplicaciones intentan prohibir el uso del botón ``volver atrás'' del navegador, debido a la dificultad de mantener el seguimiento del estado de una sesión.
Expresar un control de flujo no trivial a través de varias páginas normalmente es engorroso y varios flujos de control pueden ser difíciles o imposibles de expresar.

% Seaside is a component-based framework that uses ``\ind{continuations}''\footnote{A \emph{continuation} represents ``the rest of the computation'' at any point in a computation. In Smalltalk, a continuation is just an object that captures the current state of the computation, and which can be resumed at any point.} to keep track of multiple points in the control flow of web applications. Continuations are managed automatically by Seaside, so web developers do not even have to be aware of the underlying machinery. It just works.

\index{Seaside!backtracking de estado}\luq{Traducimos backtracking como vuelta a atrás?}
\index{Seaside!transacciones}
\index{Seaside!componentes}

Seaside es un marco de trabajo basado en componentes que hace el desarrollo web más fácil en varias formas.
Primero, el control de flujo puede expresarse de forma natural usando el envío de mensajes. Seaside realiza el seguimiento de la página web que corresponde con cada punto de ejecución de la aplicación web.
Esto significa que el botón ``volver atrás'' del navegador funciona correctamente.  

Segundo, gestiona el estado en tu lugar.
Como el desarrollador, puedes escoger habilitar el seguimiento del estado, para que la navegación ``hacia atrás'' en el tiempo desahaga los efectos laterales.
Si no, puedes usar el soporte de transacciones incluído en Seaside para evitar que los usuarios deshagan los efectos laterales permanentes cuando usen el botón volver atrás.
No tienes que codificar la información de estado en la URL\,---\,esto también es gestionado automáticamente por ti

Tercero, las páginas web son construídas a partir de componentes anidados, cada uno de los cuales soporta su propio control de flujo independiente.
No hay plantillas XHTML\,---\,sino que se genera XHTML válido programadamente, usando un sencillo protocolo Smalltalk.
Seaside soporta Hojas de Estilo en Cascada (\ind{CSS}), de forma que el contenido y disposición estén claramente separados.
\seeindex{Hojas de Estilo en Cascada}{CSS}

Finalmente, Seaside proporciona una práctica interfaz de desarrollo basada en web, lo que hace fácil desarrollar aplicaciones iterativamente, depurar aplicaciones interactivamente  y recompilar y extender aplicaciones miembras el servidor está ejecutándose.

%=================================================================
\section{Para empezar}

La forma más sencilla de comenzar es descargar ``Seaside \subind{Seaside}{Experiencia en Un Click}'' desde el \subind{Seaside}{sitio web} de Seaside\footnote{\url{http://seaside.st}}.
Esta es una versión preempaquetada de Seaside 2.8 para \ind{Mac OSX}, \ind{Linux} y \ind{Windows}.
El mismo sitio web lista muchas referencias a recursos adicionales, incluyendo documentación y tutoriales.
Te advertimos, sin embargo, de que Seaside ha evolucionado considerablemente con los años y no todo el material disponible se refiere a la última versión de Seaside.


% If you are feeling more adventurous, an alternative to the ``one-click'' image is to start with the latest \ind{\pharo web image}\footnote{\url{http://pharo-project.org/download}}, and install Seaside yourself by following the manual \subind{Seaside}{installation} instructions on the Seaside web site.

Seaside incluye un servidor web; puedes iniciar el servidor, diciéndole que escuche en el puerto 8080, evaluando \clsind{WAKom} \ct{startOn: 8080},
y puedes detenerlo otra vez evaluando \ct{WAKom stop}.
En la instalación por defecto, el \subind{Seaside}{login de administrador} por defecto es \lct{admin} y la contraseña por defecto es \lct{seaside}.
Para cambiarlos, evalúa: \clsind{WADispatcherEditor} \ct{initialize}.
Esto te solicitará un nuevo nombre y contraseña.

\begin{figure}[tbh]
\begin{center}
\includegraphics[width=\textwidth]{seasideStartup}
\caption{Iniciando Seaside}
\figlabel{seasideStartup}
\end{center}
\end{figure}

\dothis{Inicia el servidor Seaside y dirige un navegador web a \url{http://localhost:8080/seaside/}.}

\noindent
Deberías ver una página web como la de la \figref{seasideStartup}.

\noindent
\dothis{Navega a la página \lct{examples{\go}counter} page. (\figref{counter})}

\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.8\textwidth]{counter}
\caption{El contador.}
\figlabel{counter}
\end{center}
\end{figure}

\noindent
Esta página es una pequeña aplicación Seaside: muestra un \subind{Seaside}{contador} que puede ser incrementado o decrementado haciendo click en los enlaces \link{++} y \link{--\,--}.

\noindent
\dothis{Juega con el contador haciendo click en estos enlaces.
Usa el botón ``atrás'' de tu navegador para volver a un estado previo y entonces haz cllick en \link{++} otra vez.
Fíjate cómo el contador se incrementa correctamente con respecto al estado mostrado en ese momento, en lugar del estado en que estaba cuando usaste el botón ``volver''.} 

Fíjate en la \subind{Seaside}{barra de herramientas} al final de la página web en la \figref{seasideStartup}.
Seaside soporta una noción de ``sesiones'' para realizar el seguimiento del estado de la aplicación para diferentes usuarios.
\button{New Session} comenzará una nueva sesión en la aplicación contador.
\button{Configure} permite configurar los ajustes de tu aplicación a través de una cómoda interfaz web.
(Para cerrar la vista \button{Configure}, pulsa en la \link{x} en la esquina superior derecha.)
\button{Toggle Halos} proporciona una forma de explorar el estado de la aplicación ejecutándose en el servidor Seaside.
\button{Profiler} y \button{Memory} proporcionan información detallada sobre el rendimiento de la aplicación en tiempo de ejecución.
\button{XHTML} puede usarse para validar la página web generada, pero sólo funciona cuando la página web es públicamente accesible en Internet porque usa el servicio de validación del W3C.
\index{Seaside!halos}

Las aplicaciones Seaside se construyen a partir de ``componentes'' conectables.
De hecho, los componentes son objetos normales de Smalltalk.
Lo único que tienen de especial es que deben ser instancias de clases que heredan de la clase \ct{WAComponent} del marco de trabajo Seaside.
Podemos explorar los componentes y sus clases desde la imagen \pharo o directamente desde la interfaz web usando los halos.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{counterHalos}
\caption{Halos}
\figlabel{counterHalos}
\end{center}
\end{figure}

\dothis{Selecciona \button{Toggle Halos}. Deberías ver una página web como la de la \figref{counterHalos}.
En la esquina superior izquierda el texto \ct{WACounter} indica la clase del componente Seaside que implementa el comportamiento de esta página web.
Junto a este, hay tres iconos que puedes pulsar.
El primero, con el lápiz, activa el navegador de clases de Seaside sobre esta clase.
El segundo, con la lupa, abre un inspector de objetos sobre la instancia \ct{WACounter} actualmente activa.
El tercero, con los circulos de color, muestra la hoja de estilos \ind{CSS} para este componente.
En la esquina superior derecha, la \link{R} y \link{S} te permiten conmutar entre las vistas renderizadas y fuente de la página web.
Experimenta con todos estos enlaces.
Ten en cuenta que los vínculos \link{++} y \link{--} también están activos en la vista fuente.
Compara la vista fuente correctamente formateada que proporciona los Halos con la vista fuente sin formato ofrecida por tu navegador.}

El navegador de clases y el inspector de objetos de Seaside pueden ser muy útiles cuando el servidor está ejecutándose en otro ordenador, especialmente cuando el servidor no tiene pantalla o está en un lugar remoto.
Sin embargo, cuando desarrollas una aplicación Seaside por vez primera, el servidor estará ejecutándose localmente y es fácil usar las herramientas de desarrollo normales de \pharo en la imagen del servidor.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.7\textwidth]{haltingCounter}
\caption{Deteniendo el contador}
\figlabel{haltingCounter}
\end{center}
\end{figure}

\dothis{Usando el enlace del inspector de objetos en el navegador web, abrir un inspector sobre el objeto contador de Smalltalk subyacente y evaluar \ct{self halt}.
La página web detendrá la carga.
Ahora cambia a la imagen de Seaside.
Deberías ver una ventana de pre-depurador (\figref{haltingCounter}) mostrando un objeto \ct{WACounter} ejecutando un \ct{halt}.
Examina la ejecución en el depurador y entonces \button{Proceed}.
Vuelve al navegador web y fíjate en que la aplicación contador está ejecutándose otra vez.}

Los componentes de Seaside pueden instanciarse varias veces y en diferentes contextos.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{multiCounterHalos}
\caption{Subcomponentes independientes}
\figlabel{multiCounterHalos}
\end{center}
\end{figure}

\dothis{Dirige tu navegador web a \url{http://localhost:8080/seaside/examples/multicounter}.
Verás una aplicación formada por un número de instancias independientes del componente contador.
Incrementa y decrementa varios de los contadores.
Verifica que se comportan correctamente incluso si usas el botón ``atrás''.
Activa los halos para ver cómo la aplicación está formada por componentes anidados.
Usa el navegador de clases de Seaside para ver la implementación de  \ct{WAMultiCounter}.
Deberías ver tres métodos en el lado de clase (\ct{canBeRoot}, \ct{description} e \ct{initialize}) y tres en el lado de instancia (\ct{children}, \ct{initialize} y \ct{renderContentOn:}).
Observa que una aplicación es simplemente un componente dispuesto a ser la raíz de la jerarquía de componentes; esta predisposición se indica definiendo un método de clase \ct{canBeRoot} que responda \ct{true}.}
\index{Seaside!multi contador}

Puedes usar la interfaz web de Seaside para configurar, copiar o eliminar aplicaciones individuales (es decir, componentes del nivel raíz). Inteta realizar el siguiente cambio de configuración.

\dothis{Dirige tu navegador web a  \url{http://localhost:8080/seaside/config}.
Introduce el login y contraseña (\ct{admin} y \ct{seaside} por defecto).
Selecciona \link{Configure} junto a ``examples.''
Bajo la cabecera ``Add entry point'', introduce el nuevo nombre ``counter2'' para el tipo \emph{Application} y pulsa sobre \button{Add} (ver \figref{counter2}).
En la siguiente pantalla, cambia \emph{Root Component} a \clsind{WACounter}, entonces haz click en \button{Save} y \button{Close}.
Ahora tenemos un nuevo contador instalado en  \url{http://localhost:8080/seaside/examples/counter2}.
Usa la misma interfaz de configuración para eliminar este punto de entrada.
}
\index{Seaside!configuración}


\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{counter2}
\caption{Configuración de una nueva aplicación}
\figlabel{counter2}
\end{center}
\end{figure}

Seaside opera en dos modos: el modo \emph{desarrollo}, que es el que hemos visto hasta ahora, y el modo \emph{despliegue}, en el que la barra de herramientas no está disponible.
\index{Seaside!modo desarrollo}
\index{Seaside!modo despliegue}
Puedes poner Seaside en el modo despliegue usando la página de configuración (navega a la entrada para la aplicación y haz click en el enlace \link{Configure})
% \ab{How?  I couldn't find this}
o haciendo click en el botón \button{Configure} en la barra de herramientas.
En cualquier caso, se pone el modo despliegue a \emph{true}.
Observa que esto sólo afecta a las nuevas sesiones.
También puedes poner el modo globalmente evaluando
\clsind{WAGlobalConfiguration} \lct{setDeploymentMode}
o
\ct{WAGlobalConfiguration setDevelopmentMode}.
\index{Seaside!modo desarrollo}
\index{Seaside!modo despliegue}

La página web de configuración sólo es otra aplicación Seaside por lo que también puede ser controlada desde la página de configuración.
Si eliminas la aplicación ``config'', puedes recuperarla evaluando
\clsind{WADispatcherEditor} \ct{initialize}.

%=================================================================
\section{Componentes Seaside}
\seclabel{componentes}

%\ab{This section was too long\,---\,18 pages.  It also contained several self-references (``see section 1.3''). So I broke into smaller sections, by promoting some of the subsections and subsubsections.}

Como hemos mencionado en la sección anterior, las aplicaciones Seaside se construyen con \emph{\subind{Seaside}{componentes}}.
Vamos a estudiar detenidamente cómo funciona Seaside implementando el componente \emph{Hello World}.

Todo componente Seaside debe heredar directa o indirectamente de \clsind{WAComponent}, como muestra la figura \figref{WACounter}.

\dothis{Define una subclase de \ct{WAComponent} llamada \ct{WAHelloWorld}.}

Los componentes deben saber cómo representarse a sí mismos.
Normalmente esto se hace implementando el método \mthind{WAPresenter}{renderContentOn:}, que recibe como argumento una instancia de \clsind{WAHtmlCanvas}, que sabe cómo generar XHTML.
\index{Seaside!representación}

\dothis{Implementa el siguiente método y ponlo en un protocolo llamado \prot{rendering}:}

\needlines{2}
\begin{code}{}
WAHelloWorld>>>renderContentOn: html
	html text: 'hello world'
\end{code}

\noindent
Ahora debemos informar a Seaside de que este componente está dispuesto a ser una aplicación independiente.

\dothis{Implementa el siguiente método de clase de \ct{WAHelloWorld}.}

\begin{code}{}
WAHelloWorld class>>>canBeRoot
	^ true
\end{code}

\noindent
¡Estamos a punto de acabar!

\dothis{Dirige tu navegador web a \url{http://localhost:8080/seaside/config}, añade un nuevo punto de entrada llamado ``hello'' y pon como su componente raíz \ct{WAHelloWorld}.
Ahora dirige tu navegador a \url{http://localhost:8080/seaside/hello}.
!Ya está! Deberías ver una página web como la de la figura \figref{WAHelloWorld}.}


\begin{figure}[htb]
\begin{center}
\includegraphics[width=\textwidth]{WAHelloWorld}
\caption{``Hello World'' en Seaside}
\figlabel{WAHelloWorld}
\end{center}
\end{figure}

%-----------------------------------------------------------------
\subsection{Marcha atrás de estado y la aplicación ``Counter''}
%{Simple and nested components}

La aplicación ``counter'' es sólo ligeramente más compleja que la aplicación ``hello world''.
\seclabel{backtracking}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{WACounter}
\caption{La clase \ct{WACounter}, que implementa la aplicación \emph{counter}. Los métodos con nombres subrayados son de clase; aquellos con nombres en texto normal son de instancia.}
\figlabel{WACounter}
\end{center}
\end{figure}

La clase \clsind{WACounter} es una aplicación independiente, con lo que la clase \ct{WACounter} debe responder \ct{true} al mensaje \mthind{WAComponent class}{canBeRoot}.
También debe registrarse como una aplicación; esto se hace en su método de clase \ct{initialize}, como muestra la figura \figref{WACounter}.
\ct{WACounter} define dos métodoso, \ct{increase} y \ct{decrease}, que serán disparados desde los vínculos \link{++} y \link{--\,--} de la página web.
También define una variable de instancia \ct{count} para registrar el estado del contador.
Sin embargo, también queremos que Seaside sincronice el contador con la página del navegador: cuando el usuario hace click en el botón ``atrás'' del navegador, queremos que Seaside ``retroceda'' el estado del objeto \ct{WACounter}.
Seaside incluye un mecaniso general de vuelta a atrás, pero cada aplicación tiene que decirle a Seaside qué partes de su estado tiene que seguir.

Un componente habilita la vuelta a atrás implementando el método \ct{states} en el lado de instancia:
% \ab{note that xspace messes up again, by inserting a space at the start of this line}
\ct{states} debería devolver un array que contenga todos los objetos a seguir.
En este caso, el objeto \ct{WACounter} se añade él mismo a la tabla de objetos que pueden retrocederse de Seaside Seaside devolviendo \ct{Array with: self}.

\paragraph{\emph{Advertencia.}}
Hay un punto sutil pero importante al que estar atento cuando se declaran objetos para retroceder.
Seaside sigue el estado haciendo una \emph{copia} de todos los objetos declarados en el array \ct{states}.
Hace esto usando un objeto \clsind{WASnapshot}; \ct{WASnapshot} es una subclase de \clsind{IdentityDictionary} que registra los objetos a seguir como claves y copias superficiales de su estado como valores.
\luq{\emph{shallow copy} como copia superficial}

Si el estado de una aplicación da marcha atrás a una instantánea particular, el estado de cada objeto que se añadió al diccionario de instantáneas se sobreescribe por la copia guardada en la instantánea. 
\luq{\emph{snapshot} traducido como instantánea}

El aspecto al que hay que estar atento es el siguiente:
En el caso de \ct{WACounter}, podrías pensar que el estado a seguir es un número\,---\,el valor de la variable de instancia \ct{count}.
Sin embargo, hacer que el método \ct{states} retorne \ct{Array with: count} no funcionará.  
Esto es así porque el objeto nombrado por \ct{count} es un entero y los enteros son inmutables.
Los métodos \ct{increase} y \ct{decrease} no cambian el estado del objeto \ct{0} a \ct{1} o el objeto \ct{3} a \ct{2}.
En cambio, \ct{count} nombra un entero diferente: 
cada vez que count se incrementa o decrementa, el objeto nombrado por \ct{count} es \emph{reemplazado} por otro.
Por esto es por lo que \ct{WACounter>>>states} debe retornar \ct{Array with: self}.
Cuando el estado de un objeto \mbox{\ct{WACounter}} es reemplazado por un estado previo, el \emph{valor} de cada una de las variables de instancia en el objeto es reemplazado por un valor previo; este reemplaza correctamente el valor actual de \ct{count} por un valor anterior. 
\index{Seaside!vuelta atrás del esstado}
\index{WAPresenter!states@\ct{states}}

\section{Generando XHTML}

El propósito de una aplicación web es crear o ``presentar'' páginas web.  Como mencionamos en \secref{components}, cada componente Seaside es responsable de presentarse a sí mismo.  
Así pues, vamos a comenzar nuestra exploración de la presentación viendo cómo el componente contador se presenta a sí mismo.

\subsection{Presentando el Contador}

La presentación del contador es relativamente directa; el código se muestra en la figura \figref{WACounter}.
El valor actual del contador se muestra como una cabecera XHTML, y las operaciones de incrementar y decrementar se implementan como anclas html (es decir, vínculos) con retrollamadas a bloques que enviarán \ct{increase} y \ct{decrease} al objeto contador.
\luq{\emph{callback} como retrollamada}

Echaremos un vistazo más de cerca al protocolo de presentación en un momento.
Pero antes de hacerlo, echemos un vistazo rápido al \subind{Seaside}{multi-contador}.

\subsection{De Contador a Multicontador}

\ct{WAMultiCounter} que se muestra en la figura \figref{WAMultiCounter} también es una aplicación independiente, con lo que sobreescribe \mthind{WAComponent class}{canBeRoot} para responder \ct{true}.
Además, es un componente \emph{compuesto}, con lo que Seaside requiere que declare sus hijos implementando un método \ct{children} que responda con un array con todos los componentes que contiene.
Se presenta a sí mismo presentando cada uno de sus subcomponentes, separados por una línea horizontal.
Además de los métodos de inicialización de instancia y estáticos, no hay nada más en el multicontador.

\begin{figure}[bht]
\begin{center}
\includegraphics[width=\textwidth]{WAMultiCounter}
\caption{WAMultiCounter}
\figlabel{WAMultiCounter}
\end{center}
\end{figure}

%-----------------------------------------------------------------
\subsection{Más sobre la Presentación XHTML}

Como puedes ver en estos ejemplos, Seaside no usa plantillas para generar páginas web.
En su lugar, genera XHTML programadamente.
La idea básica es que cada componente Seaside debería sobreescribir el método \mthind{WAPresenter}{renderContentOn:}; este mensaje será enviado por el marco de trabajo a cada componente que necesita ser presentado.
Este mensaje \ct{renderContentOn:} tendrá un argumento que es un \seeindex{lienzo}{lienzo html} \emphind{lienzo html} sobre el que el componente debe presentarse a sí mismo. Por convenio, el parámetro del lienzo html se llama \ct{html}.

Un lienzo html es análogo al lienzo gráfico usado por Morphic (y la mayoría de otros marcos de trabajo de dibujo) para abstraerse de los detalles dependientes del dispositivo de dibujo.
 
Estos son algunos de los métodos de presentación más básicos:
\begin{code}{}
html text: 'hello world'.  "presenta una cada de texto plano"
html html: '&ndash;'.     "presenta un conjuro XHTML"
html render: 1.              "presenta cualquier objeto"
\end{code}

El mensaje \ct{render: anyObject} se puede enviar a un lienzo html para presentar \ct{anyObject}; se utiliza normalmente para presentar subcomponentes. A \lct{anyObject} se le enviará el mensaje \ct{renderContentOn:}
esto es lo que ocurre en el multi-contador (ver la \figref{WAMultiCounter}).

\subsection{Usando Pinceles}
\seclabel{brushes}

Un lienzo proporciona un número de \emphind{pinceles} que pueden usarse para presentar (\ie ``pintar) contenido en el lienzo.
Hay lienzos para cada tipo de elemento XHTML \,---\,párrafos, tablas, listas y demás.
Para ver el protocolo completo de lienzos y métodos de utilidad, deberías navegar por la clase \clsind{WACanvas} y sus subclases.
El argumento para \ct{renderContentOn:} es realmente una instancia de la subclase \clsind{WARenderCanvas}.

Ya hemos visto el siguiente pincel utilizado en los ejemplos contador y multi-contador:
\needlines{2}
\begin{code}{}
html horizontalRule.
\end{code}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{RenderingDemo}
\caption{RenderingDemo}
\figlabel{RenderingDemo}
\end{center}
\end{figure}

En la figura \figref{RenderingDemo} podemo ver la salida de muchos de los pinceles básicos ofrecidos por Seaside.\footnote{El código fuente para \mthref{renderdemo} está en el paquete \ct{PBE-SeasideDemo} en el proyecto \url{http://www.squeaksource.com/PharoByExample}.}
El componente raíz \ct{SeasideDemo} simplemente presenta sus subcomponentes, que son instancias de \ct{SeasideHtmlDemo}, \ct{SeasideFormDemo}, \ct{SeasideEditCallDemo} y \ct{SeasideDialogDemo}, como se muestra en \mthref{renderdemo}.

\needspace{7ex}
\begin{code}[renderdemo]{\lct{SeasideDemo>>renderContentOn:}}
SeasideDemo>>>renderContentOn: html
	html heading: 'Rendering Demo'.
	html heading
		level: 2;
		with: 'Rendering basic HTML: '.
	html div
		class: 'subcomponent';
		with: htmlDemo.
	"render the remaining components ..."
\end{code}

\noindent
Recuerda que un componente raíz debe siempre declarar sus hijos o Seaside rechazará presentarlos.
\begin{code}{}
SeasideDemo>>>children
	^ { htmlDemo . formDemo . editDemo . dialogDemo }
\end{code}

Ten en cuenta que hay dos formas distintas de instanciar el pincel \ct{heading}.
La primera forma es establecer el texto directamente enviando el mensaje \ct{heading:}.
La segunda forma es instanciar el pincel enviando \ct{heading} y entonces enviar una cascada de mensajes al pincel para establecer sus propiedades y presentarlo.

Muchos de los pinceles disponibles pueden usarse de estas dos formas.

\important{Si envías una \ind{cascada} de mensajes al pincel, incluyendo el mensaje \mthind{WABrush}{with:}, entonces \ct{with:} debería ser el mensaje \emph{final}.
\ct{with:} establece el contenido y presenta el resultado.}

En \mthref{renderdemo}, la primera cabecera está al nivel 1, ya que este es el valor por defecto.
Explícitamente ponemos el nivel de la segunda cabecera a 2.
El subcomponente es presentado como un \emph{div} XHTML con la clase \ind{CSS} ``subcomponent''.
(Más sobre CSS en \secref{css}.)
También ten en cuenta que es necesario que el argumento para el mensaje de palabra clave \ct{with:} no sea una cadena literal: puede ser otro componente, o incluso\,---\,como en el siguiente ejemplo\,---\,un bloque conteniendo más acciones de presentación.

El componente \ct{SeasideHtmlDemo} demuestra muchos de los pinceles más básicos.
La mayoría del código debería explicarse por sí solo.

\begin{code}{}
SeasideHtmlDemo>>>renderContentOn: html 
	self renderParagraphsOn: html.
	self renderListsAndTablesOn: html.
	self renderDivsAndSpansOn: html.
	self renderLinkWithCallbackOn: html
\end{code}

Es una práctica común dividir métodos de presentación largos en muchos métodos auxiliares, como hemos hecho aquí.

\important{No pongas todo tu código de presentación en un único método.
Divídelo en métodos auxiliares nombrados usando el patrón \ct{render*On:}.
Todos los métodos de presentación van en el protocolo \prot{rendering}.
No envíes \ct{renderContentOn:} desde tu propio código, usa \ct{render:} en su lugar.}

Mira el siguiente código.
El primer método auxiliar, \ct{SeasideHtmlDemo>>>renderParagraphsOn:}, muestra cómo generar párrafos XHTML, texto plano y enfatizado e imágenes.
Ten en cuenta que en Seaside los elementos sencillos son presentados especificando el texto que contienen directamente, mientras que los elementos complejos se especifican usando bloques.
Este es un convenio sencillo para ayudatte a estructurar tu código de presentación.

\begin{code}{}
SeasideHtmlDemo>>>renderParagraphsOn: html 
	html paragraph: 'Un parrafo con texto plano.'.
	html paragraph: [
		html
			text: 'Un parrafo con texto plano seguido por una nueva linea. ';
			break;
			emphasis: 'Texto con enfasis ';
			text: 'seguido por una linea horizontal.';
			horizontalRule;
			text: 'Una URI de imagen: '.
		html image
			url: self squeakImageUrl;
			width: '50']
\end{code}

El siguiente método auxiliar, \ct{SeasideHtmlDemo>>>renderListsAndTablesOn:}, muestra cómo generar listas y tablas.
Una tabla usa dos niveles de bloques para mostrar cada una de sus filas y las celdas dentro de las filas.

\begin{code}{}
SeasideHtmlDemo>>>renderListsAndTablesOn: html 
	html orderedList: [
		html listItem: 'Un elemento de una lista ordenada'].
	html unorderedList: [
		html listItem: 'Un elemento de una lista desordenada'].
	html table: [
		html tableRow: [
			html tableData: 'Una tabla con una celda de datos.']]
\end{code}

El siguiente ejemplo muestra cómo podemos especificar \emph{div}s y \emph{span}s con atributos CSS \emph{class} o \emph{id}.
Por supuesto, los mensajes \ct{class:} e \ct{id:} también pueden enviarse a los otros pinceles, no sólo a \emph{div}s y \emph{span}s.
El método \ct{SeasideDemoWidget>>>style} define cómo deberían ser mostrados estos elementos XHTML (ver \secref{css}).

\begin{code}{}
SeasideHtmlDemo>>>renderDivsAndSpansOn: html 
	html div
		id: 'author';
		with: [
			html text: 'Texto plano con un div con id ''author''. '.
			html span
				class: 'highlight';
				with: 'Un span con class ''highlight''.']
\end{code}

Finalmente vemos un sencillo ejemplo de un vínculo, creado asociando una sencilla \subind{Seaside}{retrollamada} con un ``ancla'' (\ie un vínculo).
Hacer click en el vínculo causará que el texto a continuación cambie entre ``true'' y ``false'' cambiando la variable de instancia \ct{toggleValue}.

\needlines{3}
\begin{code}{}
SeasideHtmlDemo>>>renderLinkWithCallbackOn: html 
	html paragraph: [
		html text: 'Un ancla con una accion local: '.
		html span with: [
			html anchor
				callback: [toggleValue := toggleValue not];
				with: 'cambia el booleano:'].
		html space.
		html span
			class: 'boolean';
			with: toggleValue ]
\end{code}

\important{Ten en cuenta que las acciones deberían aparecer sólo en retrollamadas.
¡El código ejecutado durante la presentación no debería cambiar el estado de la aplicación!}

%-----------------------------------------------------------------
\subsection{Formularios}

Los formularios se presentan igual que los otros ejemplos que ya hemos visto.
Este es el código para el componente \ct{SeasideFormDemo} de la figura \figref{RenderingDemo}.
\index{Seaside!formularios XHTML}

\begin{code}{}
SeasideFormDemo>>>renderContentOn: html
	| radioGroup |
	html heading: heading.
	html form: [
		html span: 'Cabecera: '.
		html textInput on: #heading of: self.
		html select
			list: self colors;
			on: #color of: self.
		radioGroup := html radioGroup.
		html text: 'Radio on:'.
		radioGroup radioButton
			selected: radioOn;
			callback: [radioOn := true].
		html text: 'off:'.
		radioGroup radioButton
			selected: radioOn not;
			callback: [radioOn := false].
		html checkbox on: #checked of: self.
		html submitButton
			text: 'hecho' ]
\end{code}{}

Puesto que un formulario es una entidad compleja, se presenta usando un bloque.
Ten en cuenta que todos los cambios de estado ocurren en las retrollamadas, no como parte de la presentación.

Hay una característica de Seaside utilizada aquí que merece una mención especial, que es el mensaje \mthind{WAAnchorTag}{on:of:}.
En el ejemplo, este mensaje se usa para asociar un campo de entrada de texto con la variable \ct{heading}.
Anclas y botones también soportan este mensaje.
El primer argumento es el nombre de una variable de instancia para la que se han definido métodos de acceso; el segundo argumento es el argumento al que esta variable de instancia pertenece.
Ambos métodos de acceso, observador (\ct{heading}) y modificador (\ct{heading:}) son comprendidos por el objeto con el convenio de nombre habitual.
En este caso de un campo de entrada de texto, esto nos ahorra el problema de tener que definir una retrollamada que actualice el campo además de tener que asociar los contenidos por defecto del campo de entrada html con el valor actual de la variable de instancia.
Usando \ct{on: #heading of: self}, la variable \ct{heading} se actualiza automáticamente cuando el usuario actualiza el campo de entrada de texto.

El mismo mensaje se usa dos veces más en este ejemplo, para causar que la selección de un color en el formulario html actualice la variable \ct{color}, y para asociar el resultado del checkbox con la variable \ct{checked}.
Muchos otros ejemplos pueden encontrarse en los tests funcionales de Seaside.
Echa un vistazo a la categoría \scat{Seaside-Tests-Functional}, o simplemente dirige tu navegador a \url{http://localhost:8080/seaside/tests/alltests}.
Selecciona \menu{WAInputTest} y haz click en el botón \button{Restart} para ver la mayoría de las características de los formularios.

No olvides que si activas \button{Toggle Halos}, puedes navegar directamente por el código fuente de los ejemplos usando el navegador de clases de Seaside.

%-----------------------------------------------------------------
\section{CSS: Cascading style sheets}
\seclabel{css}

%\ab{I think that it just needs a few paragraphs telling the reader the key ideas behind CSS, and the new terminology that the CSS folks introduce, before going in to the details of how you define their "thingies".  Now I have forgotten what they call their "thingies" --- I know that there are effectively paragraph styles (divs) and character styles (spans), but I've forgotten what they call them.  So, I think that the text needs to tell the reader, for each thingie, (1) the CSS concept behind the thingie, (2) what it looks like in a CSS style sheet , (3) what it looks like in html, and (4) how to do it in Seaside.   Maybe (3) can be omitted, because it's not needed to use Seaside.}
% \on{I think we do most of that already.}

Cascading Style Sheets\footnote{\url{http://www.w3.org/Style/CSS/}}, or \ind{CSS} for short, have emerged as a standard way for web applications to separate style from content.
Seaside relies on CSS to avoid cluttering your rendering code with layout considerations.

You can set the CSS style sheet for your web components by defining the method \ct{style}, which should return a string containing the CSS rules for that component.
The styles of all the components displayed on a web page are joined together, so each component can have its own style.
A better approach can be to define an abstract class for your web application that defines a common style for all its subclasses.

Actually, for deployed applications, it is more common to define style sheets as external files.
This way the look and feel of the component is completely separate from its functionality.
(Have a look at \clsind{WAFileLibrary}, which provides a way to serve static files without the need for a standalone server.)

If you already are familiar with CSS, then that's all you need to know.
Otherwise, read on for a very brief introduction to CSS.

Instead of directly encoding display attributes in the paragraph and text elements of your web pages, with CSS you will define different classes of elements and place all display considerations in a separate style sheet.
Paragraph-like entities are called \emph{div}s and text-like entities are \emph{span}s.
You would then define symbolic names, like ``highlight'' (see example below) for text to be highlighted, and specify how highlighted text is to be displayed in your style sheet.

Basically a CSS style sheet consists of a set of rules that specify how to format given XHTML elements.
Each rule consists of two parts.
There is a \emph{selector} that specifies which XHTML elements the rule applies to, and there is a \emph{declaration} which sets a number of attributes for that element.

\begin{figure}[tb]
\begin{code}{}
SeasideDemoWidget>>>style
	^ '
body {
	font: 10pt Arial, Helvetica, sans-serif, Times New Roman;
}
h2 {
	font-size: 12pt;
	font-weight: normal;
	font-style: italic;
}
table { border-collapse: collapse; }
td {
	border: 2px solid #CCCCCC;
	padding: 4px;
}
#author {
	border: 1px solid black;
	padding: 2px;
	margin: 2px;
}
.subcomponent {
	border: 2px solid lightblue;
	padding: 2px;
	margin: 2px;
}
.highlight { background-color: yellow; }
.boolean { background-color: lightgrey; }
.field { background-color: lightgrey; }
'
\end{code}
\caption{\lct{SeasideDemoWidget} common style sheet.
\figlabel{democss}}
\end{figure}
\figref{democss} illustrates a simple style sheet for the rendering demo shown earlier in \figref{RenderingDemo}.
The first rule specifies a preference for the fonts to use for the \ct{body} of the web page.
The next few rules specify properties of second-level headings (\ct{h2}), tables (\ct{table}), and table data (\ct{td}).

The remaining rules have selectors that will match XHTML elements that have the given ``class'' or ``id'' attributes.
CSS selectors for class attributes start with a ``\ct{.}'' and those for id attributes with ``\ct{#}''.
The main difference between class and id attributes is that many elements may have the same class, but only one element may have a given id (\ie an \emph{identifier}). 
So, whereas a class attribute, such as \ct{highlight}, may occur multiple times on any page, an id must identify a \emph{unique} element on the page, such as a particular menu, the modified date, or author.
Note that a particular XHTML element may have multiple classes, in which case all the applicable display attributes will be applied in sequence.

% This style sheet expects at most one element to specify the \emph{author} of the web page.

Selector conditions may be combined, so the selector \ct{div.subcomponent} will only match an XHTML element if it is both a div \emph{and} it has a class attribute equal to ``subcomponent''.

It is also possible to specify nested elements, though this is seldom necessary.
For example, the selector ``\ct{p span}'' will match a span within a paragraph but not within a div.

There are numerous books and web sites to help you learn CSS.
For a dramatic demonstration of the power of CSS, we recommend you to have a look at the CSS Zen Garden\footnote{\url{http://www.csszengarden.com/}}, which shows how the same content can be rendered in radically different ways simply by changing the CSS style sheet.

%-----------------------------------------------------------------
\section{Managing control flow}

Seaside makes it particularly easy to design web applications with non-trivial control flow.
There are basically two mechanisms that you can use:

\begin{enumerate}
  \item A component can \emph{call} another component by sending \ct{caller call: callee}.
  The caller is temporarily replaced by the callee, until the callee returns control by sending \ct{answer:}.
  The caller is usually \ct{self}, but could also be any other currently visible component.

  \item A workflow can be defined as a \emphsubind{Seaside}{task}.
  This is a special kind of component that subclasses \clsind{WATask} (instead of \clsind{WAComponent}). \seclabel{task}
  Instead of defining \ct{renderContentOn:}, it defines no content of its own, but rather defines a \ct{go} method that sends a series of \ct{call:} messages to activate various subcomponents in turn.
\end{enumerate}
\index{Seaside!control flow}

%-----------------------------------------------------------------
\subsection{Call and answer}

Call and answer are used to realize simple dialogues.

There is a trivial example of \ct{call:} and \ct{answer:} in the rendering demo of \figref{RenderingDemo}.
The component \ct{SeasideEditCallDemo} displays a text field and an \emph{edit} link.
The callback for the edit link calls a new instance of \ct{SeasideEditAnswerDemo} initialized to the value of the text field.
The callback also updates this text field to the result which is sent as an answer.

(We underline the \ct{call:} and \ct{answer:} sends to draw attention to them.)

\begin{code}{}
SeasideEditCallDemo>>>renderContentOn: html 
	html span
		class: 'field';
		with: self text.
	html space.
	html anchor
		callback: [self text: (self !\underline{call:}! (SeasideEditAnswerDemo new text: self text))];
		with: 'edit'
\end{code}{}

What is particularly elegant is that the code makes absolutely no reference to the new web page that must be created.
At run-time, a new page is created in which the \ct{SeasideEditCallDemo} component is replaced by a \ct{SeasideEditAnswerDemo} component; the parent component and the other peer components are untouched.

\important{\mthind{WAComponent}{call:} and \mthind{WAComponent}{answer:} should never be used while rendering.
They may safely be sent from within a \subind{Seaside}{callback}, or from within the \mthind{WATask}{go} method of a task.}

The \ct{SeasideEditAnswerDemo} component is also remarkably simple.
It just renders a form with a text field.
The submit button is bound to a callback that will answer the final value of the text field.

\begin{code}{}
SeasideEditAnswerDemo>>>renderContentOn: html
	html form: [
		html textInput
			on: #text of: self.
		html submitButton
			callback: [ self !\underline{answer:}! self text ];
			text: 'ok'.
		]
\end{code}{}

That's it.

Seaside takes care of the control flow and the correct rendering of all the components.
Interestingly, the ``back'' button of the browser will also work just fine (though side effects are not rolled back unless we take additional steps).

%-----------------------------------------------------------------
\subsection{Convenience methods}

Since certain call--answer dialogues are very common, Seaside provides some convenience methods to save you the trouble of writing components like \ct{SeasideEditAnswerDemo}.
The generated dialogues are shown in \figref{dialogs}.
We can see these convenience methods being used within \ct{SeasideDialogDemo>>>renderContentOn:}
\index{Seaside!convenience methods}

\begin{figure}[b]
\begin{center}
\includegraphics[width=\textwidth]{dialogs}
\caption{Some standard dialogs}
\figlabel{dialogs}
\end{center}
\end{figure}

The message \mthind{WAComponent}{request:} performs a call to a component that will let you edit a text field.
The component answers the edited string.
An optional label and default value may also be specified.

\needlines{3}
\begin{code}{}
SeasideDialogDemo>>>renderContentOn: html
	html anchor
		callback: [ self request: 'edit this' label: 'done' default: 'some text' ];
		with: 'self request:'.
...
\end{code}

The message \mthind{WAComponent}{inform:} calls a component that simply displays the argument message and waits for the user to click ``ok''.
The called component just returns \ct{self}.

\begin{code}{}
...
	html space.
	html anchor
		callback: [ self inform: 'yesBANG' ];
		with: 'self inform:'.
...
\end{code}

The message \mthind{WAComponent}{confirm:} asks a questions and waits for the user to select either ``Yes'' or ``No''.
The component answers a boolean, which can be used to perform further actions.

\begin{code}{}
...
	html space.
	html anchor
		callback: [
			(self confirm: 'Are you happy?')
				ifTrue: [ self inform: ':-)' ]
				ifFalse: [ self inform: ':-(' ]
			];
		with: 'self confirm:'.
\end{code}

A few further convenience methods, such as \mthind{WAComponent}{chooseFrom:caption:}, are defined in the \prot{convenience} protocol of \clsind{WAComponent}.

%-----------------------------------------------------------------
\subsection{Tasks}

A \subind{Seaside}{task} is a component that subclasses \clsind{WATask}.
It does not render anything itself, but simply calls other components in a control flow defined by implementing the method \mthind{WATask}{go}.

\clsind{WAConvenienceTest} is a simple example of a task defined in the category \scat{Seaside-Tests-Functional}.
To see its effect, just point your browser to \url{http://localhost:8080/seaside/tests/alltests}, select \menu{WAConvenienceTest} and click \button{Restart}.

\begin{code}{}
WAConvenienceTest>>>go
	[ self chooseCheese.
	  self confirmCheese ] whileFalse.
	self informCheese
\end{code}

This task calls in turn three components.
The first, generated by the convenience method \mthind{WAComponent}{chooseFrom: caption:}, is a \clsind{WAChoiceDialog} that asks the user to choose a cheese.

\begin{code}{}
WAConvenienceTest>>>chooseCheese
	cheese := self
		chooseFrom: #('Greyerzer' 'Tilsiter' 'Sbrinz')
		caption: 'What''s your favorite Cheese?'.
	cheese isNil ifTrue: [ self chooseCheese ]
\end{code}

% \alex{Is there a situation where cheese may be nil? Maybe if a browser authorizes an empty selection...}

The second is a \clsind{WAYesOrNoDialog} to confirm the choice (generated by the convenience method \mthind{WAComponent}{confirm:}).

\begin{code}{}
WAConvenienceTest>>>confirmCheese
	^self confirm: 'Is ', cheese,  ' your favorite cheese?'
\end{code}

Finally a \clsind{WAFormDialog} is called (via the convenience method \mthind{WAComponent}{inform:}).

\begin{code}{}
WAConvenienceTest>>>informCheese
	self inform: 'Your favorite cheese is ', cheese, '.'
\end{code}

The generated dialogues are shown in \figref{chooseCheese}.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{chooseCheese}
\caption{A simple task}
\figlabel{chooseCheese}
\end{center}
\end{figure}

%-----------------------------------------------------------------
\subsection{Transactions}

We saw in \secref{backtracking} that Seaside can keep track of the correspondence between the state of components and individual web pages by having components register their state for backtracking:
all that a component need do is implement the method \ct{states} to answer an array of all the objects whose state must be tracked.

Sometimes, however, we do not want to backtrack state: instead we want to \emph{prevent} the user from accidentally undoing effects that should be permanent.
This is often referred to as ``the shopping cart problem''.
Once you have checked-out your shopping cart and paid for the items you have purchased, it should not be possible to go ``back'' with the browser and add more items to the shopping cart!

Seaside allows you to prevent this by defining a task within which certain actions are grouped together as \emph{transactions}.
You can backtrack within a transaction, but once a transaction is complete, you can no longer go back to it.
The corresponding pages are \emph{invalidated}, and any attempt to go back to them will cause Seaside to generate a warning and redirect the user to the most recent valid page.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{sushiStore}
\caption{The Sushi Store}
\figlabel{sushiStore}
\end{center}
\end{figure}

The Seaside \emphsubind{Seaside}{Sushi Store} is sample application that illustrates many of the features of Seaside, including transactions.
This application is bundled with your installation of Seaside, so you can try it out by pointing your browser at
\url{http://localhost:8080/seaside/examples/store}.\footnote{If you cannot find it in your image, there is a version of the sushi store available on SqueakSource from \url{http://www.squeaksource.com/SeasideExamples/}.}

The sushi store supports the following workflow:
\begin{enumerate}[itemsep=0pt]
  \item Visit the store.
  \item Browse or search for sushi.
  \item Add sushi to your shopping cart.
  \item Checkout.
  \item Verify your order.
  \item Enter shipping address.
  \item Verify shipping address.
  \item Enter payment information.
  \item Your fish is on its way!
\end{enumerate}

If you toggle the \subind{Seaside}{halos}, you will see that the top-level component of the sushi store is an instance of \clsind{WAStore}.
It does nothing but render the title bar, and then it renders \ct{task}, an instance of \clsind{WAStoreTask}.

\begin{code}{}
WAStore>>>renderContentOn: html
	"... render the title bar ..."
	html div id: 'body'; with: task
\end{code}

\clsind{WAStoreTask} captures this workflow sequence. At a couple of points it is critical that the user not be able to go back and change the submitted information.

\dothis{\,``Purchase'' some sushi and then use the ``back'' button to try to put more sushi into your cart.
You will get the message ``That page has expired.''}

Seaside lets the programmer say that a certain part of a workflow act like a transaction: once the transaction is complete, the user cannot go back and undo it.
You say this by sending \mthind{WAComponent}{isolate:} to a task with the transactional block as its argument.
We can see this in the sushi store workflow as follows:

\begin{code}{}
WAStoreTask>>>go
	| shipping billing creditCard |
	cart := WAStoreCart new.
	self isolate:
		[[self fillCart.
		self confirmContentsOfCart]
			whileFalse].

	self isolate:
		[shipping := self getShippingAddress.
		billing := (self useAsBillingAddress: shipping)
					ifFalse: [self getBillingAddress]
					ifTrue: [shipping].
		creditCard := self getPaymentInfo.
		self shipTo: shipping billTo: billing payWith: creditCard].

	self displayConfirmation.
\end{code}

Here we see quite clearly that there are two transactions.
The first fills the cart and closes the shopping phase.
(The helper methods \ct{fillCart} \etc take care of instantiating and calling the right subcomponents.)
Once you have confirmed the contents of the cart you cannot go back without starting a new session.
The second transaction completes the shipping and payment data.
You can navigate back and forth within the second transaction until you confirm payment.
However, once both transactions are complete, any attempt to navigate back will fail.

Transactions may also be nested.
A simple demonstration of this is found in the class \clsind{WANestedTransaction}.
The first \ct{isolate:} takes as argument a block that contains another, nested \ct{isolate:}

\begin{code}{}
WANestedTransaction>>>go
	self inform: 'Before parent txn'.
	self isolate:
			[self inform: 'Inside parent txn'.
			self isolate: [self inform: 'Inside child txn'].
			self inform: 'Outside child txn'].
	self inform: 'Outside parent txn'
\end{code}

\dothis{Go to \url{http://localhost:8080/seaside/tests/alltests}, select \menu{WATransactionTest} and click on \button{Restart}.
Try to navigate back and forth within the parent and child transaction by clicking the \button{back} button and then clicking \button{ok}.
Note that as soon as a transaction is complete, you can no longer go back inside the transaction without generating an error upon clicking \button{ok}.}

%=================================================================
\section{A complete tutorial example}

% ON: Should take about two hours

Let's see how we can build a complete Seaside application from scratch.\footnote{The exercise should take at most a couple of hours. If you prefer to just look at the completed source code, you can grab it from the SqueakSource project \url{http://www.squeaksource.com/PharoByExample}.
The package to load is \scat{PBE-SeasideRPN}. The tutorial that follows uses slightly different class names so that you can compare your implementation with ours.}
We will build a RPN (Reverse Polish Notation) calculator as a Seaside application that uses a simple stack machine as its underlying model.
Furthermore, the Seaside interface will let us toggle between two displays\,---\,one which just shows us the current value on top of the stack, and the other which shows us the complete state of the stack.
The calculator with the two display options is shown in \figref{stackMachine}.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{stackMachine}
\caption{RPN calculator and its stack machine}
\figlabel{stackMachine}
\end{center}
\end{figure}

We begin by implementing the stack machine and its tests.

\dothis{Define a new class called \ct{MyStackMachine} with an instance variable \ct{contents} initialized to a new \ct{OrderedCollection}.}

\begin{code}{}
MyStackMachine>>>initialize
	super initialize.
	contents := OrderedCollection new.
\end{code}

The stack machine should provide operations to \ct{push:} and \ct{pop} values, view the \ct{top} of the stack, and perform various arithmetic operations to add, subtract, multiply and divide the top values on the stack.

\dothis{Write some tests for the stack operations and then implement these operations.
Here is a sample test:}

\needlines{4}
\begin{code}{}
MyStackMachineTest>>>testDiv
	stack
		push: 3;
		push: 4;
		div.
	self assert: stack size = 1.
	self assert: stack top = (4/3).
\end{code}

You might consider using some helper methods for the arithmetic operations to check that there are two numbers on the stack before doing anything, and raising an error if this precondition is not fulfilled.\footnote{It's a good idea to use \ct{Object>>>assert:} to specify the preconditions for an operation.
This method will raise an \ct{AssertionFailure} if the user tries to use the stack machine in an invalid state.}
If you do this, most  of your methods will just be one or two lines long.

You might also consider implementing \ct{MyStackMachine>>>printOn:} to make it easier to debug your stack machine implementation with the help of an object inspector.
(Hint: just delegate printing to the \ct{contents} variable.)
\index{Object!printOn:@\ct{printOn:}}

\dothis{Complete the \ct{MyStackMachine} by writing operations \ct{dup} (push a duplicate of the top value onto the stack), \ct{exch} (exchange the top two values), and \ct{rotUp} (rotate the entire stack contents up\,---\,the top value will move to the bottom).}

Now we have a simple stack machine implementation.
We can start to implement the Seaside RPN Calculator.

We will make use of 5 classes:
\begin{itemize}
  \item \ct{MyRPNWidget}\,---\,this should be an abstract class that defines the common CSS style sheet for the application, and other common behavior for the components of the RPN calculator.
  It is a subclass of \ct{WAComponent} and the direct superclass of the following four classes. 
  
    \item \ct{MyCalculator}\,---\,this is the root component.
  It should register the application (on the class side), it should instantiate and render its subcomponents, and it should register any state for backtracking.
  \item \ct{MyKeypad}\,---\,this displays the keys that we use to interact with the calculator.
  \item \ct{MyDisplay}\,---\,this component displays the top of the stack and provides a button to call another component to display the detailed view.
  \item \ct{MyDisplayStack}\,---\,this component shows the detailed view of the stack and provides a button to answer back.
  It is a subclass of \lct{MyDisplay}.
\end{itemize}

\dothis{Define \ct{MyRPNWidget} in the category \ct{MyCalculator}.
Define the common \ct{style} for the application.}

Here is a minimal CSS for the application.
You can make it more fancy if you like.
\begin{code}{}
MyRPNWidget>>>style
	^ 'table.keypad { float: left; }
td.key {
	border: 1px solid grey;
	background: lightgrey;
	padding: 4px;
	text-align: center;
}
table.stack { float: left; }
td.stackcell {
	border: 2px solid white;
	border-left-color: grey;
	border-right-color: grey;
	border-bottom-color: grey;
	padding: 4px;
	text-align: right;
}
td.small { font-size: 8pt; }'
\end{code}

\dothis{Define \ct{MyCalculator} to be a root component and register itself as an application (\ie implement \ct{canBeRoot} and \ct{initialize} on the class side).
Implement \ct{MyCalculator>>>renderContentOn:} to render something trivial (such as its name), and verify that the application runs in a browser.
}

\ct{MyCalculator} is responsible for instantiating \ct{MyStackMachine}, \ct{MyKeypad} and \ct{MyDisplay}.

\dothis{
Define \ct{MyKeypad} and \ct{MyDisplay} as subclasses of \lct{MyRPNWidget}.
All three components will need access to a common instance of the stack machine, so define the instance variable \ct{stackMachine} and an initialization method \ct{setMyStackMachine:} in the common parent, \ct{MyRPNWidget}.
Add instance variables \ct{keypad} and \ct{display} to \ct{MyCalculator} and initialize them in \ct{MyCalculator>>>initialize}.
(Don't forget to send \lct{super initialize}!)}

\dothis{
Pass the shared instance of the stack machine to the keypad and the display in the same initialize method.
Implement \ct{MyCalculator>>>renderContentOn:} to simply render in turn the keypad and the display.
To correctly display the subcomponents, you must implement \ct{MyCalculator>>>children} to return an array with the keypad and the display.
Implement placeholder rendering methods for the keypad and the display and verify that the calculator now displays its two subcomponents.
}

%\ab{Too long!}

Now we will change the implementation of the display to show the top value of the stack.

\dothis{
Use a table with class ``keypad'' containing a row with a single table data cell with class ``stackcell''.
Change the rendering method of the keypad to ensure that the number 0 is pushed on the stack in case it is empty.
(Define and use \ct{MyKeypad>>>ensureMyStackMachineNotEmpty}.)
Also make it display an empty table with class ``keypad''.
Now the calculator should display a single cell containing the value 0.
If you toggle the halos, you should see something like this:
}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.8\textwidth]{firstStackDisplay}
\caption{Displaying the top of the stack}
\figlabel{firstStackDisplay}
\end{center}
\end{figure}

Now let's implement an interface to interact with the stack.

\dothis{
First define the following helper methods, which will make it easier to script the interface:
}

\needlines{3}
\begin{code}{}
MyKeypad>>>renderStackButton: text callback: aBlock colSpan: anInteger on: html 
	html tableData
		class: 'key';
		colSpan: anInteger;
		with: 
				[html anchor
					callback: aBlock;
					with: [html html: text]]
\end{code}


\begin{code}{}
MyKeypad>>>renderStackButton: text callback: aBlock on: html 
	self 
		renderStackButton: text
		callback: aBlock
		colSpan: 1
		on: html
\end{code}

We will use these two methods to define the buttons on the keypad with appropriate callbacks.
Certain buttons may span multiple columns, but the default is to occupy just one column.

\dothis{
Use the two helper methods to script the keypad as follows:
(Hint: start by getting the digit and ``Enter'' keys working, then the arithmetic operators.)
}

\needlines{4}
\begin{code}{}
MyKeypad>>>renderContentOn: html 
  self ensureStackMachineNotEmpty.
  html table
    class: 'keypad';
    with: [
      html tableRow: [
          self renderStackButton: '+' callback: [self stackOp: #add] on: html.
          self renderStackButton: '&ndash;' callback: [self stackOp: #min] on: html.
          self renderStackButton: '&times;' callback: [self stackOp: #mul] on: html.
          self renderStackButton: '&divide;' callback: [self stackOp: #div] on: html.
          self renderStackButton: '&plusmn;' callback: [self stackOp: #neg] on: html ].
        html tableRow: [
          self renderStackButton: '1' callback: [self type: '1'] on: html.
          self renderStackButton: '2' callback: [self type: '2'] on: html.
          self renderStackButton: '3' callback: [self type: '3'] on: html.
          self renderStackButton: 'Drop' callback: [self stackOp: #pop]
          	colSpan: 2 on: html ].
" and so on ... "
        html tableRow: [
          self renderStackButton: '0' callback: [self type: '0'] colSpan: 2 on: html.
          self renderStackButton: 'C' callback: [self stackClearTop] on: html.
          self renderStackButton: 'Enter'
          	callback: [self stackOp: #dup. self setClearMode]
			colSpan: 2 on: html ]]
\end{code}

Check that the keypad displays properly.
If you try to click on the keys, however, you will find that the calculator does not work yet\ldots{}

\dothis{
Implement \ct{MyKeypad>>>type:} to update the top of the stack by appending the typed digit.
You will need to convert the top value to a string, update it, and convert it back to an integer, something like this:
}
\begin{code}{}
MyKeypad>>>type: aString
	stackMachine push: (stackMachine pop asString, aString) asNumber.
\end{code}
Now when you click on the digit keys the display should be updated.
(Be sure that \ct{MyStackMachine>>>pop} returns the value popped, or this will not work!)


\dothis{Now we must implement \ct{MyKeypad>>>stackOp:}
Something like this will do the trick:}

\begin{code}{}
MyKeypad>>>stackOp: op
	[ stackMachine perform: op ] on: AssertionFailure do: [ ].
\end{code}

The point is that we are not sure that all operations will succeed, for example, addition will fail if we do not have two numbers on the stack.
For the moment we can just ignore such errors.
If we are feeling more ambitious later on, we can provide some user feedback in the error handler block.

\dothis{The first version of the calculator should be working now.
Try to enter some numbers by pressing the digit keys, hitting \menu{Enter} to push a copy of the current value, and entering \menu{+} to sum the top two values.}

You will notice that typing digits does not behave the way you might expect.
Actually the calculator should be aware of whether you are typing a \emph{new} number, or appending to an existing number.

\dothis{Adapt \ct{MyKeypad>>>type:} to behave differently depending on the current typing mode.
Introduce an instance variable \ct{mode} which takes on one of the three values \lct{\#typing} (when you are typing), \lct{\#push} (after you have performed a calculator operation and typing should force the top value to be pushed), or \lct{\#clear} (after you have performed \menu{Enter} and the top value should be cleared before typing).
The new \ct{type:} method might look like this:
}

\begin{code}{}
MyKeypad>>>type: aString
	self inPushMode ifTrue: [
		stackMachine push: stackMachine top.
		self stackClearTop ].
	self inClearMode ifTrue: [ self stackClearTop ].
	stackMachine push: (stackMachine pop asString, aString) asNumber.
\end{code}
\mb{better with "stackMachine dup" instead of "stackMachine push:
  stackMachine top}"

Typing might work better now, but it is still frustrating not to be able to see what is on the stack.

\dothis{
Define \ct{MyDisplayStack} as a subclass of \ct{MyDisplay}.
Add a button to the rendering method of \ct{MyDisplay} which will call a new instance of \ct{MyDisplayStack}.
You will need an html anchor that looks something like this:
}

\begin{code}{}
html anchor
	callback: [ self call: (MyDisplayStack new setMyStackMachine: stackMachine)];
	with: 'open'
\end{code}
\mb{if the user got a stackmachine ivar, I'm sure he will define
  setStackMachine and not setMyStackMachine}


The callback will cause the current instance of \ct{MyDisplay} to be temporarily replaced by a new instance of \ct{MyDisplayStack} whose job it is to display the complete stack.
When this component signals that it is done (\ie by sending \ct{self answer}), then control will return to the original instance of \ct{MyDisplay}.

\dothis{
Define the rendering method of \ct{MyDisplayStack} to display all of the values on the stack.
(You will either need to define an accessor for the stack machine's \ct{contents} or you can define \ct{MyStackMachine>>>do:} to iterate over the stack values.)
The stack display should also have a button labelled ``close'' whose callback will simply perform \ct{self answer}.
}

\begin{code}{}
html anchor
	callback: [ self answer];
	with: 'close'
\end{code}

Now you should be able to \emph{open} and \emph{close} the stack while you are using the calculator.

There is, however, one thing we have forgotten.
Try to perform some operations on the stack.
Now use the ``back'' button of your browser and try to perform some more stack operations.
(For example, \menu{open} the stack, type \menu{1}, \menu{Enter} twice and \menu {+}.
The stack should display ``2'' and ``1''.
Now hit the ``back'' button.
The stack now shows three times ``1'' again.
Now if you type \menu{+} the stack shows ``3''.
Backtracking is not yet working.

\dothis{
Implement \ct{MyCalculator>>>states} to return 
an array with the contents of the stack machine.
Check that backtracking now works correctly!
}

Sit back and enjoy a tall glass of something cool!

%=================================================================
\section{A quick look at AJAX}

% Original text by Lukas Renggli

\ind{AJAX} (Asynchronous \ind{JavaScript} and \ind{XML}) is a technique to make web applications more interactive by exploiting JavaScript functionality on the client side.

Two well-known JavaScript libraries are \ind{Prototype} (\url{http://www.prototypejs.org}) and \ind{script.aculo.us} (\url{http://script.aculo.us}).
Prototype provides a framework to ease writing JavaScript.
script.aculo.us provides some additional features to support animations and drag-and-drop on top of Prototype.
Both frameworks are supported in Seaside through the package ``Scriptaculous''.

All ready-made images have the Scriptaculous package extensions already loaded.
The latest version is available from \url{http://www.squeaksource.com/Seaside}.
An online demo is available at \url{http://scriptaculous.seasidehosting.st}.
Alternatively, if you have a enabled image running, simply go to \url{http://localhost:8080/seaside/tests/scriptaculous}.

The Scriptaculous extensions follow the same approach as Seaside itself\,---\,simply configure Smalltalk objects to model your application, and the needed Javascript code will be generated for you.

Let us look at a simple example of how client-side Javascript support can make our RPN calculator behave more naturally.
Currently every keystroke to enter a digit generates a request to refresh the page.
We would like instead to handle editing of the display on the client-side by updating the display in the existing page.

\dothis{To address the display from JavaScript code we must first give it a unique id.
Update the calculator's rendering method as follows:\footnote{If you have not implemented the tutorial example yourself, you can simply load the complete example (PBE-SeasideRPN) from \url{http://www.squeaksource.com/PharoByExample} and apply the suggested changes to the classes \ct{RPN*} instead of \ct{My*}.}}

\begin{code}{}
MyCalculator>>>renderContentOn: html
	html div id: 'keypad'; with: keypad.
	html div id: 'display'; with: display.	
\end{code}
				
\dothis{To be able to re-render the display when a keyboard button is pressed, the keyboard needs to know the display component.
Add a \ct{display} instance variable to \ct{MyKeypad}, an initialize method \ct{MyKeypad>>>setDisplay:}, and call this from \ct{MyCalculator>>initialize}.
Now we are able to assign some JavaScript code to the buttons by updating \ct{MyKeypad>>>renderStackButton:callback:colSpan:on:} as follows:}

\begin{code}{}
MyKeypad>>>renderStackButton: text callback: aBlock colSpan: anInteger on: html 
	html tableData
		class: 'key';
		colSpan: anInteger;
		with: [
			html anchor
				callback: aBlock;
				onClick:				"handle Javascript event"
					(html updater
						id: 'display';
						callback: [ :r |
							aBlock value.
							r render: display ];
						return: false);
				with: [ html html: text ] ]
\end{code}

\mthind{WATagBrush}{onClick:} specifies a \ind{JavaScript} event handler.
\ct{html updater} returns an instance of \ct{SUUpdater}, a Smalltalk object representing the JavaScript Ajax.Updater object (\url{http://www.prototypejs.org/api/ajax/updater}).
This object performs an AJAX request and updates a container's contents based on the response text.
\ct{id:} tells the updater what XHTML DOM element to update, in this case the contents of the div element with the id 'display'.
\ct{callback:} specifies a block that is triggered when the user presses the button.
The block argument is a new renderer \ct{r}, which we can use to render the display component.
(Note: Even though html is still accessible, it is not valid anymore at the time this callback block is evaluated).
Before rendering the display component we evaluate \ct{aBlock} to perform the desired action.

\ct{return: false} tells the JavaScript engine to not trigger the original link callback, which would cause a full refresh.
We could instead remove the original anchor \ct{callback:}, but like this the calculator will still work even if JavaScript is disabled.

\dothis{Try the calculator again, and notice how a full page refresh is triggered every time you press a digit key. (The URL of the web page is updated at each keystroke.)}

Although we have implemented the client-side behavior, we have not yet activated it.
Now we will enable the Javascript event handling.

\dothis{
Click on the \link{Configure} link in the toolbar of the calculator.
Select ``Add Library:'' \ct{SULibrary}, click the \button{Add} button and \button{Close}.}

Instead of manually adding the library, you may also do it programmatically when you register the application:
\begin{code}{}
MyCalculator class>>>initialize
	(self registerAsApplication: 'rpn')
		addLibrary: SULibrary}}
\end{code}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{ajax-processing}
\caption{Seaside AJAX processing (simplified)}
\figlabel{ajax-processing}
\end{center}
\end{figure}

\dothis{Try the revised application.  Note that the feedback is much more natural. In particular, a new URL is not generated with each keystroke.}

You may well ask, \emph{yes, but how does this work?}
\figref{ajax-processing} shows how the RPN applications would both without and with AJAX.
Basically AJAX short-circuits the rendering to \emph{only} update the display component.
Javascript is responsible both for triggering the request and updating the corresponding DOM element.
Have a look at the generated source-code, especially the JavaScript code:

\begin{code}{}
new Ajax.Updater(
	'display',
	'http://localhost/seaside/RPN+Calculator',
	{'evalScripts': true,
	  'parameters': ['UNDERSCOREs=zcdqfonqwbeYzkza', 'UNDERSCOREk=jMORHtqr','9'].join('&')});
return false
\end{code}

For more advanced examples, have a further look at \url{http://localhost:8080/seaside/tests/scriptaculous}.

\paragraph{\emph{Hints.}}
In case of server side problems use the Smalltalk debugger.
In case of client side problems use FireFox (\url{http://www.mozilla.com}) with the JavaScript debugger FireBug (\url{http://www.getfirebug.com/}) plugin enabled.

%=================================================================
\section{Chapter summary}

\begin{itemize}
  \item The easiest way to get started is to download the ``Seaside One-Click Experience'' from \url{http://seaside.st}
  \item Turn the server on and off by evaluating \ct{WAKom startOn: 8080} and \ct{WAKom stop}.
  \item Reset the administrator login and password by evaluating \ct{WADispatcherEditor initialize}.
  \item \menu{Toggle Halos} to directly view application source code, run-time objects, CSS and XHTML.
  \item Send \ct{WAGlobalConfiguration setDeploymentMode} to hide the toolbar.
  \item Seaside web applications are composed of components, each of which is an instance of a subclass of \ct{WAComponent}.
  \item Only a root component may be registered as a component. It should implement \ct{canBeRoot} on the class side. Alternatively it may register itself as an application in its class-side \ct{initialize} method by sending \ct{self registerAsApplication:} \emph{application path}.
  If you override \ct{description} it is possible to return a descriptive application name that will be displayed in the configuration editor.
  \item To backtrack state, a component must implement the \ct{states} method to answer an array of objects whose state will be restored if the user clicks the browser's ``back'' button.
  \item A component renders itself by implementing \ct{renderContentOn:}.
  The argument to this method is an XHTML rendering \emph{canvas} (usually called \ct{html}).
  \item A component can render a subcomponent by sending \ct{self render:} \emph{subcomponent}.
  \item XHTML is generated programmatically by sending messages to \emph{brushes}. A brush is obtained by sending a message, such as \ct{paragraph} or \ct{div}, to the html canvas.
  \item If you send a cascade of messages to a brush that includes the message \ct{with:}, then \ct{with:} should be the last message sent.
  Thw \ct{with:} message sets the contents \emph{and} renders the result.
  \item Actions should appear only in callbacks.
You should not change the state of the application while you are rendering it.
  \item You can bind various form widgets and anchors to instance variables with accessors by sending the message \ct{on:} \emph{instance variable} \ct{of:} \emph{object} to the brush.
  \item You can define the CSS for a component hierarchy by defining the method \ct{style}, which should return a string containing the style sheet.
  (For deployed applications, it is more usual to refer to a style sheet located at a static URL.)
  \item Control flows can be programmed by sending \ct{x call: y}, in which case component \ct{x} will be replaced by \ct{y} until \ct{y} answers by sending \ct{answer:} with a result in a callback.
  The receiver of \ct{call:} is usually \ct{self}, but may in general be any visible component.
  \item A control flow can also be specified as a \emph{task}\,---\,a instance of a subclass of \ct{WATask}. It should implement the method \ct{go}, which should \ct{call:} a series of components in a workflow.
  \item Use \ct{WAComponents}'s convenience methods \ct{request:}, \ct{inform:}, \ct{confirm:} and \ct{chooseFrom:caption:} for basic interactions.
  \item To prevent the user from using the browser's ``back'' button to access a previous execution state of the web application, you can declare portions of the workflow to be a \emph{transaction} by enclosing them in an \ct{isolate:} block.
\end{itemize}
%-----------------------------------------------------------------

%=================================================================
\ifx\wholebook\relax\else 
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=================================================================
