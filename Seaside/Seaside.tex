% $Author$
% $Date$
% $Revision$
% $Id$

% HISTORY:
% 2007-10-29 - Oscar started chapter
% 2007-11-30 - Oscar first draft
% 2007-12-07 - Orla Greevy reviewed
% 2007-12-09 - Lukas Renggli reviewed
% 2008-01-11 - Andrew revised
% 2009-04-17 - Fabrizio Perin reviewed
% 2009-04-18 - Jorge Ressia reviewed
% 2009-05-06 - Oscar converted to Pharo; fixed review comments
% 2011-05-29 - Rafael Luque translated to spanish
%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../co	mmon.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
\chapter{Seaside en Ejemplos}
\chalabel{seaside}

\luq{Otras opción posible para el título podría ser: 'Seaside con Ejemplos'}

%=================================================================

\ind{Seaside} es un marco de trabajo para crear aplicaciones web en Smalltalk. Fue desarrollado originalmente por Avi Bryant \index{Bryant, Avi} en 2002; una vez dominado, Seaside hace las aplicaciones web tan fáciles de escribir como las aplicaciones de escritorio.

Dos de las aplicaciones creadas con Seaside más conocidas son \ind{SqueakSource}\footnote{\url{http://SqueakSource.com}} y \ind{Dabble DB}\footnote{\url{http://DabbleDB.com}}.
Seaside es poco común ya que está rigurosamente orientado a objetos: no hay plantillas XHTML, ni complicados controles de flujo a través de páginas web, ni codificación del estado en las URLs. En su lugar, sólo envías mensajes a los objetos. ¡Qué buena idea!

\section{¿Por qué necesitamos Seaside?}

Las aplicaciones web modernas tratan de interactuar con el usuario de la misma manera que las aplicaciones de escritorio: realizan al usuario preguntas y el usuario responde, normalmente rellenando un formulario o pulsando un botón. Pero la web funciona en sentido inverso: el navegador del usuario realiza una petición al servidor y el servidor responde con una nueva página web.

Por lo tanto, los marcos de \ind{desarrollo de aplicaciones web} tienen que tratar con un montón de problemas, siendo el principal de ellos la gestión de este control de flujo ``invertido''.
Por esto, muchas aplicaciones intentan prohibir el uso del botón ``volver atrás'' del navegador, debido a la dificultad de mantener el seguimiento del estado de una sesión.
Expresar un control de flujo no trivial a través de varias páginas normalmente es engorroso y varios flujos de control pueden ser difíciles o imposibles de expresar.

% Seaside is a component-based framework that uses ``\ind{continuations}''\footnote{A \emph{continuation} represents ``the rest of the computation'' at any point in a computation. In Smalltalk, a continuation is just an object that captures the current state of the computation, and which can be resumed at any point.} to keep track of multiple points in the control flow of web applications. Continuations are managed automatically by Seaside, so web developers do not even have to be aware of the underlying machinery. It just works.

\index{Seaside!backtracking de estado}\luq{Traducimos backtracking como vuelta a atrás?}
\index{Seaside!transacciones}
\index{Seaside!componentes}

Seaside es un marco de trabajo basado en componentes que hace el desarrollo web más fácil en varias formas.
Primero, el control de flujo puede expresarse de forma natural usando el envío de mensajes. Seaside realiza el seguimiento de la página web que corresponde con cada punto de ejecución de la aplicación web.
Esto significa que el botón ``volver atrás'' del navegador funciona correctamente.  

Segundo, gestiona el estado en tu lugar.
Como el desarrollador, puedes escoger habilitar el seguimiento del estado, para que la navegación ``hacia atrás'' en el tiempo desahaga los efectos laterales.
Si no, puedes usar el soporte de transacciones incluído en Seaside para evitar que los usuarios deshagan los efectos laterales permanentes cuando usen el botón volver atrás.
No tienes que codificar la información de estado en la URL\,---\,esto también es gestionado automáticamente por ti

Tercero, las páginas web son construídas a partir de componentes anidados, cada uno de los cuales soporta su propio control de flujo independiente.
No hay plantillas XHTML\,---\,sino que se genera XHTML válido programadamente, usando un sencillo protocolo Smalltalk.
Seaside soporta Hojas de Estilo en Cascada (\ind{CSS}), de forma que el contenido y disposición estén claramente separados.
\seeindex{Hojas de Estilo en Cascada}{CSS}

Finalmente, Seaside proporciona una práctica interfaz de desarrollo basada en web, lo que hace fácil desarrollar aplicaciones iterativamente, depurar aplicaciones interactivamente  y recompilar y extender aplicaciones miembras el servidor está ejecutándose.

%=================================================================
\section{Para empezar}

La forma más sencilla de comenzar es descargar ``Seaside \subind{Seaside}{Experiencia en Un Click}'' desde el \subind{Seaside}{sitio web} de Seaside\footnote{\url{http://seaside.st}}.
Esta es una versión preempaquetada de Seaside 2.8 para \ind{Mac OSX}, \ind{Linux} y \ind{Windows}.
El mismo sitio web lista muchas referencias a recursos adicionales, incluyendo documentación y tutoriales.
Te advertimos, sin embargo, de que Seaside ha evolucionado considerablemente con los años y no todo el material disponible se refiere a la última versión de Seaside.


% If you are feeling more adventurous, an alternative to the ``one-click'' image is to start with the latest \ind{\pharo web image}\footnote{\url{http://pharo-project.org/download}}, and install Seaside yourself by following the manual \subind{Seaside}{installation} instructions on the Seaside web site.

Seaside incluye un servidor web; puedes iniciar el servidor, diciéndole que escuche en el puerto 8080, evaluando \clsind{WAKom} \ct{startOn: 8080},
y puedes detenerlo otra vez evaluando \ct{WAKom stop}.
En la instalación por defecto, el \subind{Seaside}{login de administrador} por defecto es \lct{admin} y la contraseña por defecto es \lct{seaside}.
Para cambiarlos, evalúa: \clsind{WADispatcherEditor} \ct{initialize}.
Esto te solicitará un nuevo nombre y contraseña.

\begin{figure}[tbh]
\begin{center}
\includegraphics[width=\textwidth]{seasideStartup}
\caption{Iniciando Seaside}
\figlabel{seasideStartup}
\end{center}
\end{figure}

\dothis{Inicia el servidor Seaside y dirige un navegador web a \url{http://localhost:8080/seaside/}.}

\noindent
Deberías ver una página web como la de la \figref{seasideStartup}.

\noindent
\dothis{Navega a la página \lct{examples{\go}counter} page. (\figref{counter})}

\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.8\textwidth]{counter}
\caption{El contador.}
\figlabel{counter}
\end{center}
\end{figure}

\noindent
Esta página es una pequeña aplicación Seaside: muestra un \subind{Seaside}{contador} que puede ser incrementado o decrementado haciendo click en los enlaces \link{++} y \link{--\,--}.

\noindent
\dothis{Juega con el contador haciendo click en estos enlaces.
Usa el botón ``atrás'' de tu navegador para volver a un estado previo y entonces haz cllick en \link{++} otra vez.
Fíjate cómo el contador se incrementa correctamente con respecto al estado mostrado en ese momento, en lugar del estado en que estaba cuando usaste el botón ``volver''.} 

Fíjate en la \subind{Seaside}{barra de herramientas} al final de la página web en la \figref{seasideStartup}.
Seaside soporta una noción de ``sesiones'' para realizar el seguimiento del estado de la aplicación para diferentes usuarios.
\button{New Session} comenzará una nueva sesión en la aplicación contador.
\button{Configure} permite configurar los ajustes de tu aplicación a través de una cómoda interfaz web.
(Para cerrar la vista \button{Configure}, pulsa en la \link{x} en la esquina superior derecha.)
\button{Toggle Halos} proporciona una forma de explorar el estado de la aplicación ejecutándose en el servidor Seaside.
\button{Profiler} y \button{Memory} proporcionan información detallada sobre el rendimiento de la aplicación en tiempo de ejecución.
\button{XHTML} puede usarse para validar la página web generada, pero sólo funciona cuando la página web es públicamente accesible en Internet porque usa el servicio de validación del W3C.
\index{Seaside!halos}

Las aplicaciones Seaside se construyen a partir de ``componentes'' conectables.
De hecho, los componentes son objetos normales de Smalltalk.
Lo único que tienen de especial es que deben ser instancias de clases que heredan de la clase \ct{WAComponent} del marco de trabajo Seaside.
Podemos explorar los componentes y sus clases desde la imagen \pharo o directamente desde la interfaz web usando los halos.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{counterHalos}
\caption{Halos}
\figlabel{counterHalos}
\end{center}
\end{figure}

\dothis{Selecciona \button{Toggle Halos}. Deberías ver una página web como la de la \figref{counterHalos}.
En la esquina superior izquierda el texto \ct{WACounter} indica la clase del componente Seaside que implementa el comportamiento de esta página web.
Junto a este, hay tres iconos que puedes pulsar.
El primero, con el lápiz, activa el navegador de clases de Seaside sobre esta clase.
El segundo, con la lupa, abre un inspector de objetos sobre la instancia \ct{WACounter} actualmente activa.
El tercero, con los circulos de color, muestra la hoja de estilos \ind{CSS} para este componente.
En la esquina superior derecha, la \link{R} y \link{S} te permiten conmutar entre las vistas renderizadas y fuente de la página web.
Experimenta con todos estos enlaces.
Ten en cuenta que los vínculos \link{++} y \link{--} también están activos en la vista fuente.
Compara la vista fuente correctamente formateada que proporciona los Halos con la vista fuente sin formato ofrecida por tu navegador.}

El navegador de clases y el inspector de objetos de Seaside pueden ser muy útiles cuando el servidor está ejecutándose en otro ordenador, especialmente cuando el servidor no tiene pantalla o está en un lugar remoto.
Sin embargo, cuando desarrollas una aplicación Seaside por vez primera, el servidor estará ejecutándose localmente y es fácil usar las herramientas de desarrollo normales de \pharo en la imagen del servidor.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.7\textwidth]{haltingCounter}
\caption{Deteniendo el contador}
\figlabel{haltingCounter}
\end{center}
\end{figure}

\dothis{Usando el enlace del inspector de objetos en el navegador web, abrir un inspector sobre el objeto contador de Smalltalk subyacente y evaluar \ct{self halt}.
La página web detendrá la carga.
Ahora cambia a la imagen de Seaside.
Deberías ver una ventana de pre-depurador (\figref{haltingCounter}) mostrando un objeto \ct{WACounter} ejecutando un \ct{halt}.
Examina la ejecución en el depurador y entonces \button{Proceed}.
Vuelve al navegador web y fíjate en que la aplicación contador está ejecutándose otra vez.}

Los componentes de Seaside pueden instanciarse varias veces y en diferentes contextos.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{multiCounterHalos}
\caption{Subcomponentes independientes}
\figlabel{multiCounterHalos}
\end{center}
\end{figure}

\dothis{Dirige tu navegador web a \url{http://localhost:8080/seaside/examples/multicounter}.
Verás una aplicación formada por un número de instancias independientes del componente contador.
Incrementa y decrementa varios de los contadores.
Verifica que se comportan correctamente incluso si usas el botón ``atrás''.
Activa los halos para ver cómo la aplicación está formada por componentes anidados.
Usa el navegador de clases de Seaside para ver la implementación de  \ct{WAMultiCounter}.
Deberías ver tres métodos en el lado de clase (\ct{canBeRoot}, \ct{description} e \ct{initialize}) y tres en el lado de instancia (\ct{children}, \ct{initialize} y \ct{renderContentOn:}).
Observa que una aplicación es simplemente un componente dispuesto a ser la raíz de la jerarquía de componentes; esta predisposición se indica definiendo un método de clase \ct{canBeRoot} que responda \ct{true}.}
\index{Seaside!multi contador}

Puedes usar la interfaz web de Seaside para configurar, copiar o eliminar aplicaciones individuales (es decir, componentes del nivel raíz). Inteta realizar el siguiente cambio de configuración.

\dothis{Dirige tu navegador web a  \url{http://localhost:8080/seaside/config}.
Introduce el login y contraseña (\ct{admin} y \ct{seaside} por defecto).
Selecciona \link{Configure} junto a ``examples.''
Bajo la cabecera ``Add entry point'', introduce el nuevo nombre ``counter2'' para el tipo \emph{Application} y pulsa sobre \button{Add} (ver \figref{counter2}).
En la siguiente pantalla, cambia \emph{Root Component} a \clsind{WACounter}, entonces haz click en \button{Save} y \button{Close}.
Ahora tenemos un nuevo contador instalado en  \url{http://localhost:8080/seaside/examples/counter2}.
Usa la misma interfaz de configuración para eliminar este punto de entrada.
}
\index{Seaside!configuración}


\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{counter2}
\caption{Configuración de una nueva aplicación}
\figlabel{counter2}
\end{center}
\end{figure}

Seaside opera en dos modos: el modo \emph{desarrollo}, que es el que hemos visto hasta ahora, y el modo \emph{despliegue}, en el que la barra de herramientas no está disponible.
\index{Seaside!modo desarrollo}
\index{Seaside!modo despliegue}
Puedes poner Seaside en el modo despliegue usando la página de configuración (navega a la entrada para la aplicación y haz click en el enlace \link{Configure})
% \ab{How?  I couldn't find this}
o haciendo click en el botón \button{Configure} en la barra de herramientas.
En cualquier caso, se pone el modo despliegue a \emph{true}.
Observa que esto sólo afecta a las nuevas sesiones.
También puedes poner el modo globalmente evaluando
\clsind{WAGlobalConfiguration} \lct{setDeploymentMode}
o
\ct{WAGlobalConfiguration setDevelopmentMode}.
\index{Seaside!modo desarrollo}
\index{Seaside!modo despliegue}

La página web de configuración sólo es otra aplicación Seaside por lo que también puede ser controlada desde la página de configuración.
Si eliminas la aplicación ``config'', puedes recuperarla evaluando
\clsind{WADispatcherEditor} \ct{initialize}.

%=================================================================
\section{Componentes Seaside}
\seclabel{componentes}

%\ab{This section was too long\,---\,18 pages.  It also contained several self-references (``see section 1.3''). So I broke into smaller sections, by promoting some of the subsections and subsubsections.}

Como hemos mencionado en la sección anterior, las aplicaciones Seaside se construyen con \emph{\subind{Seaside}{componentes}}.
Vamos a estudiar detenidamente cómo funciona Seaside implementando el componente \emph{Hello World}.

Todo componente Seaside debe heredar directa o indirectamente de \clsind{WAComponent}, como muestra la figura \figref{WACounter}.

\dothis{Define una subclase de \ct{WAComponent} llamada \ct{WAHelloWorld}.}

Los componentes deben saber cómo representarse a sí mismos.
Normalmente esto se hace implementando el método \mthind{WAPresenter}{renderContentOn:}, que recibe como argumento una instancia de \clsind{WAHtmlCanvas}, que sabe cómo generar XHTML.
\index{Seaside!representación}

\dothis{Implementa el siguiente método y ponlo en un protocolo llamado \prot{rendering}:}

\needlines{2}
\begin{code}{}
WAHelloWorld>>>renderContentOn: html
	html text: 'hello world'
\end{code}

\noindent
Ahora debemos informar a Seaside de que este componente está dispuesto a ser una aplicación independiente.

\dothis{Implementa el siguiente método de clase de \ct{WAHelloWorld}.}

\begin{code}{}
WAHelloWorld class>>>canBeRoot
	^ true
\end{code}

\noindent
¡Estamos a punto de acabar!

\dothis{Dirige tu navegador web a \url{http://localhost:8080/seaside/config}, añade un nuevo punto de entrada llamado ``hello'' y pon como su componente raíz \ct{WAHelloWorld}.
Ahora dirige tu navegador a \url{http://localhost:8080/seaside/hello}.
!Ya está! Deberías ver una página web como la de la figura \figref{WAHelloWorld}.}


\begin{figure}[htb]
\begin{center}
\includegraphics[width=\textwidth]{WAHelloWorld}
\caption{``Hello World'' en Seaside}
\figlabel{WAHelloWorld}
\end{center}
\end{figure}

%-----------------------------------------------------------------
\subsection{Marcha atrás de estado y la aplicación ``Counter''}
%{Simple and nested components}

La aplicación ``counter'' es sólo ligeramente más compleja que la aplicación ``hello world''.
\seclabel{backtracking}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{WACounter}
\caption{La clase \ct{WACounter}, que implementa la aplicación \emph{counter}. Los métodos con nombres subrayados son de clase; aquellos con nombres en texto normal son de instancia.}
\figlabel{WACounter}
\end{center}
\end{figure}

La clase \clsind{WACounter} es una aplicación independiente, con lo que la clase \ct{WACounter} debe responder \ct{true} al mensaje \mthind{WAComponent class}{canBeRoot}.
También debe registrarse como una aplicación; esto se hace en su método de clase \ct{initialize}, como muestra la figura \figref{WACounter}.
\ct{WACounter} define dos métodoso, \ct{increase} y \ct{decrease}, que serán disparados desde los vínculos \link{++} y \link{--\,--} de la página web.
También define una variable de instancia \ct{count} para registrar el estado del contador.
Sin embargo, también queremos que Seaside sincronice el contador con la página del navegador: cuando el usuario hace click en el botón ``atrás'' del navegador, queremos que Seaside ``retroceda'' el estado del objeto \ct{WACounter}.
Seaside incluye un mecaniso general de vuelta a atrás, pero cada aplicación tiene que decirle a Seaside qué partes de su estado tiene que seguir.

Un componente habilita la vuelta a atrás implementando el método \ct{states} en el lado de instancia:
% \ab{note that xspace messes up again, by inserting a space at the start of this line}
\ct{states} debería devolver un array que contenga todos los objetos a seguir.
En este caso, el objeto \ct{WACounter} se añade él mismo a la tabla de objetos que pueden retrocederse de Seaside Seaside devolviendo \ct{Array with: self}.

\paragraph{\emph{Advertencia.}}
Hay un punto sutil pero importante al que estar atento cuando se declaran objetos para retroceder.
Seaside sigue el estado haciendo una \emph{copia} de todos los objetos declarados en el array \ct{states}.
Hace esto usando un objeto \clsind{WASnapshot}; \ct{WASnapshot} es una subclase de \clsind{IdentityDictionary} que registra los objetos a seguir como claves y copias superficiales de su estado como valores.
\luq{\emph{shallow copy} como copia superficial}

Si el estado de una aplicación da marcha atrás a una instantánea particular, el estado de cada objeto que se añadió al diccionario de instantáneas se sobreescribe por la copia guardada en la instantánea. 
\luq{\emph{snapshot} traducido como instantánea}

El aspecto al que hay que estar atento es el siguiente:
En el caso de \ct{WACounter}, podrías pensar que el estado a seguir es un número\,---\,el valor de la variable de instancia \ct{count}.
Sin embargo, hacer que el método \ct{states} retorne \ct{Array with: count} no funcionará.  
Esto es así porque el objeto nombrado por \ct{count} es un entero y los enteros son inmutables.
Los métodos \ct{increase} y \ct{decrease} no cambian el estado del objeto \ct{0} a \ct{1} o el objeto \ct{3} a \ct{2}.
En cambio, \ct{count} nombra un entero diferente: 
cada vez que count se incrementa o decrementa, el objeto nombrado por \ct{count} es \emph{reemplazado} por otro.
Por esto es por lo que \ct{WACounter>>>states} debe retornar \ct{Array with: self}.
Cuando el estado de un objeto \mbox{\ct{WACounter}} es reemplazado por un estado previo, el \emph{valor} de cada una de las variables de instancia en el objeto es reemplazado por un valor previo; este reemplaza correctamente el valor actual de \ct{count} por un valor anterior. 
\index{Seaside!vuelta atrás del esstado}
\index{WAPresenter!states@\ct{states}}

\section{Generando XHTML}

El propósito de una aplicación web es crear o ``presentar'' páginas web.  Como mencionamos en \secref{components}, cada componente Seaside es responsable de presentarse a sí mismo.  
Así pues, vamos a comenzar nuestra exploración de la presentación viendo cómo el componente contador se presenta a sí mismo.

\subsection{Presentando el Contador}

La presentación del contador es relativamente directa; el código se muestra en la figura \figref{WACounter}.
El valor actual del contador se muestra como una cabecera XHTML, y las operaciones de incrementar y decrementar se implementan como anclas html (es decir, vínculos) con retrollamadas a bloques que enviarán \ct{increase} y \ct{decrease} al objeto contador.
\luq{\emph{callback} como retrollamada}

Echaremos un vistazo más de cerca al protocolo de presentación en un momento.
Pero antes de hacerlo, echemos un vistazo rápido al \subind{Seaside}{multi-contador}.

\subsection{De Contador a Multicontador}

\ct{WAMultiCounter} que se muestra en la figura \figref{WAMultiCounter} también es una aplicación independiente, con lo que sobreescribe \mthind{WAComponent class}{canBeRoot} para responder \ct{true}.
Además, es un componente \emph{compuesto}, con lo que Seaside requiere que declare sus hijos implementando un método \ct{children} que responda con un array con todos los componentes que contiene.
Se presenta a sí mismo presentando cada uno de sus subcomponentes, separados por una línea horizontal.
Además de los métodos de inicialización de instancia y estáticos, no hay nada más en el multicontador.

\begin{figure}[bht]
\begin{center}
\includegraphics[width=\textwidth]{WAMultiCounter}
\caption{WAMultiCounter}
\figlabel{WAMultiCounter}
\end{center}
\end{figure}

%-----------------------------------------------------------------
\subsection{Más sobre la Presentación XHTML}

Como puedes ver en estos ejemplos, Seaside no usa plantillas para generar páginas web.
En su lugar, genera XHTML programadamente.
La idea básica es que cada componente Seaside debería sobreescribir el método \mthind{WAPresenter}{renderContentOn:}; este mensaje será enviado por el marco de trabajo a cada componente que necesita ser presentado.
Este mensaje \ct{renderContentOn:} tendrá un argumento que es un \seeindex{lienzo}{lienzo html} \emphind{lienzo html} sobre el que el componente debe presentarse a sí mismo. Por convenio, el parámetro del lienzo html se llama \ct{html}.

Un lienzo html es análogo al lienzo gráfico usado por Morphic (y la mayoría de otros marcos de trabajo de dibujo) para abstraerse de los detalles dependientes del dispositivo de dibujo.
 
Estos son algunos de los métodos de presentación más básicos:
\begin{code}{}
html text: 'hello world'.  "presenta una cada de texto plano"
html html: '&ndash;'.     "presenta un conjuro XHTML"
html render: 1.              "presenta cualquier objeto"
\end{code}

El mensaje \ct{render: anyObject} se puede enviar a un lienzo html para presentar \ct{anyObject}; se utiliza normalmente para presentar subcomponentes. A \lct{anyObject} se le enviará el mensaje \ct{renderContentOn:}
esto es lo que ocurre en el multi-contador (ver la \figref{WAMultiCounter}).

\subsection{Usando Pinceles}
\seclabel{brushes}

Un lienzo proporciona un número de \emphind{pinceles} que pueden usarse para presentar (\ie ``pintar) contenido en el lienzo.
Hay lienzos para cada tipo de elemento XHTML \,---\,párrafos, tablas, listas y demás.
Para ver el protocolo completo de lienzos y métodos de utilidad, deberías navegar por la clase \clsind{WACanvas} y sus subclases.
El argumento para \ct{renderContentOn:} es realmente una instancia de la subclase \clsind{WARenderCanvas}.

Ya hemos visto el siguiente pincel utilizado en los ejemplos contador y multi-contador:
\needlines{2}
\begin{code}{}
html horizontalRule.
\end{code}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{RenderingDemo}
\caption{RenderingDemo}
\figlabel{RenderingDemo}
\end{center}
\end{figure}

En la figura \figref{RenderingDemo} podemo ver la salida de muchos de los pinceles básicos ofrecidos por Seaside.\footnote{El código fuente para \mthref{renderdemo} está en el paquete \ct{PBE-SeasideDemo} en el proyecto \url{http://www.squeaksource.com/PharoByExample}.}
El componente raíz \ct{SeasideDemo} simplemente presenta sus subcomponentes, que son instancias de \ct{SeasideHtmlDemo}, \ct{SeasideFormDemo}, \ct{SeasideEditCallDemo} y \ct{SeasideDialogDemo}, como se muestra en \mthref{renderdemo}.

\needspace{7ex}
\begin{code}[renderdemo]{\lct{SeasideDemo>>renderContentOn:}}
SeasideDemo>>>renderContentOn: html
	html heading: 'Rendering Demo'.
	html heading
		level: 2;
		with: 'Rendering basic HTML: '.
	html div
		class: 'subcomponent';
		with: htmlDemo.
	"render the remaining components ..."
\end{code}

\noindent
Recuerda que un componente raíz debe siempre declarar sus hijos o Seaside rechazará presentarlos.
\begin{code}{}
SeasideDemo>>>children
	^ { htmlDemo . formDemo . editDemo . dialogDemo }
\end{code}

Ten en cuenta que hay dos formas distintas de instanciar el pincel \ct{heading}.
La primera forma es establecer el texto directamente enviando el mensaje \ct{heading:}.
La segunda forma es instanciar el pincel enviando \ct{heading} y entonces enviar una cascada de mensajes al pincel para establecer sus propiedades y presentarlo.

Muchos de los pinceles disponibles pueden usarse de estas dos formas.

\important{Si envías una \ind{cascada} de mensajes al pincel, incluyendo el mensaje \mthind{WABrush}{with:}, entonces \ct{with:} debería ser el mensaje \emph{final}.
\ct{with:} establece el contenido y presenta el resultado.}

En \mthref{renderdemo}, la primera cabecera está al nivel 1, ya que este es el valor por defecto.
Explícitamente ponemos el nivel de la segunda cabecera a 2.
El subcomponente es presentado como un \emph{div} XHTML con la clase \ind{CSS} ``subcomponent''.
(Más sobre CSS en \secref{css}.)
También ten en cuenta que es necesario que el argumento para el mensaje de palabra clave \ct{with:} no sea una cadena literal: puede ser otro componente, o incluso\,---\,como en el siguiente ejemplo\,---\,un bloque conteniendo más acciones de presentación.

El componente \ct{SeasideHtmlDemo} demuestra muchos de los pinceles más básicos.
La mayoría del código debería explicarse por sí solo.

\begin{code}{}
SeasideHtmlDemo>>>renderContentOn: html 
	self renderParagraphsOn: html.
	self renderListsAndTablesOn: html.
	self renderDivsAndSpansOn: html.
	self renderLinkWithCallbackOn: html
\end{code}

Es una práctica común dividir métodos de presentación largos en muchos métodos auxiliares, como hemos hecho aquí.

\important{No pongas todo tu código de presentación en un único método.
Divídelo en métodos auxiliares nombrados usando el patrón \ct{render*On:}.
Todos los métodos de presentación van en el protocolo \prot{rendering}.
No envíes \ct{renderContentOn:} desde tu propio código, usa \ct{render:} en su lugar.}

Mira el siguiente código.
El primer método auxiliar, \ct{SeasideHtmlDemo>>>renderParagraphsOn:}, muestra cómo generar párrafos XHTML, texto plano y enfatizado e imágenes.
Ten en cuenta que en Seaside los elementos sencillos son presentados especificando el texto que contienen directamente, mientras que los elementos complejos se especifican usando bloques.
Este es un convenio sencillo para ayudatte a estructurar tu código de presentación.

\begin{code}{}
SeasideHtmlDemo>>>renderParagraphsOn: html 
	html paragraph: 'Un parrafo con texto plano.'.
	html paragraph: [
		html
			text: 'Un parrafo con texto plano seguido por una nueva linea. ';
			break;
			emphasis: 'Texto con enfasis ';
			text: 'seguido por una linea horizontal.';
			horizontalRule;
			text: 'Una URI de imagen: '.
		html image
			url: self squeakImageUrl;
			width: '50']
\end{code}

El siguiente método auxiliar, \ct{SeasideHtmlDemo>>>renderListsAndTablesOn:}, muestra cómo generar listas y tablas.
Una tabla usa dos niveles de bloques para mostrar cada una de sus filas y las celdas dentro de las filas.

\begin{code}{}
SeasideHtmlDemo>>>renderListsAndTablesOn: html 
	html orderedList: [
		html listItem: 'Un elemento de una lista ordenada'].
	html unorderedList: [
		html listItem: 'Un elemento de una lista desordenada'].
	html table: [
		html tableRow: [
			html tableData: 'Una tabla con una celda de datos.']]
\end{code}

El siguiente ejemplo muestra cómo podemos especificar \emph{div}s y \emph{span}s con atributos CSS \emph{class} o \emph{id}.
Por supuesto, los mensajes \ct{class:} e \ct{id:} también pueden enviarse a los otros pinceles, no sólo a \emph{div}s y \emph{span}s.
El método \ct{SeasideDemoWidget>>>style} define cómo deberían ser mostrados estos elementos XHTML (ver \secref{css}).

\begin{code}{}
SeasideHtmlDemo>>>renderDivsAndSpansOn: html 
	html div
		id: 'author';
		with: [
			html text: 'Texto plano con un div con id ''author''. '.
			html span
				class: 'highlight';
				with: 'Un span con class ''highlight''.']
\end{code}

Finalmente vemos un sencillo ejemplo de un vínculo, creado asociando una sencilla \subind{Seaside}{retrollamada} con un ``ancla'' (\ie un vínculo).
Hacer click en el vínculo causará que el texto a continuación cambie entre ``true'' y ``false'' cambiando la variable de instancia \ct{toggleValue}.

\needlines{3}
\begin{code}{}
SeasideHtmlDemo>>>renderLinkWithCallbackOn: html 
	html paragraph: [
		html text: 'Un ancla con una accion local: '.
		html span with: [
			html anchor
				callback: [toggleValue := toggleValue not];
				with: 'cambia el booleano:'].
		html space.
		html span
			class: 'boolean';
			with: toggleValue ]
\end{code}

\important{Ten en cuenta que las acciones deberían aparecer sólo en retrollamadas.
¡El código ejecutado durante la presentación no debería cambiar el estado de la aplicación!}

%-----------------------------------------------------------------
\subsection{Formularios}

Los formularios se presentan igual que los otros ejemplos que ya hemos visto.
Este es el código para el componente \ct{SeasideFormDemo} de la figura \figref{RenderingDemo}.
\index{Seaside!formularios XHTML}

\begin{code}{}
SeasideFormDemo>>>renderContentOn: html
	| radioGroup |
	html heading: heading.
	html form: [
		html span: 'Cabecera: '.
		html textInput on: #heading of: self.
		html select
			list: self colors;
			on: #color of: self.
		radioGroup := html radioGroup.
		html text: 'Radio on:'.
		radioGroup radioButton
			selected: radioOn;
			callback: [radioOn := true].
		html text: 'off:'.
		radioGroup radioButton
			selected: radioOn not;
			callback: [radioOn := false].
		html checkbox on: #checked of: self.
		html submitButton
			text: 'hecho' ]
\end{code}{}

Puesto que un formulario es una entidad compleja, se presenta usando un bloque.
Ten en cuenta que todos los cambios de estado ocurren en las retrollamadas, no como parte de la presentación.

Hay una característica de Seaside utilizada aquí que merece una mención especial, que es el mensaje \mthind{WAAnchorTag}{on:of:}.
En el ejemplo, este mensaje se usa para asociar un campo de entrada de texto con la variable \ct{heading}.
Anclas y botones también soportan este mensaje.
El primer argumento es el nombre de una variable de instancia para la que se han definido métodos de acceso; el segundo argumento es el argumento al que esta variable de instancia pertenece.
Ambos métodos de acceso, observador (\ct{heading}) y modificador (\ct{heading:}) son comprendidos por el objeto con el convenio de nombre habitual.
En este caso de un campo de entrada de texto, esto nos ahorra el problema de tener que definir una retrollamada que actualice el campo además de tener que asociar los contenidos por defecto del campo de entrada html con el valor actual de la variable de instancia.
Usando \ct{on: #heading of: self}, la variable \ct{heading} se actualiza automáticamente cuando el usuario actualiza el campo de entrada de texto.

El mismo mensaje se usa dos veces más en este ejemplo, para causar que la selección de un color en el formulario html actualice la variable \ct{color}, y para asociar el resultado del checkbox con la variable \ct{checked}.
Muchos otros ejemplos pueden encontrarse en los tests funcionales de Seaside.
Echa un vistazo a la categoría \scat{Seaside-Tests-Functional}, o simplemente dirige tu navegador a \url{http://localhost:8080/seaside/tests/alltests}.
Selecciona \menu{WAInputTest} y haz click en el botón \button{Restart} para ver la mayoría de las características de los formularios.

No olvides que si activas \button{Toggle Halos}, puedes navegar directamente por el código fuente de los ejemplos usando el navegador de clases de Seaside.

%-----------------------------------------------------------------
\section{CSS: Hojas de estilo en cascada}
\seclabel{css}

%\ab{I think that it just needs a few paragraphs telling the reader the key ideas behind CSS, and the new terminology that the CSS folks introduce, before going in to the details of how you define their "thingies".  Now I have forgotten what they call their "thingies" --- I know that there are effectively paragraph styles (divs) and character styles (spans), but I've forgotten what they call them.  So, I think that the text needs to tell the reader, for each thingie, (1) the CSS concept behind the thingie, (2) what it looks like in a CSS style sheet , (3) what it looks like in html, and (4) how to do it in Seaside.   Maybe (3) can be omitted, because it's not needed to use Seaside.}
% \on{I think we do most of that already.}

Las hojas de estilo en cascada\footnote{\url{http://www.w3.org/Style/CSS/}}, o \ind{CSS} para abreviar, han surgido como una forma estándar de separar el estilo del contenido para las aplicaciones web.
Seaside se basa en CSS para evitar llenar tu código de presentación con consideraciones de diseño.

Puedes establecer la hoja de estilos CSS para tus componentes web definiendo el método \ct{style}, que debería devolver una cadena conteniendo las reglas CSS para ese componente.
Los estilos de todos los componentes mostrados en una página web se unen entre sí, con lo que cada componente puede tener su propio estilo.
Una mejor aproximación puede ser definir una clase abstracta para tu aplicación web que defina un estilo común para todas sus subclases.

En realidad, para las aplicaciones desplegadas, es más habitual definir las hojas de estilos como archivos externos.
De esta forma el aspecto del componente está completamente separado de su funcionalidad.
(Echa un vistazo a \clsind{WAFileLibrary}, que proporciona un modo de servir archivos estáticos sin la necesidad de un servidor independiente.)

Si ya estás familiarizado con CSS, esto es todo lo que necesitas saber.
En caso contrario, continúa leyendo una breve descripción de CSS.

En lugar de codificar directamente los atributos de presentación en los elementos de texto y párrafos de tus páginas web, con CSS definirás diferentes clases de elementos y colocarás todas las consideraciones de presentación en una hoja de estilos separada.
Las entidades de tipo párrafo se llaman \emph{div}s y las entidades de tipo texto son \emph{span}s. 
Entonces se definen nombres simbólicos, como ``highlight'' (ver ejemplo de abajo), para el texto resaltado y se especifica en la hoja de estilos cómo se va a presentar el texto resaltado.

Fundamentalmente una hoja de estilos CSS consiste en un conjunto de reglas que especifican cómo formatear los elementos XHTML dados.
Cada regla consta de dos partes.
Existe un \emph{selector} que especifica a qué elementos XHTML aplica la regla y una \emph{declaración} que define un número de atributos para esos elementos.

\begin{figure}[tb]
\begin{code}{}
SeasideDemoWidget>>>style
	^ '
body {
	font: 10pt Arial, Helvetica, sans-serif, Times New Roman;
}
h2 {
	font-size: 12pt;
	font-weight: normal;
	font-style: italic;
}
table { border-collapse: collapse; }
td {
	border: 2px solid #CCCCCC;
	padding: 4px;
}
#author {
	border: 1px solid black;
	padding: 2px;
	margin: 2px;
}
.subcomponent {
	border: 2px solid lightblue;
	padding: 2px;
	margin: 2px;
}
.highlight { background-color: yellow; }
.boolean { background-color: lightgrey; }
.field { background-color: lightgrey; }
'
\end{code}
\caption{Hoja de estilo común de \lct{SeasideDemoWidget}.
\figlabel{democss}}
\end{figure}

La \figref{democss} representa una hoja de estilo sencilla para la demo de presentación mostrada anteriormente en la \figref{RenderingDemo}.
La primera regla especifica una preferencia para la tipografía a utilizar por el \ct{body} de la página web.
Las siguientes reglas especifican propiedas de las cabeceras de segundo nivel (\ct{h2}), tablas (\ct{table}) y datos de las tablas (\ct{td}).

El resto de reglas tienen selectores que corresponden con los elementos XHTML que tengan los atributos ``class'' o``id''.
Los selectores CSS para los atributos clase comienzan con un ``\ct{.}'' y aquellos para los atributos id con ``\ct{#}''.
La principal diferencia entre los atributos clase e id es que muchos elementos pueden tenir la misma clase, pero sólo un elemento muy tener un id dado (\ie un \emph{identificador}). 
Así que, mientras un atributo clase, como \ct{highlight}, puede aparecer varias veces en cualquier página, un id debe identificar un elemento \emph{único} en la página, como un menú particular, la fecha de modificación o el autor.
Ten en cuanta que un elemento XHTML concreto puede tener varias clases, en cuyo caso todos los atributos de presentación se aplicarán en secuencia.

% This style sheet expects at most one element to specify the \emph{author} of the web page.

Las condiciones de los selectores pueden combinarse, con lo que el selector \ct{div.subcomponent} sólo se aplicará a aquellos elementos XHTML que sean un div \emph{y} tengan una atributo clave igual a ``subcomponent''.

También es posible especificar elementos anidados, aunque rara vez es necesario.
Por ejemplo, el selector ``\ct{p span}'' aplicará a un span dentro de un párrafo, pero no dentro de un div.

Existen muchos libros y sitios web que pueden ayudarte a aprender CSS.
Para una espectacular demostración del poder de CSS, te recomendamos que eches un vistazo al Jardín Zen CSS\footnote{\url{http://www.csszengarden.com/}}, que muestra cómo el mismo contenido puede presentarse de maneras radicalmente diferentes simplemente cambiando la hoja de estilos CSS.

%-----------------------------------------------------------------
\section{Gestión del control del flujo}

Seaside hace especialmente fácil diseñar aplicaciones web con un control de flujo no trivial.
Fundamentalmente existen dos mecanismos que puedes utilizar:

\begin{enumerate}
  \item Un componente puede \emph{llamar} a otro componente enviando \ct{visitante call: visitado}.
El visitante es reemplazado temporalmente por el visitado, hasta que el visitado devuelve el control enviando \ct{answer:}.
El visitante normalmente es \ct{self}, pero también podría ser cualquier otro componente visible actualmente.

  \item Un flujo de trabajo puede definirse como una \emphsubind{Seaside}{tarea}.
  Esta es un caso especial de componente que hereda de \clsind{WATask} (en lugar de \clsind{WAComponent}). \seclabel{tarea}
  En lugar de definir \ct{renderContentOn:}, no define ningún contenido, sino que define un método \ct{go} que envía una serie de mensajes \ct{call:} para activar varios subcomponentes.
\end{enumerate}
\index{Seaside!control de flujo}

%-----------------------------------------------------------------
\subsection{LLamada y respuesta}

Llamada y respuesta se usan para producir diálogos sencillos.

Hay un ejemplo trivial de \ct{call:} y \ct{answer:} en la demo de presentación de la \figref{RenderingDemo}.
El componente \ct{SeasideEditCallDemo} muestra un campo de texto y un vínculo \emph{edit}.
La retrollamada para el vínculo \emph{edit} llama a una nueva instancia de \ct{SeasideEditAnswerDemo} inicializada con el valor del campo de texto.
La retrollamada también actualiza este campo de texto con el resultado que se envía como respuesta.

(Subrayamos los mensajes \ct{call:} y \ct{answer:} enviados para llamar la atención sobre ellos.)

\begin{code}{}
SeasideEditCallDemo>>>renderContentOn: html 
	html span
		class: 'field';
		with: self text.
	html space.
	html anchor
		callback: [self text: (self !\underline{call:}! (SeasideEditAnswerDemo new text: self text))];
		with: 'edit'
\end{code}{}

Lo que resulta especialmente elegante es que el código no hace absolutamente ninguna referencia a la nueva página web que debe crearse.
En tiempo de ejecución, se crea una nueva página en la que el componente \ct{SeasideEditCallDemo} es reemplazado por un componente \ct{SeasideEditAnswerDemo}; el componente padre y el resto de componentes no se ven modificados.

\important{\mthind{WAComponent}{call:} y \mthind{WAComponent}{answer:} nunca deben usarse durante la presentación.
Pueden ser enviados de forma segura desde una \subind{Seaside}{retrollamada} o desde el método \mthind{WATask}{go} de una tarea.}

El componente \ct{SeasideEditAnswerDemo} también es extraordinariamente sencillo.
Simplemente presenta un formulario con un campo de texto.
El botón de envío está vinculado con una retrollamada que responderá el valor final del campo de texto.

\begin{code}{}
SeasideEditAnswerDemo>>>renderContentOn: html
	html form: [
		html textInput
			on: #text of: self.
		html submitButton
			callback: [ self !\underline{answer:}! self text ];
			text: 'ok'.
		]
\end{code}{}

Eso es todo.

Seaside se ocupa del control del flujo y de la correcta presentación de todos los componentes.
Curiosamente, el botón ``volver'' del navegador también funcionará correctamente (aunque los efectos colaterales no se deshacen a no ser que añadamos algunos pasos adicionales).

%-----------------------------------------------------------------
\subsection{Métodos de utilidad}
\luq{convenience methods como métodos de utilidad?}

Puesto que ciertos diálogos llamada--respuesta son muy comunes, Seaside proporciona algunos métodos de utilidad para ahorrarte el problema de escribir componentes como \ct{SeasideEditAnswerDemo}.
Los diálogos generados se muestran en la \figref{dialogs}.
Podemos ver los métodos de utilidad empleados en \ct{SeasideDialogDemo>>>renderContentOn:}
\index{Seaside!métodos de utilidad}

\begin{figure}[b]
\begin{center}
\includegraphics[width=\textwidth]{dialogs}
\caption{Algunos diálogos estándar}
\figlabel{dialogs}
\end{center}
\end{figure}

El mensaje \mthind{WAComponent}{request:} realiza una llamada a un componente que te permitirá editar un campo de texto.
El componente responde con la cadena editada.
También pueden especificarse opcionalmente una etiqueta y un valor por defecto.

\needlines{3}
\begin{code}{}
SeasideDialogDemo>>>renderContentOn: html
	html anchor
		callback: [ self request: 'edit this' label: 'done' default: 'some text' ];
		with: 'self request:'.
...
\end{code}

El mensaje \mthind{WAComponent}{inform:} llama a un componente que simplemente muestra el mensaje del argumento y espera a que el usuario pulse en ``ok''.
El componente llamada simplemente retorna \ct{self}.

\begin{code}{}
...
	html space.
	html anchor
		callback: [ self inform: 'yesBANG' ];
		with: 'self inform:'.
...
\end{code}

El mensaje \mthind{WAComponent}{confirm:} realiza una pregunta y espera a que el usuario seleccione ``Yes'' o ``No''.
El componente responde con un booleano, que puede utilizarse para realizar otras acciones.

\begin{code}{}
...
	html space.
	html anchor
		callback: [
			(self confirm: 'Are you happy?')
				ifTrue: [ self inform: ':-)' ]
				ifFalse: [ self inform: ':-(' ]
			];
		with: 'self confirm:'.
\end{code}

Algunos otros métodos de utilidad, como \mthind{WAComponent}{chooseFrom:caption:}, se definen en el protocolo \prot{convenience} de \clsind{WAComponent}.

%-----------------------------------------------------------------
\subsection{Tareas}

Una \subind{Seaside}{tarea} es un componente que hereda de \clsind{WATask}.
No presenta nada por sí misma, sino que simplemente llama a otros componentes en un control de flujo definido implementando el método \mthind{WATask}{go}.

\clsind{WAConvenienceTest} es un ejemplo sencillo de una tarea definida en la categoría \scat{Seaside-Tests-Functional}.
Para ver sus efectos, simplemente dirige tu navegador a \url{http://localhost:8080/seaside/tests/alltests}, selecciona \menu{WAConvenienceTest} y haz click en \button{Restart}.

\begin{code}{}
WAConvenienceTest>>>go
	[ self chooseCheese.
	  self confirmCheese ] whileFalse.
	self informCheese
\end{code}

Esta tarea llamada a su vez a tres componentes.
El primero, generado por el método de utilidad \mthind{WAComponent}{chooseFrom: caption:}, es un \clsind{WAChoiceDialog} que pide al usuario que escoja un queso.

\begin{code}{}
WAConvenienceTest>>>chooseCheese
	cheese := self
		chooseFrom: #('Greyerzer' 'Tilsiter' 'Sbrinz')
		caption: 'What''s your favorite Cheese?'.
	cheese isNil ifTrue: [ self chooseCheese ]
\end{code}

% \alex{Is there a situation where cheese may be nil? Maybe if a browser authorizes an empty selection...}

El segundo es un \clsind{WAYesOrNoDialog} para confirmar la elección (generado por el método de utilidad \mthind{WAComponent}{confirm:}).

\begin{code}{}
WAConvenienceTest>>>confirmCheese
	^self confirm: 'Is ', cheese,  ' your favorite cheese?'
\end{code}

Finalmente se llama a un \clsind{WAFormDialog} (por medio del método de utilidad \mthind{WAComponent}{inform:}).

\begin{code}{}
WAConvenienceTest>>>informCheese
	self inform: 'Your favorite cheese is ', cheese, '.'
\end{code}

Los diálogos generados se muestran en la \figref{chooseCheese}.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{chooseCheese}
\caption{Una tarea sencilla}
\figlabel{chooseCheese}
\end{center}
\end{figure}

%-----------------------------------------------------------------
\subsection{Transacciones}

Como vimos en la \secref{backtracking}, Seaside puede realizar un seguimiento de la correspondencia entre el estado de los componentes y las páginas web individuales por medio de componentes que registran sus estados para la vuelta atrás:
todo lo que un componente necesita es implementar el método \ct{states} para devolver un array con todos los objetos cuyo estado debe seguirse.

Sin embargo, algunas veces, no queremos volver atrás el estado: en su lugar queremos \emph{evitar} que el usuario accidentalmente deshaga los efectos que deberían ser permanentes.
A esto nos referimos frecuentemente como ``el problema del carrito de la compra''.
Una vez que has validado tu carrito de la compra y pagado por los elementos que has comprado, no debería ser posible volver ``atrás'' con el navegador y añadir más elementos al carrito.

Seaside te permite evitar esto definiendo una tarea en la que ciertas acciones están agrupadas como \emph{transacciones}.
Puedes volver atrás dentro de una transacción, pero una vez que una transacción está completa, ya no puedes deshacerla.
Las páginas correspondientes están \emph{invalidadas} y cualquier intento de volver a ellas causará que Seaside genere un aviso y redirija al usuario a la página válida más reciente.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{sushiStore}
\caption{La tienda de Sushi}
\figlabel{sushiStore}
\end{center}
\end{figure}

La aplicación de Seaside \emphsubind{Seaside}{Sushi Store} es una aplicación de ejemplo que ilustra muchas de las características de Seaside, incluyendo las transacciones.
La aplicación está incluída con tu instalación de Seaside, así que puedes probarla dirigiendo tu navegador a
\url{http://localhost:8080/seaside/examples/store}.\footnote{Si no puedes encontrarla en tu imagen, existe una versión de la tienda de sushi disponible en SqueakSource en \url{http://www.squeaksource.com/SeasideExamples/}.}

La tienda de sushi soporta el siguiente flujo:
\begin{enumerate}[itemsep=0pt]
  \item Visita la tienda.
  \item Navega o busca sushi.
  \item Añade sushi a tu carrito de la compra.
  \item Lanza el pedido.
  \item Verifica tu pedido.
  \item Introduce la dirección de entrega.
  \item Verifica la dirección de entrega.
  \item Introduce la información del pago.
  \item ¡Tu pescado está en camino!
\end{enumerate}

Si activas los \subind{Seaside}{halos}, verás que el componente de primer nivel de la tienda de sushi es una instancia de \clsind{WAStore}.
No hace nada, salvo presentar la barra de título y entonces presenta \ct{task}, una instancia de  \clsind{WAStoreTask}.

\begin{code}{}
WAStore>>>renderContentOn: html
	"... render the title bar ..."
	html div id: 'body'; with: task
\end{code}

\clsind{WAStoreTask} captura la secuencia de este flujo. En un par de puntos es crítico que el usuario no sea capaz de volver atrás y cambiar la información enviada.

\dothis{\,``Compra'' algo de sushi y entonces usa el botón ``atrás'' para intentar añadir más sushi al carrito.
Obttendrás el mensaje ``That page has expired.''}

Seaside permite al programador declarar que cierta parte de un flujo de trabajo actúa como una transacción: una vez que la transacción se completa, el usuario no puede volver atrás y deshacerla.
Declaras esto enviando \mthind{WAComponent}{isolate:} a una tarea con el bloque transaccional como su argumento.
Podemos ver esto en el flujo de trabajo de la tienda de sushi a continuación:

\begin{code}{}
WAStoreTask>>>go
	| shipping billing creditCard |
	cart := WAStoreCart new.
	self isolate:
		[[self fillCart.
		self confirmContentsOfCart]
			whileFalse].

	self isolate:
		[shipping := self getShippingAddress.
		billing := (self useAsBillingAddress: shipping)
					ifFalse: [self getBillingAddress]
					ifTrue: [shipping].
		creditCard := self getPaymentInfo.
		self shipTo: shipping billTo: billing payWith: creditCard].

	self displayConfirmation.
\end{code}

Aquí vemos bastante claramente que existen dos transacciones.
La primera rellena el carrito y cierra la fase de compra.
(Los métodos auxiliares \ct{fillCart} \etc se ocupan de instanciar y llamar a los componentes adecuados.)
Una vez que has confirmado los contenidos del carrito no puedes volver atrás sin iniciar una nueva sesión.
La segunda transacción cumplimenta los datos de envío y pago.
Puedes navegar atrás y adelante dentro de la segunda transacción hasta que confirmas el pago.
Sin emgargo, una vez que ambas transacciones estás completas, cualquier intento de navegar atrás fallará.

Las transacciones también pueden anidarse.
Una demostración sencilla de estos se encuentra en la clase \clsind{WANestedTransaction}.
El primer \ct{isolate:} recibe como argumento un bloque que contiene otro \ct{isolate:} anidado.

\begin{code}{}
WANestedTransaction>>>go
	self inform: 'Before parent txn'.
	self isolate:
			[self inform: 'Inside parent txn'.
			self isolate: [self inform: 'Inside child txn'].
			self inform: 'Outside child txn'].
	self inform: 'Outside parent txn'
\end{code}

\dothis{Ve a \url{http://localhost:8080/seaside/tests/alltests}, selecciona \menu{WATransactionTest} y pulsa en \button{Restart}.
Prueba a navegar atrás y adelante dentro de las transacciones padre e hija pulsando el botón \button{atrás} y después en \button{ok}.
Observa que tan pronto como una transacción se completa, ya no puedes volver atrás dentro de la transacción sin generar un error al pulsar \button{ok}.}

%=================================================================
\section{Un ejemplo tutorial completo}

% ON: Should take about two hours

Veamos como podemos construir una aplicaci\'on Seaside completa desde cero.\footnote{El ejercicio debe llevar como mucho un par de horas.
Si prefieres solo mirar el c\'odigo fuente completo, puedes obtenerlo del proyecto SqueakSource \url{http://www.squeaksource.com/PharoByExample}.
El paquete a cargar es  \scat{PBE-SeasideRPN}. El siguiente tutorial utiliza  nombres de clases levemente diferentes para que puedas comparar tu implementaci\'on con las nuestra.}
Construiremos una calculadora de notaci\'on polaca inversa como una aplicaci\'on Seaside que utiliza una simple pila  como su modelo subyacente.
Incluso m\'as, la interface Seaside nos permitir\'a alternar entre dos vistas\,---\, una que solo nos muestre  el valor actual en el tope de la pila, y la otra que nos muestre el estado completo de la pila.

La calculadora con las dos opciones de vistas se muestra en \figref{stackMachine}.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{stackMachine}
\caption{RPN calculator and its stack machine}
\figlabel{stackMachine}
\end{center}
\end{figure}

Comenzamos por implementar la pila y sus pruebas.

\dothis{Define una nueva clase llamada  \ct{MyStackMachine} con una variable de instancia \ct{contents} inicializada a una nueva \ct{OrderedCollection}.}

\begin{code}{}
MyStackMachine>>>initialize
	super initialize.
	contents := OrderedCollection new.
\end{code}

Esta pila deber\'ia proveer operationes para poner y sacar valores, ver el tope de la pila y realizar varias operaciones aritm\'eticas para sumar
restar, multiplicar y dividir valores en la pila.

\dothis{Escribe algunas pruebas para las operaciones  de la pila y luego implementalas.
Aqui hay una prueba de muestra:}

\needlines{4}
\begin{code}{}
MyStackMachineTest>>>testDiv
	stack
		push: 3;
		push: 4;
		div.
	self assert: stack size = 1.
	self assert: stack top = (4/3).
\end{code}

Puedes considerar usar algunos m\'etodos de ayuda para las operaciones aritm\'etica para chequear que haya dos n\'umeros en la pila antes de hacer cualquier cosa y levantar un error
si esta precondici\'on no es cumplida. \footnote{Es una buena idea usar \ct{Object>>>assert:} para especificar las precondiciones de una operaci\'on. Este m\'etodo levantar\'a una \ct{AssertionFailure} si el usuario intenta usar la pila en un estado invalido.}
Si haces esto, la mayor\'ia de tus m\'etodos ser\'an de una o dos lineas de longitud.
\nicopaez{helper methods traducidos como metodos de ayuda}

Tambi\'en pueden considerar implementar \ct{MyStackMachine>>>printOn:} para facilitar la depuraci\'on de la implementaci\'on de tu pila con la ayuda de un inspector de objetos.
(Pista: solo delega la impresi\'on a la variable \ct{contents}.)
\index{Object!printOn:@\ct{printOn:}}

\dothis{Completa \ct{MyStackMachine} escribiendo las operaciones \ct{dup} (apila un duplicado del valor en el tope de la pila), \ct{exch} (intercambia los dos valores topes en la pila),
y \ct{rotUp} (rota la todos los contenidos de la pila\,---\,el tope ser\'a ser\'a movido al fondo de la pila).}

Ahora tenemos una implementaci\'on de una pila.
Podemos comenzar a implementar la calculadora NPI Seaside.

Haremos uso de 5 clases:
\begin{itemize}
  \item \ct{MyRPNWidget}\,---\,esta deberia ser una clase abstracta que defina la hoja de estilo CSS com\'un para la aplicaci\'on, y otro comportamiento com\'un para los componentes de la calculadora NPI.
  Es una subclase de \ct{WAComponent} y la superclase directa de las siguientes cuatro clases. 
    \item \ct{MyCalculator}\,---\,este es el componentes ra\'iz.
  Deber\'ia registrar la aplicaci\'on (en la parte de la clase), instanciar y hacer render de sus subcomponentes, y registrar cualquier estado para backtracking.
  \item \ct{MyKeypad}\,---\,esta muestra las teclas que usamos para interactuar con la calculadora. \nicopaez{traduje render, como hacer render, debe backtracking como backtracking}
  \item \ct{MyDisplay}\,---\,este componente muetra el tope de la pila y provee un bot\'on para llamar a otro componente para mostrar la vista detallada.
  \item \ct{MyDisplayStack}\,---\,este componente, muestra la vista detallada de la pila y provee un bot\'on para responder.
  Es una subclase de \lct{MyDisplay}.
\end{itemize}

\dothis{Define \ct{MyRPNWidget} en la categoria \ct{MyCalculator}.
Define el \ct{estilo} com\'un para la aplicaci\'on.}

Esta es un CSS m\'inimo para la aplicaci\'on.
Puedes hacerla mas atractiva si gustas. \nicopaez{aqui decia fancy y lo reemplace por atrativo pues no encontre una traduccion apropiada para fancy}
\begin{code}{}
MyRPNWidget>>>style
	^ 'table.keypad { float: left; }
td.key {
	border: 1px solid grey;
	background: lightgrey;
	padding: 4px;
	text-align: center;
}
table.stack { float: left; }
td.stackcell {
	border: 2px solid white;
	border-left-color: grey;
	border-right-color: grey;
	border-bottom-color: grey;
	padding: 4px;
	text-align: right;
}
td.small { font-size: 8pt; }'
\end{code}

\dothis{Define \ct{MyCalculator} para ser el componente ra\'iz y registralo asimismo como aplicaci\'onb (\ie implementa \ct{canBeRoot} y \ct{initialize} del lado de la clase).
Implementa \ct{MyCalculator>>>renderContentOn:} para hacer render de algo trivial (como su nombre), y verificar que la aplicaci\'on corre en un nagevador.
}

\ct{MyCalculator} es responsable de instanciar \ct{MyStackMachine}, \ct{MyKeypad} y \ct{MyDisplay}.

\dothis{
Define \ct{MyKeypad} y \ct{MyDisplay} como subclase de \lct{MyRPNWidget}.
Los tres componentes necesitar\'an acceso a una instancia com\'un de la pila, entonces define una variable de instancia \ct{stackMachine} y un m\'etodo de inicializaci\'on \ct{setMyStackMachine:} 
en su padre com\'un, \ct{MyRPNWidget}.
Agrega variables de instancia \ct{keypad} y \ct{display} para \ct{MyCalculator} e inicializarlos en \ct{MyCalculator>>>initialize}.
(No olvides de enviar \lct{super initialize}!)}

\dothis{
Pasa una instancia compartida de la pila al keypad y al display en el mismo m\'etodo initialize.
Implementa \ct{MyCalculator>>>renderContentOn:} para simplemente hacer render cuando corresponda del keypad y el display.
Para mostrar correctamente los subcomponentes, debes implementar \ct{MyCalculator>>>children} para devolver un arreglo con el keypad y el display.
\nicopaez{la siguiente frase no supe como traducirla}
Implement placeholder rendering methods for the keypad and the display and verify that the calculator now displays its two subcomponents.
}

%\ab{Too long!}

Ahora cambiaremos la implementaci\'on del display para mostrar el valor en el tope de la pila.

\dothis{
Usa una tabla con clase ``keypad'' conteniendo una fila con celda de datos con clase ``stackcell''.
Cambia el m\'etodo de rendering del keypad para asegurar que el n\'umero 0 es apilado en la pila en caso que este vacia.
(Define y usa \ct{MyKeypad>>>ensureMyStackMachineNotEmpty}.)
Tambi\'en hazlo mostrar una tabla vacia con la clase ``keypad''.
Ahora la calculadora deber\'ia mostrar una celda conteniendo el valor 0.
Si cambias los halos, deber\'ias ver algo como esto:
}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.8\textwidth]{firstStackDisplay}
\caption{Mostrando el tope de la pila}
\figlabel{firstStackDisplay}
\end{center}
\end{figure}

Ahora implementemos la interface para interactuar con la pila.

\dothis{
Primero define los siguientes m\'etodos de ayuda, que har\'an m\'as simple el gui\'on de la interface:
}

\needlines{3}
\begin{code}{}
MyKeypad>>>renderStackButton: text callback: aBlock colSpan: anInteger on: html 
	html tableData
		class: 'key';
		colSpan: anInteger;
		with: 			
				[html anchor
					callback: aBlock;
					with: [html html: text]]
\end{code}


\begin{code}{}
MyKeypad>>>renderStackButton: text callback: aBlock on: html 
	self 
		renderStackButton: text
		callback: aBlock
		colSpan: 1
		on: html
\end{code}
Usaremos estos dos m\'etodos para definir los botones en el keypad con las correspondientes m\'etodos de callback.
Ciertos botones pueden expandirse por m\'ultiples columnas, pero por defecto ocupar\'an solo una.

\dothis{
Usa los dos m\'etodos de ayuda para guionar el keypad como a continuaci\'on:
(Pista: comienza por obtener el d\'igito e ``introducir'' teclas de trabajo y luego las operaciones aritm\'eticas.)
}

\needlines{4}
\begin{code}{}
MyKeypad>>>renderContentOn: html 
  self ensureStackMachineNotEmpty.
  html table
    class: 'keypad';
    with: [
      html tableRow: [
          self renderStackButton: '+' callback: [self stackOp: #add] on: html.
          self renderStackButton: '&ndash;' callback: [self stackOp: #min] on: html.
          self renderStackButton: '&times;' callback: [self stackOp: #mul] on: html.
          self renderStackButton: '&divide;' callback: [self stackOp: #div] on: html.
          self renderStackButton: '&plusmn;' callback: [self stackOp: #neg] on: html ].
        html tableRow: [
          self renderStackButton: '1' callback: [self type: '1'] on: html.
          self renderStackButton: '2' callback: [self type: '2'] on: html.
          self renderStackButton: '3' callback: [self type: '3'] on: html.
          self renderStackButton: 'Drop' callback: [self stackOp: #pop]
          	colSpan: 2 on: html ].
" and so on ... "
        html tableRow: [
          self renderStackButton: '0' callback: [self type: '0'] colSpan: 2 on: html.
          self renderStackButton: 'C' callback: [self stackClearTop] on: html.
          self renderStackButton: 'Enter'
          	callback: [self stackOp: #dup. self setClearMode]
			colSpan: 2 on: html ]]
\end{code}

Chequea que el keypad se muestra correctamente.
Si intentas hacer clic en las teclas, sin embargo, entontrar\'as que la calculadora a\'un no funciona \ldots{}

\dothis{
Implementa \ct{MyKeypad>>>type:} para actualizar el tope de la pila agregando el d\'igito tipeado.
Necesitar\'as convertir el valor del tope a una cadena de caracteres, actualizarlo y volver a convertirlo a entero, algo asi:
}

\begin{code}{}
MyKeypad>>>type: aString
	stackMachine push: (stackMachine pop asString, aString) asNumber.
\end{code}
Now when you click on the digit keys the display should be updated.
(Be sure that \ct{MyStackMachine>>>pop} returns the value popped, or this will not work!)


\dothis{Now we must implement \ct{MyKeypad>>>stackOp:}
Something like this will do the trick:}

\begin{code}{}
MyKeypad>>>stackOp: op
	[ stackMachine perform: op ] on: AssertionFailure do: [ ].
\end{code}

El punto es que no estamos seguros de que todas las operacione sean exitosas, por ejemplo, la suma fallar\'a si no tenemos dos n\'umeros en la pila.
Por el momento podemos ignorar estos errores.
Si no sentimos m\'as ambiciosos luego, podemos proveer alg\'un feedback al usuario en el bloque de manejo de error.

\dothis{Esta primera versi\'on de la calculadora deber\'ia estar funcionando ahora.
Intentar ingresar algunos n\'umeros presionando las teclas de los d\'igitos, haciendo \menu{Enter} para apilar una copia del valor actual, e ingresando \menu{+} para sumar los dos valores en el tope de la pila.}

Notar\'as que tipeo d\'igitos no se comporta de la manera esperada.
En verdad la calculadora, deber\'ia estar al tanto de si se est\'an tipeando un \emph{nuevo} n\'umero, o agregando un n\'umero existente.

\dothis{Adapta \ct{MyKeypad>>>type:} para comportarse de manera diferente dependiendo del modo actual de tipeo.
Introduce una nueva variable de instancia \ct{mode} que tome uno de los 3 valores \lct{\#typing} (cuando se esta tipeando), \lct{\#push} (luego de que se realizado una operaci\'on 
y tipear deber\'ia forzar al valor tope a ser apilado, o \lct{\#clear} (luego de haber realizar \menu{Enter} y el valor tope deba ser limpiado antes de tipear).
El nuevo m\'etodo \ct{type:} se veria como:
}

\begin{code}{}
MyKeypad>>>type: aString
	self inPushMode ifTrue: [
		stackMachine push: stackMachine top.
		self stackClearTop ].
	self inClearMode ifTrue: [ self stackClearTop ].
	stackMachine push: (stackMachine pop asString, aString) asNumber.
\end{code}
\mb{better with "stackMachine dup" instead of "stackMachine push:
  stackMachine top}"

El tipeo deber\'ia funcionar mejor ahora, pero a\'un es fustrante no se capaz de ver que est\'an en la pila.

\dothis{
Define \ct{MyDisplayStack} una subclase de \ct{MyDisplay}.
Agrega un bot\'on al m\'etodo render de \ct{MyDisplay} que llamar\'a a una nueva instancia de \ct{MyDisplayStack}.
Necesitar\'as un anchor html que se parezca a lo siguiente:
}

\begin{code}{}
html anchor
	callback: [ self call: (MyDisplayStack new setMyStackMachine: stackMachine)];
	with: 'open'
\end{code}
\mb{if the user got a stackmachine ivar, I'm sure he will define
  setStackMachine and not setMyStackMachine}

El m\'etodo de callback causar\'a que la instancia actual de \ct{MyDisplay} sea temporalmente reemplazada por una nueva instancia de \ct{MyDisplayStack} 
cuyo trabajo is mostrar la pila completa.
Cuando este componente se\~nala que ha terminado (\ie enviando \ct{self answer}), entonces el control retonar\'a a la instancia original de \ct{MyDisplay}.

\dothis{
Define el m\'etodo de render de \ct{MyDisplayStack} para mostrar todos los valores de la pila.
(Necesitar\'as definir un accesor para el \ct{contenido} de la pila o puedes definir \ct{MyStackMachine>>>do:} para iterar sobre los valores de la pila.)
La vista de la pila deber\'ia tener tambi\'en  un boton etiquedado ``close'' cuyo m\'etodo de callback simplemente ejecutar\'a \ct{self answer}.
}

\begin{code}{}
html anchor
	callback: [ self answer];
	with: 'close'
\end{code}

Ahora deberias ser capaz de \emph{abrir} y \emph{cerrar} la pila mientras estes usando la calculadora.

ESto es sin embargo una cosa que nos hemos olvidado.
Intenta realizar algunas operaciones con la pila.
Ahora usa el bot\'on ``back'' de tu navegador e intenta realizar algunas operaciones m\'as con la pila.
(Por ejemplo, \menu{abrir} la pila, tipear \menu{1}, \menu{Enter} dos veces y \menu {+}.
La pila deber\'ia mostrar ``2'' y ``1''.
Ahora presiona el bot\'on ``back''.
La pila ahora muestra tres veces 1 otra vez.
Ahora si tipeas \menu{+} la pila muestra ``3''.
El backtracking no est\'a funcionando a\'un.

\dothis{
Implementa \ct{MyCalculator>>>states} para devolver un arreglo con los contenidos de la pila. Chequea que el backtraking ahora funciona correctamente!.
}

Si\'entate y disfruta de un gran vaso de de algo cool!

%=================================================================
\section{Una mirada a AJAX}
\nicopaez{tambien podria ser: Una mirada rapida a AJAX}
% Original text by Lukas Renggli

\ind{AJAX} (Asynchronous \ind{JavaScript} and \ind{XML}) es una t\'ecnica para hacer aplicaciones web m\'as interactivas explotando funcionalidad JavaScript del lado del cliente.

Dos librerias JavaScript bien conocidas son \ind{Prototype} (\url{http://www.prototypejs.org}) y \ind{script.aculo.us} (\url{http://script.aculo.us}).
Prototype provee un marco de trabajo para facilitar la escritura de JavaScript.
script.aculo.us provee algunas caracter\'isticas adicionales para soportar animaciones y drag-and-drop por encima de Prototype.
Ambos marcos de trabajo estan soportados en Seaside a traves del paquete ``Scriptaculous''.

Todas las im\'agenes prearmadas tienen el paquete Scriptaculous ya cargado.
La \'ultima versi\'on est\'a disponible desde \url{http://www.squeaksource.com/Seaside}.
Un demostraci\'on en lin\'ea est\'a disponible en \url{http://scriptaculous.seasidehosting.st}.
Alternativamente, si tienes una imagen habilitada corriendo, simplemente ve a \url{http://localhost:8080/seaside/tests/scriptaculous}.
\nicopaez{traduje ready-made como prearmadas, no es un traduccion literal, pero creo que mantiene lo que se quiere decir}

Las extensiones Scriptaculous extensions siguen el mismo enfoque que Seaside mismo\,---\,simplemente configuran objetos Smalltalk para modelar tu aplicaci\'on, y el c\'odigo JavaScript
necesario ser\'a generado por ti.


Veamos un simple ejemplo de como el soporte JavaScript en el cliente puede hacer a nuestra calculadora NPI compartarse m\'as naturalmente.
Actualmente cada presi\'on de una tecla para ingresar un d\'igito genera un pedido para refrescar la p\'agina.
Nos gustar\'ia en su lugar, manejar la edici\'on del display del lado del cliente, actualizando el display en la p\'agina existente.

\dothis{Para manipular el display desde el c\'odigo JavaScript debemos primero darle un id \'unico.
Actualizar el m\'etodo de rendering de la calculadora como sigue:\footnote{Si no has implementado el ejemplo tutorial, puedes cargar dicho ejemplo completo (PBE-SeasideRPN) desde \url{http://www.squeaksource.com/PharoByExample} 
y aplicar los cambios sugeridos a las clases \ct{RPN*} en lugar de \ct{My*}.}}

\begin{code}{}
MyCalculator>>>renderContentOn: html
	html div id: 'keypad'; with: keypad.
	html div id: 'display'; with: display.	
\end{code}
				
\dothis{Para ser capaz de re-dibujar el display cuando un bot\'on del teclado es presionado, el teclado necesita conocer al componente display.
Agrega una variable de instancia \ct{display} al \ct{MyKeypad}, un m\'etodo inicializador \ct{MyKeypad>>>setDisplay:}, y llamalo desde \ct{MyCalculator>>initialize}.
Ahora somo capaces de asignar c\'odigo JavaScript a los botones, actualizando \ct{MyKeypad>>>renderStackButton:callback:colSpan:on:} com sigue:}
\nicopaez{traduje re-render como re-dibujar, se que no feliz, pero no se ocurrio otra cosa}

\begin{code}{}
MyKeypad>>>renderStackButton: text callback: aBlock colSpan: anInteger on: html 
	html tableData
		class: 'key';
		colSpan: anInteger;
		with: [
			html anchor
				callback: aBlock;
				onClick:				"handle Javascript event"
					(html updater
						id: 'display';
						callback: [ :r |
							aBlock value.
							r render: display ];
						return: false);
				with: [ html html: text ] ]
\end{code}

\mthind{WATagBrush}{onClick:} especifica un manejador de evento \ind{JavaScript}.
\ct{html updater} retorna una instancia de \ct{SUUpdater}, un objeto Smalltalk representando el objeto JavaScript Ajax.Updater (\url{http://www.prototypejs.org/api/ajax/updater}).
Este objeto realiza un pedido AJAX y actualiza el contenido de un contenedor basado en el texto de una respuesta.
\ct{id:} indica al actualiozador que elemento XHTML DOM actualizar, en este caso los contenidos de un elmento div con id 'display'.
\ct{callback:} especifica un bloque que is disparado cuando el usuario presiona el bot\'on.
El argumento del bloque es un nuevo renderer \ct{r}, que podemos usar para hacer render del componente display.
(Nota: a pesar de que html est\'a a\'un accesible, ya no es v\'alido en el momento en que esta bloque de callback es evaluado).

Antes de hacer rendering del componente display evaluamos \ct{aBlock} para realizar la acci\'on deseada.

\ct{return: false} indica al motor JavaScript no disparar el enlace de callback original, que causar\'ia un refresco completo.
Podriamos en su lugar, remover el anchor \ct{callback:} original, pero asi esta calculadora funcionar\'a a\'un si JavaScript est\'a desabilitado. 

\dothis{Prueba la calculadora otra vez, y nota como un refresco completo de p\'agina es disparado cada vez que presionas una tecla de un d\'igito. (La URL de la p\'agina web is actualizada con cada presi\'on de tecla.)}

A pesar que hemos implementado el comportamiento del lado del cliente, a\'un no lo hemos activado.
Ahora habilitaremos el manejo de eventos JavaScript.

\dothis{
Haz clic en el enlace \link{Configure} en la barra de herramientas de la calculadora.
Selecciona ``Add Library:'' \ct{SULibrary}, haz clic en los botones \button{Add} y \button{Close}.}

En lugar de agregar manualmente la bibliteca, puedes tambi\'en hacerlo program\'aticamente cuando registras la aplicaci\'on:
\begin{code}{}
MyCalculator class>>>initialize
	(self registerAsApplication: 'rpn')
		addLibrary: SULibrary}}
\end{code}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{ajax-processing}
\caption{Seaside AJAX processing (simplified)}
\figlabel{ajax-processing}
\end{center}
\end{figure}

\dothis{Prueba la aplicaci\'on revisada.  Nota que el feedback es mucho m\'as natural. En particular, no se genera una nueva URL con cada presi\'on de tecla.}

Bien puedes preguntar, \emph{si, pero como funciona esto?}
\figref{ajax-processing} muestra como la aplicacion Caculadora NPI trabajar\'ia con y sin AJAX.
B\'asicamente, AJAX corto-circuita el rendering para actualizar \emph{solamente} el componente display.
Javascript es responsable por disparar el pedido y actualizar el correspondiente elemento DOM.
Mira el c\'odigo fuente generado, especialmente el c\'odigo JavaScript:

\begin{code}{}
new Ajax.Updater(
	'display',
	'http://localhost/seaside/RPN+Calculator',
	{'evalScripts': true,
	  'parameters': ['UNDERSCOREs=zcdqfonqwbeYzkza', 'UNDERSCOREk=jMORHtqr','9'].join('&')});
return false
\end{code}

Para ejemplos m\'as avanzados, mira \url{http://localhost:8080/seaside/tests/scriptaculous}.

\paragraph{\emph{Pista.}}
En caso de problemas del lado del servidor, utiliza el depurador de Smalltalk.
En caso de problemas del lado del cliente utiliza FireFox (\url{http://www.mozilla.com}) con el agregado del depurador JavaScript FireBug (\url{http://www.getfirebug.com/}) habilitado.

%=================================================================
\section{Resumen del cap\'itulo}

\begin{itemize}
  \item La forma m\'as simple de comenzar es descargando el ``Seaside One-Click Experience'' desde \url{http://seaside.st}
  \item Enciende y apaga el servidor evaluando \ct{WAKom startOn: 8080} y \ct{WAKom stop}.
  \item Restablce el usuario administrador y contrase\~na evaluando \ct{WADispatcherEditor initialize}.
  \item \menu{Toggle Halos} para directamente ver el c\'odigo fuente de la aplicaci\'on, los objetos en ejecuci\'on, CSS y XHTML.
  \item Env\'ia \ct{WAGlobalConfiguration setDeploymentMode} para ocultar la barra de herramientas.
  \item Las aplicaciones web Seaside estan compuestas por componentes, cada uno de los cuales es una instancia de una subclase de \ct{WAComponent}.
  \item Solo un componente ra\'iz puede ser registrado como un componente. Este debe implementar \ct{canBeRoot} del lado de la clase. Alternativamente puede registrarse asimismo como una aplicaci\'on en su m\'etodo de clase \ct{initialize} enviando \ct{self registerAsApplication:} \emph{application path}.
  Si sobreescribes \ct{description} es posible retornar un nombre descriptivo de la aplicaci\'on que ser\'a mostrado en el editor de configuraci\'on.
  \item Para seguir el estado, un componente debe implementar el m\'etodo \ct{states} para retornar un arreglo de objetos cuyo estado ser\'a restaurado si el usuario hace clic en el bot\'on ``back'' de su navegador.
  \nicopaez{traduje backtrack como seguir, pero no me gusta}
  \item Un componente se renderiza asimismo implementando \ct{renderContentOn:}.
  El argumento de este m\'etodo es un \emph{lienzo} de rendering XHTML (usualmente llamado \ct{html}).
  \item Un componente puede hacer render de un subcomponente enviando \ct{self render:} \emph{subcomponent}.
  \item XHTML es generado program\'aticamente enviando mensajes a \emph{pinceles}. Un pincel se obtiene enviando un mensaje, como \ct{paragraph} o \ct{div}, al lienzo html.
  \item Si envias un mensjae en cascada a un pincel que incluya el mensaje \ct{with:}, entonces \ct{with:} deber\'ia ser el \'ultimo mensaje enviado.
  El mensaje \ct{with:} establece los contenidos y \emph{and} genera el resultado.
  \item Las acciones solo deberi\'an aparecer en los m\'etodos de callback.
No deberias cambiar el estado de una aplicaci\'on mientras estas haciendo render de la misma.
  \item Puedes vincular varias formas de widgets y anclas a variables de instancia con m\'etodos de acceso enviando el mensaje \ct{on:} \emph{variable de instancia} \ct{of:} \emph{objeto} de un pincel.
  \item Puedes definir el CSS para una jerarqu\'ia de componentes definiendo el m\'etodo \ct{style}, el cual deber\'ia retornar una cadena de caracteres conteniendo la hoja de estilos.
  (Para aplicaciones desplegadas, is m\'as usual hacer referencia a una hoja de estilos localizada en una URL est\'atica.)
  \item El flujo de control puede ser programado enviando \ct{x call: y}, en cuyo caso el componente \ct{x} ser\'a reemplazado por \ct{y} hasta que \ct{y} responda enviando \ct{answer:} con el resultado en un mensaje de callback.
  El receptor de \ct{call:} es usualmente \ct{self}, pero puede ser en general cualquier componente visible.
  \item El flujo de control tambi\'en puede ser especificado como una \emph{tarea}\,---\,una instancia de una subclase de \ct{WATask}. 
Esta deber\'ia implementar el m\'etodo \ct{go}, que deber\'ia llamar una seria de componentes en un workflow.
  
\item Utiliza los m\'etodos de \ct{WAComponents} \ct{request:}, \ct{inform:}, \ct{confirm:} y \ct{chooseFrom:caption:} para interacciones b\'asicas.
  \item Para prevenir que el usuario utilice el bot\'on ``back'' del navegador para acceder a estados previos de ejecuci\'on de la aplicaci\'on web, 
puedes declarar porciones de un workflow para ser \emph{transacciones} encerr\'andolas en un bloque \ct{isolate:}.
\end{itemize}
%-----------------------------------------------------------------

%=================================================================
\ifx\wholebook\relax\else 
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=================================================================
