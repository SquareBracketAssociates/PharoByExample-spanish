% $Author$
% $Date$
% $Revision$

% HISTORY:
% 2006-12-07 - Andrew started
% 2007-03-30 - Cassou moved Streams to separate chapter
% 2007-05-28 - Stef adds material
% 2007-08-13 - Oscar edits
% 2009-07-07 - Oscar migrated to Pharo; fixed broken tests
% 2011-05-05 - Pablo Barrientos started initial translation

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\usepackage[spanish]{babel}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi

%=================================================================
\chapter{Colecciones}
\chalabel{collections}

\ew{Stack (o pila) es una construcci\'on popular. ?`C\'omo encaja en la jerarqu\'ia de colecciones?}

% \ab{ The material here is based on a section that Andrew wrote for the \st Collections refactoring paper. It's not necessarily all appropriate for the book, but much of it is, I think, useful.}
%\on{recycled some material from \url{https://www.iam.unibe.ch/scg/svn_repos/Lectures/ST-H07/03StandardClasses.ppt}}
%\sd{Did a first pass: I should have a look at Xavier Briffault's book and at the material mentionned by andrew + lalonde book?}
%=============================================================
\section{Introducci√≥n}

Las clases de colecciones forman un grupo vagamente definido de subclases de prop\'osito general de \clsindmain{Collection} y de \clsind{Stream}. El grupo de clases que aparecen en el ``\ind{Blue Book}''~\cite{Gold83a} contiene 17 subclases de \ct{Collection} y 9 subclases de \ct{Stream}, para un total de 28 clases, y ya hab\'ia sido redise\~{n}ado varias veces antes que el sistema \st-80 fuera publicado. \'Este grupo de clases a menudo se considerada un ejemplo paradigm\'atico de dise\~{n}o orientado a objetos.

En \pharo, la clase abstracta \ct{Collection} tiene 101 subclases, y la clase abstracta \ct{Stream} tiene 50 subclases, pero muchas de ellas (como \mbox{\clsind{Bitmap},} \clsind{FileStream} y \clsind{CompiledMethod}) son clases de prop\'osito especial hechas para uso en otras partes del sistema o en aplicaciones, y por lo tanto no categorizadas como ``Collections'' por la organizaci\'on del sistema. A los efectos de este cap\'itulo, usamos el t\'ermino  ``Jerarqu\'ia de colecciones'' para referirnos a \ct{Collection} y sus 47 subclases que est\'an \emph{adem\'as} en las categor\'ias etiquetadas \scat{Collections-*}.
Usamos el t\'ermino ``Jerarqu\'ia de Stream'' para referirnos a \ct{Stream} y sus 9 subclases que est\'an \emph{adem\'as} en las categor\'ias \scatind{Collections-Streams}.
\'Estas 56 clases responden a 982 mensajes y definen un total de 1609 m\'etodos!

% See test case in PBE-Collections for statistics

%c := (Collection allSubclasses select: [:each | each category beginsWith: 'Collections']).
%s := (Stream allSubclasses select: [:each | each category beginsWith: 'Collections-Streams']).
%m := (c,s) gather: #methods.
%Transcript
%	show: 'Collection subclasses: ', Collection allSubclasses size printString; cr;
%	show: 'Stream subclasses: ', Stream allSubclasses size printString; cr;
%	show: 'Collection package subclasses: ', c size printString; cr;
%	show: 'Collection package subclasses: ', c size printString; cr;
%	show: 'Stream package subclasses: ', s size printString; cr;
%	show: 'Total messages: ', m size printString; cr;
%	show: 'Total messages: ', (m collect: #selector) asSet size printString; cr

%\begin{figure}
%\begin{center}
%\ifluluelse
%	{\fbox{\includegraphics[height=0.9\textheight]{CollectionHierarchyList}}}
%	{\fbox{\includegraphics[width=3in]{CollectionHierarchyList}}}
%\caption{The collection classes in \pharo. Indentation indicates subclassing.
%\textit{\textsf{Italicized}} classes are abstract.
%{\textbf{Bold}} classes are described in the ``Blue Book".}
%\figlabel{CollClassesList}
%\end{center}
%\end{figure}

En \'este cap\'itulo nos enfocamos principalmente en el subconjunto de colecciones mostradas en \figref{CollClassesTree}.
Los Streams ser\'an discutidos de forma separada en \charef{streams}.

% \sd{should put stream related text in Stream chapter}.

% Note that the stream classes suffer from aging problems since they contain duplicated code and other code smells.
% ON: We should avoid statements like this!

\begin{figure}
\begin{center}
\ifluluelse
	{\includegraphics[width=\textwidth]{CollectionHierarchy}}
	{\includegraphics[width=0.8\textwidth]{CollectionHierarchy}}
\caption{Algunas de las clases clave de colecciones en \pharo.}
\figlabel{CollClassesTree}
\end{center}
\end{figure}

%=========================================================
\section{Las variedades de colecciones}
\seclabel{varieties}

Para usar correctamente las clases de colecciones, el lector necesita al menos un conocimiento superficial de la vasta variedad de colecciones que implementan, y sus puntos en com\'un y diferencias.

Programar con colecciones en lugar de elementos individuales es una manera importante de elevar el nivel de abstracci\'on de un programa. 
La funci\'on \ct{map} de \ind{Lisp}, que aplica una funci\'on a cada uno de los elementos de una lista y retorna una nueva lista conteniendo el resultado es un ejemplo de primera hora de este estilo, pero \st-80 adopt\'o la programaci\'on basada en colecciones como un principio b\'asico. Los lenguajes de programaci\'on funcional modernos tales como \ind{ML} y \ind{Haskell} han seguido el ejemplo de \st.

?`Por qu\'e es una buena idea?
Suponga que usted tiene una estructura de datos que contiene una colecci\'on de registros de estudiantes, y desea realizar alguna acci\'on en todos los estudiantes que cumplen alg\'un criterio. Los programadores educados en un lenguaje imperativo pensar\'an de manera inmediata en un bucle. Pero el programador de \st escribir\'a:

\begin{code}{}
	estudiantes select: [ :estudiante | estudiante promedio < umbral ]
\end{code}
\noindent
que eval\'ua a una nueva colecci\'on que contiene precisamente aquellos elementos de \ct{estudiantes} para los cuales la funci\'on entre corchetes retorna \ct{true}\footnote{La expresi\'on entre corchetes puede ser pensada como una expresi\'on $\lambda$ que define una funci\'on an\'onima $\lambda x. x~{\sf promedio} < {\sf umbral}$.
\index{lambda expression}}.
El c\'odigo \st tiene la simplicidad y elegancia de un lenguaje de consulta de dominio espec\'ifico.

El mensaje \ct{select:} es entendido por \emph{todas} las colecciones en \st.  No hay necesidad de saber si la estructura de datos es un array o una lista enlazada (linked list): el mensaje \ct{select:} es entendido por ambos tipos de colecciones.  Notar que es un poco diferente a usar un loop, donde uno debe saber si \ct{estudiantes} es un array o una lista enlazada antes de que el loop pueda construirse.

En \st, cuando uno habla de una colecci\'on sin ser m\'as especifico sobre el tipo de colecci\'on, uno se refiere a un objeto que soporta un protocolo bien definido para testear inclusi\'on y enumeraci\'on de sus elementos.  \emph{Todas} las colecciones entienden los mensajes de \protind{testing} \mbox{\mthind{Collection}{includes:},} \mthind{Collection}{isEmpty} y \mbox{\mthind{Collection}{occurrencesOf:}.}  \emph{Todas} las colecciones entienden los mensajes de \prot{enumeration} \mthind{Collection}{do:}, \mthind{Collection}{select:}, \mthind{Collection}{reject:} (que es el opuesto a \ct{select:}), \mthind{Collection}{collect:} (que es como el \ct{map} de LISP), \mthind{Collection}{detect:ifNone:}, \mthind{Collection}{inject:into:} (que realiza un fold a izquierda) y muchos m\'as.
Es la omnipresencia de este protocolo, como as\'i tambi\'en su variedad, que lo hace tan poderoso.

\figref{protocols} resume los protocolos est\'andares soportados por la mayor\'ia de las clases en la jerarqu\'ia de colecciones.
Estos m\'etodos est\'an definidos, redefinidos, optimizados o incluso ocasionalmente prohibidos por las subclases de \ct{Collection}.

\begin{figure*}
\begin{center}
\ifluluelse
	{\begin{tabular}{|l|p{8cm}|}}
	{\begin{tabular}{|l|p{12cm}|}}
\hline
{\bf Protocolo} & {\bf M\'etodos}\\
\hline
\protind{accessing}	&	\lct{size}, \lct{capacity}, \lct{at: \emph{anIndex}}, \lct{at: \emph{anIndex} put: \emph{anElement}}	\\
\hline
\protind{testing}	&	\lct{isEmpty}, \lct{includes: \emph{anElement}}, \lct{contains: \emph{aBlock}}, \\
& \lct{occurrencesOf: \emph{anElement}}	\\
\hline
\protind{adding}	&	\lct{add: \emph{anElement}}, \lct{addAll: \emph{aCollection}}	\\
\hline
\protind{removing}		&	\lct{remove: \emph{anElement}}, \lct{remove: \emph{anElement} ifAbsent: \emph{aBlock}}, \lct{removeAll: \emph{aCollection}}	\\
\hline
\protind{enumerating}	&	\lct{do: \emph{aBlock}}, \lct{collect: \emph{aBlock}}, \lct{select: \emph{aBlock}}, \lct{ reject: \emph{aBlock}}, \lct{detect: \emph{aBlock}}, \lct{detect: \emph{aBlock} ifNone: \emph{aNoneBlock}}, \\
& \lct{inject: \emph{aValue} into: \emph{aBinaryBlock}}	\\
\hline
\protind{converting}	&	\lct{asBag}, \lct{asSet}, \lct{asOrderedCollection}, \lct{asSortedCollection}, \\
& \lct{asArray}, \lct{asSortedCollection: \emph{aBlock}}	\\
\hline
\protind{creation}		&	\lct{with: \emph{anElement}}, \lct{with:with:}, \lct{with:with:with:}, \\
& \lct{with:with:with:with:}, \lct{withAll: \emph{aCollection}}	\\
\hline
\end{tabular}
\caption{Protocolos est\'andar de Collection \figlabel{protocols}}
\end{center}
\end{figure*}

%\begin{figure*}
%\begin{center}
%\includegraphics[width=\textwidth]{CollectionsBySeq}
%\caption{Collections can be categorized according to whether or not they are sequenceable, \ie whether there are clearly defined first and last elements. All of the sequenceable collections except linked lists can also be indexed by an integer key. Of the non-sequenceable collections, dictionaries can be accessed by an arbitrary key, such as a string, while sets and bags cannot.\figlabel{CollsBySeq}}%
%\end{center}
%\end{figure*}
%\on{A useless diagram -- refer to the class hierarchy instead!}

M\'as all\'a de esta uniformidad b\'asica, hay muchos tipos de colecciones diferentes tambi\'en soportando diferentes protocolos, o proveyendo diferente comportamiento para los mismos mensajes.
Hagamos un breve estudio de algunas de las principales diferencias:

\begin{itemize}
  \item {\bf Sequenceable:}
  Las instancias de las subclases de \clsind{SequenceableCollection} empiezan con un primer elemento (obtenido con \mthind{SequenceableCollection}{first}) y son procesadas en un orden bien definido hasta el \'ultimo elemento (obtenido con \mthind{SequenceableCollection}{last}).
  Las instancias de \clsind{Set}, \clsind{Bag} y \clsind{Dictionary}, por otro lado, no son secuenciables.

  \item {\bf Sortable:}
  Una colecci\'on \clsind{SortedCollection} mantiene sus elementos en un orden determinado.

  \item {\bf Indexable:}
	La mayor\'ia de las colecciones secuenciables son tambi\'en indexables, esto es, sus elementos pueden ser recuperador con \ct{at:}.
	\clsind{Array} es la estructura de datos indexada conocida con un tama\~{n}o fijo;  \ct{unArray at: n} recupera el $\mbox{\ct{n}}-esimo$ elemento de \ct{unArray}, y \ct{unArray at: n put: v} cambia el $\mbox{\ct{n}}-esimo$ elemento a \ct{v}.
	las instancias de \ct{LinkedList} y \ct{SkipList} son secuenciables pero no indexables, esto es, entienden los mensajes \ct{first} y \ct{last}, pero no \ct{at:}.
	\clsindex{LinkedList}
	\clsindex{SkipList}

  \item {\bf Keyed:}
	Las instancias de \clsind{Dictionary} y sus subclases son accedidas por claves en vez de \'indices.

  \item {\bf Mutable:}
  La mayor\'ia de las colecciones son mutables, pero las instancias de \ct{Interval} y \ct{Symbol} no lo son.
	Un \clsind{Interval} es una colecci\'on inmutable que representa un rango de \ct{Integer}s.  Por ejemplo, \ct{5 to: 16 by: 2} es un intervalo que contiene los elementos 5, 7, 9, 11, 13 y 15. Es indexable con \mthind{Interval}{at:}, pero no puede ser cambiada usando \ct{at:put:}.
	\clsindex{Symbol}

  \item {\bf Growable:}
  	Las instancias de \ct{Interval} y \clsind{Array} son siempre de tama\~{n}o fijo. Otro tipo de colecciones (sorted collections, ordered collections, y linked lists) pueden crecer luego de su creaci\'on.
	
	La clase \clsind{OrderedCollection} es m\'as general que \ct{Array}; el tama\~{n}o en una \ct{OrderedCollection} crece bajo demanda, y tiene m\'etodos para agregar al inicio (\mthind{OrderedCollection}{addFirst:}) y al final (\mthind{OrderedCollection}{addLast:}) as\'i como tambi\'en \mthind{OrderedCollection}{at:} y \mthind{OrderedCollection}{at:put:}.
  
  \item {\bf Duplicados:}
  	Un \clsind{Set} filtrar\'a duplicados, , pero un \clsind{Bag} no.
	\clsind{Dictionary}, \ct{Set} y \ct{Bag} usan el m\'etodo \ct{=} provisto en los elementos; las variantes \ct{Identity} de estas clases usan el m\'etodo \ct{==}, que verifica si los argumentos son el mismo objeto, y las variables \ct{Pluggable} usan una relaci\'on de equivalencia arbitraria suministrada por el creador de la colecci\'on.
	\index{Colecciones Pluggable}

  \item {\bf Heterog\'eneas:}
  	La mayor\'ia de las colecciones contendr\'an cualquier tipo de elementos.
	Un \clsind{String}, \clsind{CharacterArray} \'o \clsind{Symbol}, sin embargo, s\'olo contendr\'an instancias de \ct{Character}.
	Un \clsind{Array} contendr\'a una mezcla de objetos, pero un \lct{ByteArray} s\'olo contiene instancias de \ct{Byte}, un \clsind{IntegerArray} s\'olo contiene instancias de \ct{Integer} y un \clsind{FloatArray} s\'olo instancias de \ct{Float}.
	Una \clsind{LinkedList} est\'a restringida a contener elementos que se ajustan al protocolo \prot{Link \go accessing}.

\end{itemize}

%  How is the order established? Sorted collections use a supplied total ordering function, intervals are implicitly ordered, while arrays and ordered collections are ordered explicitly when elements are inserted.

%=========================================================
\section{Implementaciones de colecciones}
\seclabel{implementation}

\begin{figure*}
\begin{center}
\includegraphics[width=\textwidth]{CollectionsByImpl}
\caption{Algunas clases de colecciones categorizadas por la t\'ecnica de implementaci\'on.
    \figlabel{collsByImpl}}
\end{center}
\end{figure*}

Estas categorizaciones por funcionalidad no son nuestra \'unica preocupaci\'on; debemos considerar tambi\'en c\'omo est\'an implementadas las clases de colecciones. Como se muestra en \figref{collsByImpl}, cinco t\'ecnicas principales de implementaci\'on son empleadas.

\begin{enumerate}
  \item Los Arrays almacenan sus elementos en las variables de instancia (indexables) del objeto colecci\'on en s\'i mismo; como consecuencia, los arrays deben ser de tama\~{n}o fijo, pero pueden ser creados con una alocaci\'on de memoria simple.
  \clsindex{Array}
  \item \clsind{OrderedCollections} y \clsind{SortedCollections} almacenan sus elementos en un array que es referenciado por una de las variables de instancia de la colecci\'on.
Consecuentemente, el array interno puede ser reemplazado por uno m\'as largo si la colecci\'on crece m\'as all\'a de su capacidad de almacenamiento.
  \item Los varios tipos de conjuntos y diccionarios tambi\'en referencian un array auxiliar para el almacenamiento, pero usan el array como una tabla hash. Los Bags usan un \ct{Dictionary} auxiliar, con los elementos de ese bag como claves y el n\'umero de ocurrencias como valores.
  \clsindex{Bag}
  \item Las LinkedLists usan una representaci\'on est\'andar simplemente enlazada.
  \clsindex{LinkedList}
  \item Los Intervals son representados por tres enteros que registran los dos puntos finales y el tama\~{n}o del paso.
  \clsindex{Interval}
\end{enumerate}
Adem\'as de estas clases, hay tambi\'en variantes``\subind{Collection}{weak}'' de \ct{Array}, \ct{Set} y de los varios tipos de dictionary.  \'Estas colecciones contienen sus elementos de manera d\'ebil, \ie de una forma tal que no previenen que los elementos sean reclamados por el garbage collector.
La m\'aquina virtual de \pharo es consciente de estas clases y las maneja de manera especial.
\index{weak collections}

Los lectores interesados en aprender m\'as acerca de las colecciones de \st pueden referir al excelente libro de LaLonde y Pugh' \cite{LaLo90a}.

%=========================================================
\section{Ejemplos de clases clave}
Ahora presentamos las clases m\'as comunes e importantes de colecciones usando ejemplos de c\'odigo sencillos.
Los principales protocolos de colecciones son: \mthind{Collection}{at:}, \mthind{Collection}{at:put:} --- para acceder a un elemento, \mthind{Collection}{add:}, \mthind{Collection}{remove:} --- para agregar o quitar un elemento, \mthind{Collection}{size}, \mthind{Collection}{isEmpty}, \mthind{Collection}{include:} --- para obtener determinada informaci\'on sobre la colecci\'on, \mthind{Collection}{do:}, \mthind{Collection}{collect:}, \mthind{Collection}{select:} --- para iterar sobre  la colecci\'on. 
Cada colecci\'on podr\'ia o no implementar dichos protocolos, y cuando lo hacen, los interpretan para encajar en su sem\'antica. Le sugerimos que heche un vistazo a las clases para identificar protocolos m\'as espec\'ificos y avanzados.
\seeindex{do:@\ct{do:}}{Collection, \ct{do:}}
\seeindex{at:@\ct{at:}}{Collection, \ct{at:}}
\seeindex{at:put:@\ct{at:put:}}{Collection, \ct{at:put:}}

Nos enfocaremos en las colecciones m\'as comunes: \clsind{OrderedCollection}, \clsind{Set}, \clsind{SortedCollection}, \clsind{Dictionary}, \clsind{Interval}, y \clsind{Array}.

\paragraph{Protocolo com\'un de creaci\'on.}
Hay muchas maneras de crear instancias de colecciones. Las m\'as gen\'ericas usan los m\'etodos \mthind{Collection class}{new:} y \mthind{Collection class}{with:}. \ct{new: anInteger} crea una colecci\'on de tama\~{n}o \ct{anInteger} cuyos elementos ser\'an todos \ct{nil}. \mthind{Collection class}{with:} \ct{anObject} crea una colecci\'on y agrega \ct{anObject} a la colecci\'on creada. Diferentes tipos de colecciones realizar\'an este comportamiento de manera diferente.

Puede crear colecciones con elementos iniciales usando los m\'etodos \mthind{Collection class}{with:}, \mthind{Collection class}{with:with:} \etc para hasta seis elementos.

\begin{code}{@TEST}
Array with: 1 --> #(1)
Array with: 1 with: 2 --> #(1 2)
Array with: 1 with: 2 with: 3 --> #(1 2 3)
Array with: 1 with: 2 with: 3 with: 4 --> #(1 2 3 4)
Array with: 1 with: 2 with: 3 with: 4 with: 5 --> #(1 2 3 4 5)
Array with: 1 with: 2 with: 3 with: 4 with: 5 with: 6 --> #(1 2 3 4 5 6)
\end{code}

Puede usar tambi\'en \ct{addAll:} para agregar todos los elementos de un tipo de colecci\'on a otra de otro tipo:

\begin{code}{@TEST}
(1 to: 5) asOrderedCollection addAll: '678'; yourself --> an OrderedCollection(1 2 3 4 5 $6 $7 $8)
\end{code}
\noindent
Tenga cuidado que \mthind{Collection}{addAll:} tambi\'en retorna su argumento, y no el objeto receptor!

Tambi\'en puede crear muchas colecciones con \mthind{Collection class}{withAll:} \'o \mthind{Collection class}{newFrom:}

\begin{code}{@TEST}
Array withAll: #(7 3 1 3)                      --> #(7 3 1 3)
OrderedCollection withAll: #(7 3 1 3) --> an OrderedCollection(7 3 1 3)
SortedCollection withAll: #(7 3 1 3)    --> a SortedCollection(1 3 3 7)
Set withAll: #(7 3 1 3)                         --> a Set(7 1 3)
Bag withAll: #(7 3 1 3)                        --> a Bag(7 1 3 3)
Dictionary withAll: #(7 3 1 3)               --> a Dictionary(1->7 2->3 3->1 4->3 )
\end{code}

\needlines{3}
\begin{code}{@TEST}
Array newFrom: #(7 3 1 3)                                          --> #(7 3 1 3)
OrderedCollection newFrom: #(7 3 1 3)                     --> an OrderedCollection(7 3 1 3)
SortedCollection newFrom: #(7 3 1 3)                       --> a SortedCollection(1 3 3 7)
Set newFrom: #(7 3 1 3)                                            --> a Set(7 1 3)
Bag newFrom: #(7 3 1 3)                                           --> a Bag(7 1 3 3)
Dictionary newFrom: {1 -> 7. 2 -> 3. 3 -> 1. 4 -> 3} --> a Dictionary(1->7 2->3 3->1 4->3 )
\end{code}
\noindent
Notar que esos m\'etodos no son id\'enticos.
En particular, \cmind{Dictionary class}{withAll:} interpreta su argumento como una colecci\'on de valores, mientras que \cmind{Dictionary class}{newFrom:} espera una colecci\'on de asociaciones (associations).

%---------------------------------------------------------
\subsection{Array}
Un \clsindmain{Array} es una colecci\'on de tama\~{n}o fijo de elementos accedidos por \'indices enteros.
Al contrario que la convenci\'on de C, el primer elemento de un array en \st est\'a en la posici\'on 1 y no en la 0. 
El protocolo principal para acceder a los elementos del array es el m\'etodo \mthind{Array}{at:} y \mthind{Array}{at:put:}. \ct{at: anInteger} retorna el elemento en el \'indice \ct{anInteger}. \ct{at: anInteger put: anObject} coloca \ct{anObject} en el \'indice \ct{anInteger}. Los arrays son colecciones de tama\~{n}o fijo y por ende no podemos agregar o quitar elementos al final de un array. El siguiente c\'odigo crea un array de tama\~{n}o 5, pone valores en las primeras 3 ubicaci\'on y retorna el primer elemento. 

\begin{code}{@TEST | anArray | }
anArray := Array new: 5.
anArray at: 1 put: 4.
anArray at: 2 put: 3/2.
anArray at: 3 put: 'ssss'.
anArray at: 1 --> 4
\end{code}

Hay varias formas de crear instancias de la clase \clsind{Array}. Podemos usar \ct{new:}, \ct{with:}, y las construcciones \ct{#( )} y \ct|{ }|.

\paragraph{Creaci\'on con \mthind{Array class}{new:}} \ct{new: anInteger} crea un array de tama\~{n}o \ct{anInteger}.
\ct{Array new: 5} crea un array de tama\~{n}o 5.

\paragraph{Creaci\'on con \mthind{Array class}{with:}} Los m\'etodos \ct{with:} permiten a uno especificar el valor de los elementos.  
El siguiente c\'odigo crea un array de tres elementos que consiste en el n\'umero \ct{4}, la fracci\'on \ct{3/2} y la cadena de caracteres \ct{'lulu'}.

\begin{code}{@TEST | anArray |}
Array with: 4 with: 3/2 with: 'lulu' -->  {4 . (3/2) . 'lulu'}
\end{code}

\paragraph{Creaci\'on de literales con \ct|\#()|.}
\ct{#()} crea \ind{arrays literales} con elementos est\'aticos (\'o ``\subind{Array}{literal}'') que deben ser conocidos cuando la expresi\'on se compila, y no cuando es ejecutada. El siguiente c\'odigo crea un array de tama\~{n}o 2 donde el primer elemento es el n\'umero (literal) \ct{1} y el segundo es la cadena de caracteres (literal) \ct{'here'}.

\seeindex{\#@{\textsf{\#( )}}}{Array, literal}
\seeindex{\{@{\textsf{\{ \}}}}{Array, dynamic}

\begin{code}{@TEST | anArray |}
#(1 'here') size --> 2
\end{code}

Ahora bien, si eval\'ua \ct{#(1+2)}, no se obtiene un array con un elemento simple \ct{3} sino el array \ct{#(1 #+ 2)} \ie con tres elementos: \ct{1}, el s\'imbolo \ct{#+} y el n\'umero \ct{2}.

\begin{code}{@TEST}
#(1+2) -->  #(1 #+ 2)
\end{code}

\noindent
Esto ocurre porque el constructor \ct{#()} causa que el compilador interprete literalmente la expresi\'on contenida en el array. La expresi\'on es escaneada y los elementos resultantes alimentan el nuevo array. Los arrays literales contienen n\'umeros, \ct{nil}, \ct{true}, \ct{false}, s\'imbolos y cadenas de caracteres.

\paragraph{Creaci\'on din\~{n}amica con \ct|\{ \}|.}
Finalmente, puede crear un array de manera din\'amica usando el constructor \ct|{}|. \ct|{ a . b }| es equivalente a \lct{Array with: a with: b}. Esto siginifica en particular que las expresiones encerradas por \ct|{| y \ct|}| son ejecutadas. 

\begin{code}{@TEST | anArray |}
{ 1 + 2 } --> #(3)
{(1/2) asFloat} at: 1 --> 0.5
{10 atRandom . 1/3} at: 2 --> (1/3)
\end{code}

\paragraph{Acceso a los elementos.}
Los elementos de todas las colecciones secuenciables pueden ser accedidos con \mthind{Array}{at:} y \mthind{Array}{at:put:}.

\begin{code}{@TEST | anArray |}
anArray := #(1 2 3 4 5 6) copy.
anArray at: 3 --> 3
anArray at: 3 put: 33.
anArray at: 3 --> 33
\end{code}
\cmindex{Array}{copy}

\noindent
Tenga cuidado con el c\'odigo que modifica arrays literales!
El compilador intenta asignar espacio s\'olo una vez para arrays literales.
A menos que copie el array, la segunda vez que eval\'ua el c\'odigo su array ``literal'' quiz\'as no tenga el valor que espera.
(Sin la clonaci\'on, la segunda vez, el literal \ct{#(1 2 3 4 5 6)} ser\'a en realidad \ct{#(1 2 33 4 5 6)}!)
Los arrays din\'amicos no tienen este problema.

%---------------------------------------------------------
\subsection{OrderedCollection}
\clsindmain{OrderedCollection} es una de las colecciones que puede crecer de tama\~{n}o, y para la cual los elementos pueden ser agregados secuencialmente. Ofrece una variedad de m\'etodos tales como \mthind{OrderedCollection}{add:}, \mthind{OrderedCollection}{addFirst:}, \mthind{OrderedCollection}{addLast:}, y \mthind{OrderedCollection}{addAll:}. 

\begin{code}{@TEST | ordCol |}
ordCol := OrderedCollection new.
ordCol add: 'Seaside'; add: 'SqueakSource'; addFirst: 'Monticello'.
ordCol --> an OrderedCollection('Monticello' 'Seaside' 'SqueakSource')
\end{code}

\paragraph{Quitar elementos.} El m\'etodo \mthind{OrderedCollection}{remove:} \ct{anObject} remueve la primera ocurrencia de anObject de la colecci\'on. Si la colecci\'on no incluye el objeto, levanta un error. 

\begin{code}{@TEST | ordCol | ordCol := OrderedCollection with: 'Monticello' with: 'Seaside' with: 'SqueakSource'.}
ordCol add: 'Monticello'.
ordCol remove: 'Monticello'.
ordCol --> an OrderedCollection('Seaside' 'SqueakSource' 'Monticello')
\end{code}

Hay una variante de\ct{remove:} llamada \mthind{OrderedCollection}{remove:ifAbsent:} que permite a uno especificar como segundo argumento un bloque que es ejecutado en caso que el elemento a ser removido no est\'e en la colecci\'on. 

\begin{code}{@TEST | ordCol res | ordCol := OrderedCollection with: 'Seaside' with: 'SqueakSource' with: 'Monticello'.}
res := ordCol remove: 'zork' ifAbsent: [33].
res --> 33
\end{code}

\paragraph{Conversi\'on.}
Es posible obtener una \ct{OrderedCollection} a partir de un \ct{Array} (o de cualquier otra colecci\'on) enviando el mensaje \mthind{Collection}{asOrderedCollection}:

\begin{code}{@TEST}
#(1 2 3) asOrderedCollection --> an OrderedCollection(1 2 3)
'hello' asOrderedCollection --> an OrderedCollection($h $e $l $l $o)
\end{code}

%\paragraph{A word about automatic growth.}
%Note that while \ct{OrderedCollection} grows automatically when you add new elements it can be better to create an \ct{OrderedCollection} with a good approximation of the numbers of elements it will contain. The following code creates an ordered collection whose size is equal to the number of classes in \pharo and adds all the classes to it.

% \on{I don't like this example. No one should ever write code like this. Furthermore it is not good advice, as you almost never need to do this.}

%\begin{code}{@TEST | classes res | }
%classes := Smalltalk allClasses.
%res := OrderedCollection new: classes size.
%classes do: [:each | res add: each].
%classes size = res size --> true
%\end{code}

%\noindent
%This can be faster than creating the ordered collection with \ct{new} and letting it grow (see \charef{profiling}).

%---------------------------------------------------------
\subsection{Interval}
La clase \clsindmain{Interval} representa rangos de n\'umeros. Por ejemplo, el intervalo de n\'umeros de 1 a 100 se define de la siguiente manera:
\cmindex{Interval class}{from:to:}
\begin{code}{@TEST}
Interval from: 1 to: 100 --> (1 to: 100)
\end{code}

\noindent
El m\'etodo \mthind{Interval class}{printString} de este intervalo revela que la clase \ct{Number} nos provee un m\'etodo c\'omodo llamado \mthind{Number}{to:} para generar intervalos:

\begin{code}{}
(Interval from: 1 to: 100) = (1 to: 100) --> true
\end{code}

Podemos usar \cmind{Interval class}{from:to:by:} \'o \cmind{Number}{to:by:} para especificar los pasos entre dos n\'umeros de la siguiente manera:

\begin{code}{@TEST}
(Interval from: 1 to: 100 by: 0.5) size --> 199
(1 to: 100 by: 0.5) at: 198 --> 99.5
(1/2 to: 54/7 by: 1/3) last --> (15/2)
\end{code}

%---------------------------------------------------------
\subsection{Dictionary}
Los diccionarios son colecciones importantes cuyos elementos son accedidos usando claves. 
Entre los mensajes m\'as com\'unmente usados de los diccionarios puede encontrar \mthind{Dictionary}{at:}, \mthind{Dictionary}{at:put:}, \mthind{Dictionary}{at:ifAbsent:}, \mthind{Dictionary}{keys} y \mthind{Dictionary}{values}.
\seeindex{keys}{Dictionary, keys}
\seeindex{values}{Dictionary, values}

\begin{code}{@TEST | colors |}
colors := Dictionary new.
colors at: #yellow put: Color yellow.
colors at: #blue put: Color blue.
colors at: #red put: Color red.
colors at: #yellow --> Color yellow
colors keys          --> a Set(#blue #yellow #red)
colors values       --> {Color blue . Color yellow . Color red}
\end{code}

Los diccionarios comparan las claves por igualdad. Dos claves son consideradas las mismas si retornan \ct{true} cuando se comparan usando \ct{=}. Un problema com\'un y dif\'icil de reconocer es usar como clave un objeto cuyo m\'etodo \ct{=} ha sido redefinido pero no as\'i su m\'etodo \ct{hash}. Ambos m\'etodos son usados en la implementaci\'on del diccionario y cuando se comparan objetos.
\index{Dictionary! Redefiniendo \ct{=} y \ct{hash}}

La clase \clsindmain{Dictionary} ilustra claramente que la jerarqu\'ia de colecciones est\'a basada en la subclasificaci\'on y no en la subtificaci\'on. A pesar que \ct{Dictionary} es una subclase de \clsind{Set}, no quisi\'eramos usar normalmente un\ct{Dictionary} donde se espera un \ct{Set}. En su implementaci\'on, sin embargo, un \ct{Dictionary} puede ser claramente visto como un conjunto de asociaciones (clave valor) creados usando el mensaje \mthind{Object}{->}. Podemos crear un \ct{Dictionary} a partir de una colecci\'on de asociaciones, o bien convertir un diccionario a un array de asociaciones.
\seeindex{association}{Object, \ct{->}}

\needlines{5}
\begin{code}{@TEST | colors |}
colors := Dictionary newFrom: { #blue->Color blue. #red->Color red. #yellow->Color yellow }.
colors removeKey: #blue.
colors associations --> {#yellow->Color yellow . #red->Color red}
\end{code}

\paragraph{IdentityDictionary.}
Mientras un diccionario usa el resultado de los mensajes \ct{=} y \ct{hash} para determinar si dos claves son la misma, la clase \clsindmain{IdentityDictionary} usa la identidad (mensaje \mthind{ProtoObject}{==}) de las claves en vez de sus valores, \ie considera dos claves iguales \emph{s\'olo} si son el mismo objeto.

A menudo las instancias de \ct{Symbol} son usadas como clave, en cuyo caso es natural usar un \ct{IdentityDictionary}, dado que\clsind{Symbol} garantiza ser globalmente \'unico.
Si, por el contrario, sus claves son cadenas de caracteres (\ct{String}), es mejor usar un \ct{Dictionary}, o es probable que tenga problemas:

\begin{code}{@TEST | a b trouble |}
a := 'foobar'.
b := a copy.
trouble := IdentityDictionary new.
trouble at: a put: 'a'; at: b put: 'b'.
trouble at: a          --> 'a'
trouble at: b          --> 'b'
trouble at: 'foobar' --> 'a'
\end{code}

\noindent
Dado que \ct{a} y \ct{b} son objetos diferentes, son tratados como objetos diferentes.
Es interesante notar que el literal \mbox{\ct{'foobar'}} es instanciado s\'olo una vez, por lo cual es realmente el mismo objeto que \ct{a}.
Usted no quiere que su c\'odigo dependa en un comportamiento como \'este!
Un \ct{Dictionary} le dar\'ia el mismo valor para cualquier clave igual a \ct{'foobar'}.

Use s\'olo objetos \'unicos globalmente (como instancias de \ct{Symbol} \'o \ct{SmallInteger}) como claves de un \ct{IdentityDictionary}, y cadenas de caracteres (u otros objetos) como claves de un \ct{Dictionary}.


Notar que \glbind{Smalltalk} es una instancia de \clsind{SystemDictionary}, una subclase de \ct{IdentityDictionary}, y por lo tanto, todas sus claves son instancias de \ct{Symbol} (en realidad de \ct{ByteSymbol}, que contiene s\'olo caracteres de 8 bits).

\begin{code}{@TEST}
Smalltalk keys collect: [ :each | each class ] --> a Set(ByteSymbol)
\end{code}
\noindent
Enviando \ct{keys} \'o \ct{values} a un \ct{Dictionary} resulta en un \ct{Set}, que veremos a continuaci\'on.
% Since every key has the same class, the set of classes of keys contains only a single element, \ct{ByteSymbol}.

%---------------------------------------------------------
\subsection{Set}
La clase \clsindmain{Set} es una colecci\'on que se comporta como un conjunto matem\'atico, \ie como una colecci\'on sin elementos duplicados y sin ning\'un orden. En un \ct{Set} los elementos se agregan usando el mensaje \mthind{Set}{add:} y no pueden ser accedidos usando el mensaje \ct{at:}. Los objetos colocados en un conjunto deben implementar los m\'etodos \ct{hash} y \ct{=}.

\begin{code}{@TEST | s | }
s := Set new.
s add: 4/2; add: 4; add:2.
s size --> 2
\end{code}

Tambi\'en puede crear conjuntos usando \cmind{Set class}{newFrom:} o el mensaje de conversi\'on \cmind{Collection}{asSet}:

\begin{code}{@TEST}
(Set newFrom: #( 1 2 3 1 4 )) = #(1 2 3 4 3 2 1) asSet --> true
\end{code}

\mthind{Collection}{asSet} nos ofrece una forma c\'omoda de eliminar duplicados de una colecci\'on:
\begin{code}{@TEST}
{ Color black. Color white. (Color red + Color blue + Color green) } asSet size --> 2
\end{code}
\noindent
Notar que red + blue + green = white.

Un \clsindmain{Bag} es muy similar a un \ct{Set} excepto que permite duplicados:
\begin{code}{@TEST}
{ Color black. Color white. (Color red + Color blue + Color green) } asBag size --> 3
\end{code}

Las operaciones de conjuntos \emph{uni\'on}, \emph{intersecci\'on} e \emph{inclusi\'on} son implementados por los mensajes de \ct{Collection}  \mthind{Collection}{union:}, \mthind{Collection}{intersection:} y \mthind{Collection}{includes:}.
El receptor es convertido primero a un \ct{Set}, por lo que \'estas operaciones funcionan para todos los tipos de colecciones!
\seeindex{Set!union}{Collection, \ct{union:}}
\seeindex{Set!intersection}{Collection, \ct{intersection:}}
\seeindex{Set!membership}{Collection, \ct{includes:}}

\begin{code}{@TEST}
(1 to: 6) union: (4 to: 10)  --> a Set(1 2 3 4 5 6 7 8 9 10)
'hello' intersection: 'there' --> 'he'
#Smalltalk includes: $k     --> true
\end{code}

Como explicamos m\'as abajo, los elementos de un conjunto son accedidos usando iteradores (ver \secref{iterators}).

%---------------------------------------------------------
\subsection{SortedCollection}
En contraste a una \ct{OrderedCollection}, una \clsindmain{SortedCollection} mantiene sus elementos en un orden particular. 

Por defecto, una sorted collection usa el mensaje \mthind{Magnitude}{<=} para establecer el orden de los elementos, por lo cual puede ordenar instancias de subclases de la clase abstracta \clsind{Magnitude}, que define el protocolo de objetos comparables (\mthind{Magnitude}{<}, \mthind{Magnitude}{=}, \mthind{Magnitude}{>}, \mthind{Magnitude}{>=}, \mthind{Magnitude}{between:and:}...).
(Vea \charef{basic}.)


Puede crear una \ct{SortedCollection} creando una nueva instancia y agregando elementos a ella:
\begin{code}{@TEST}
SortedCollection new add: 5; add: 2; add: 50; add: -10; yourself. --> a SortedCollection(-10 2 5 50)
\end{code}

\noindent
Por lo general, sin embargo, uno querr\'a enviar el mensaje de conversi\'on \mthind{Collection}{asSortedCollection} a una colecci\'on existente:
\begin{code}{@TEST}
#(5 2 50 -10) asSortedCollection --> a SortedCollection(-10 2 5 50)
\end{code}

Este ejemplo responde la siguiente pregunta frecuente (FAQ):

\important{FAQ: ?`C\'omo se ordena una colecci\'on?\\
{\sc Respuesta}: Env\'ie el mensaje \ct{asSortedCollection} a la colecci\'on.}

\begin{code}{@TEST}
'hello' asSortedCollection --> a SortedCollection($e $h $l $l $o)
\end{code}

?`C\'omo puede obtener una cadena de caracteres (\ct{String}) nuevamente a partir de este resultado?
\ct{asString} desafortunadamente retorna la representaci\'on dada por \ct{printString}, que no es lo que queremos:
\begin{code}{@TEST}
'hello' asSortedCollection asString --> 'a SortedCollection($e $h $l $l $o)'
\end{code}
\noindent
La respuesta correcta es usar \ct{String class>>>newFrom:}, \ct{String class>>>withAll:} \'o \ct{Object>>>as:}:
\begin{code}{@TEST}
'hello' asSortedCollection as: String              --> 'ehllo'
String newFrom: ('hello' asSortedCollection) --> 'ehllo'
String withAll: ('hello' asSortedCollection)     --> 'ehllo'
\end{code}
\seeindex{Collection!sorting}{Collection, \ct{asSortedCollection}}

Es posible tener diferentes tipos de elementos en una \ct{SortedCollection} en tanto sean coparables entre ellos. Por ejemplo podemos tener diferentes tipos de n\'umeros tales como enteros, de coma flotante y fracciones:
\begin{code}{@TEST | col |}
{ 5. 2/-3. 5.21 } asSortedCollection --> a SortedCollection((-2/3) 5 5.21)
\end{code}

Imagine que quiere ordenar objetos que no definen el m\'etodo \ct{<=} o que quisiera tener un criterio diferente de ordenamiento. Usted puede hacer esto suministrando un bloque de dos argumentos, denominado bloque de ordenamiento o sortblock, a la sorted collection. Por ejemplo, la clase \ct{Color} no es una subclase de Magnitude y no implementa el m\'etodo \ct{<=}, pero podemos especificar un bloque que estableza que los colores deben ser ordenados de acuerdo a la luminiscencia (una medida de brillo).

\begin{code}{@TEST | col |}
col := SortedCollection sortBlock: [:c1 :c2 | c1 luminance <= c2 luminance].
col addAll: { Color red. Color yellow. Color white. Color black }.
col --> a SortedCollection(Color black Color red Color yellow Color white)
\end{code}
\cmindex{SortedCollection class}{sortBlock:}

%---------------------------------------------------------
\subsection{String}
Una cadena de caracteres (\clsindmain{String}) en \st representa una colecci\'on de instancias de \ct{Character}.
Es secuenciable, indexable, mutable y homog\'enea, y contiene s\'olo instancias de \clsind{Character}.
De la misma forma que los \ct{Array}s, los \ct{String}s tienen una sintaxis particular, y son creados normalmente especificando directamente un literal entre comillas simples, aunque los mensajes de creaci\'on comunes de colecciones tambi\'en funcionar\'an.

\begin{code}{@TEST | s1 s2 |}
'Hello'                                             --> 'Hello'
String with: $A                               --> 'A'
String with: $h with: $i with: $BANG       --> 'hiBANG'
String newFrom: #($h $e $l $l $o) --> 'hello'
\end{code}

En realidad, \ct{String} es abstracta.
Cuando instanciamos un \ct{String} podemos obtener un \clsind{ByteString} de 8 bits \'o un \clsind{WideString} de 32 bits.
Para mantener las cosas simples, nosotros ignoraremos usualmente la diferencia y simplemente hablaremos de instancias de \ct{String}.

Dos instancias de \ct{String} pueden ser concatenadas con una coma.
\index{Collection!comma operator}
\begin{code}{@TEST |s|}
s := 'no', ' ', 'worries'.
s -->  'no worries'
\end{code}

Dado que un cadena de caracteres es una colecci\'on mutable podemos adem\'as cambiarla usando el m\'etodo \mthind{String}{at:put:}.

\begin{code}{@TEST |s| s := 'no', ' ', 'worries'.}
s at: 4 put: $h; at: 5 put: $u.
s --> 'no hurries'
\end{code}

Notar que el m\'etodo coma se define en \ct{Collection}, por lo cual funcionar\'a para todo tipo de colecciones!
\begin{code}{@TEST}
(1 to: 3) , '45' --> #(1 2 3 $4 $5)
\end{code}
\seeindex{String!concatenation}{Collection, comma operator}
\seeindex{String!comma}{Collection, comma operator}
\index{Collection!comma operator}

Podemos tambien modificar un string existente usando \mthind{String}{replaceAll:with:} \'o \mthind{String}{replaceFrom:to:with:} como se muestra a continuaci\'on. Notar que el n\'umero de caracteres y el intervalo deber\'ian tener el mismo tama\~{n}o.

\begin{code}{@TEST |s| s := 'no hurries' copy.}
s replaceAll: $n with: $N.
s --> 'No hurries'
s replaceFrom: 4 to: 5 with: 'wo'.
s --> 'No worries'
\end{code}

En contraste a los m\'etodos descriptos anteriormente, el m\'etodo \mthind{String}{copyReplaceAll:} crea una nueva cadema de caracteres.
(Curiosamente, aqu\'i los argumentos son subcadenas y no caracteres individuales, y sus tama\~{n}os no deben coincidir necesariamente.)

\begin{code}{@TEST |s| s:= 'No worries' copy.}
s copyReplaceAll: 'rries' with: 'mbats' --> 'No wombats'
\end{code}

Una vista r\'apida por la implementaci\'on de estos m\'etodos revela que est\'an definidos no solamente para los \ct{String}s, sino para todos los tipos de \ct{SequenceableCollection}, por lo que el siguiente c\'odigo tambi\'en funciona:

\begin{code}{@TEST}
(1 to: 6) copyReplaceAll: (3 to: 5) with: { 'three'. 'etc.' } --> #(1 2 'three' 'etc.' 6)
\end{code}

\paragraph{Correspondencia de cadenas de caracteres.}
\index{String!pattern matching}
Es posible preguntar si un patr\'on corresponde con una cadena de caracteres enviando el mensaje \mthind{String}{match:}.
El patr\'on puede especificar \ct{*} para indicar una serie arbitraria de caracteres y \# para indicar un caracter simple. Notar que \ct{match:} es enviado al patr\'on y no a la cadena de caracteres.
\begin{code}{@TEST}
'Linux *' match: 'Linux mag'                      --> true
'GNU/Linux #ag' match: 'GNU/Linux tag' --> true
\end{code}

Otro m\'etodo \'util es \ct{findString:}.
\begin{code}{@TEST}
'GNU/Linux mag' findString: 'Linux'                                                      --> 5
'GNU/Linux mag' findString: 'linux' startingAt: 1 caseSensitive: false  --> 5
\end{code}

M\'as facilidades avanzadas de correspondencia que ofrecen las capacidades de Perl est\'an tambi\'en disponibles en el paquete \pkgind{Regex}.

\paragraph{Algunas pruebas sobre las cadenas de caracteres.} Los siguientes ejemplos ilustran el uso de \mbox{\mthind{String}{isEmpty},} \mthind{String}{includes:} y \mthind{String}{anySatisfy:} que son mensajes adicionales definidos no s\'olo para las cadenas de caracteres sino tambi\'en para las colecciones en general.

\begin{code}{@TEST}
'Hello' isEmpty --> false
'Hello' includes: $a --> false
'JOE' anySatisfy: [:c | c isLowercase] --> false
'Joe' anySatisfy: [:c | c isLowercase] --> true
\end{code}

\paragraph{Plantillas de cadenas de caracteres.}
Hay tres mensajes que son \'utiles para manejar cadenas de caracteres \subind{String}{templating}: \mthind{String}{format:}, \mthind{String}{expandMacros} y \mthind{String}{expandMacrosWith:}.

\begin{code}{@TEST}
'{1} is {2}' format: {'Pharo' . 'cool'}  --> 'Pharo is cool'
\end{code}

Los mensajes de la familia de expandMacros ofrecen substituci\'on de variables, usando \ct{<n>} para el retorno de carro, \ct{<t>} para la tabulaci\'on, \ct{<1s>}, \ct{<2s>}, \ct{<3s>} para los argumentos (\ct{<1p>}, \ct{<2p>}, rodean la cadena de caracteres con comillas simples), y \ct{<1?valor1:valor2>} para condicionales.

\begin{code}{@TEST}
'look-<t>-here' expandMacros                                         --> 'look-	-here'
'<1s> is <2s>' expandMacrosWith: 'Pharo' with: 'cool'   --> 'Pharo is cool'
'<2s> is <1s>' expandMacrosWith: 'Pharo' with: 'cool'   --> 'cool is Pharo'
'<1p> or <1s>' expandMacrosWith: 'Pharo' with: 'cool'  --> '''Pharo'' or Pharo'
'<1?Quentin:Thibaut> plays' expandMacrosWith: true     --> 'Quentin plays'
'<1?Quentin:Thibaut> plays' expandMacrosWith: false    --> 'Thibaut plays'
\end{code}

\paragraph{Otros m\'etodos \'utiles.}
La clase \ct{String} ofrece otras numerosas utilidades incluyendo el mensaje \mthind{String}{asLowercase}, \mthind{String}{asUppercase} y \mthind{String}{capitalized}. 

\begin{code}{@TEST}
'XYZ' asLowercase --> 'xyz'
'xyz' asUppercase   --> 'XYZ'
'hilaire' capitalized   --> 'Hilaire'
'1.54' asNumber      --> 1.54
'esta sentencia es sin lugar a dudas demasiado larga' contractTo: 20 -->  'esta sent...do larga'
\end{code}

Notar que hay una diferencia entre preguntar a un objeto por su representaci\'on como cadena de caracteres enviando el mensaje \mthind{Object}{printString} y convertirlo en una cadena de caracteres enviando el mensaje \mthind{Object}{asString}.
Aqu\'i hay un ejemplo de la diferencia.

\begin{code}{@TEST}
#ASymbol printString --> '#ASymbol'
#ASymbol asString    --> 'ASymbol'
\end{code}

Un s\'imbolo es similar a una cadena de caracteres pero garantiza que es \'unico a nivel global. Por \'esta raz\'on los s\'imbolos son preferidos por sobre las cadenas de caracteres como claves de diccionarios, en particular para instancias de \ct{IdentityDictionary}.
Vea tambi\'en \charef{basic} para m\'as informaci\'on sobre cadenas de caracteres (\clsind{String}) y s\'imbolos (\clsind{Symbol}).

%=========================================================
\section{Iteradores de colecciones}
\seclabel{iterators}

En \st los bucles y condicionales son simplemente mensajes enviados a las colecciones u otros objetos tales como enteros o bloques (ver tambi\'en \charef{syntax}). Adem\'as de los mensajes de bajo nivel tales como \ct{to:do:} que eval\'ua un bloque con un argumento que van desde un n\'umero inicial a uno final, la jerarqu\'ia de colecciones de \st ofrece iteradores de alto nivel. Usando estos iteradores su c\'odigo ser\'a m\'as robusto y compacto. 
\index{Collection!iteration}

%---------------------------------------------------------
\subsection{Iterando (\lct{do:})}
El m\'etodo \mthind{Collection}{do:} es el iterador b\'asico de colecciones. Aplica su argumento (un bloque que toma un s\'olo argumento) a cada uno de los elementos del receptor.
El siguiente ejemplo imprime en el Transcript todas las cadenas de caracteres contenidas en el receptor.

\begin{code}{}
#('bob' 'joe' 'toto') do: [:each | Transcript show: each; cr].
\end{code}

\paragraph{Variantes.} Hay un mont\'on de variantes de \ct{do:}, tales como \mbox{\mthind{Collection}{do:without:},} \mbox{\mthind{SequenceableCollection}{doWithIndex:}} y \mthind{OrderedCollection}{reverseDo:}:
Para las colecciones indexadas (\ct{Array}, \ct{OrderedCollection}, \ct{SortedCollection}) el m\'etodo \mthind{SequenceableCollection}{doWithIndex:} tambi\'en da acceso al \'indice actual. \'este m\'etodo est\'a relacionado a \ct{to:do:} que est\'a definido en la clase \ct{Number}.

\begin{code}{@TEST}
#('bob' 'joe' 'toto') doWithIndex: [:each :i | (each = 'joe') ifTrue: [ ^ i ] ] --> 2
\end{code}

Para colecciones ordenadas, \mthind{OrderedCollection}{reverseDo:} recorre la colecci\'on en el orden inverso. 

El siguiente c\'odigo muestra un mensaje interesante: \mthind{Collection}{do:separatedBy:} que ejecuta el segundo bloque s\'olo entre dos elementos.
\begin{code}{@TEST | res | }
res := ''.
#('bob' 'joe' 'toto') do: [:e | res := res, e ] separatedBy: [res := res, '.'].
res --> 'bob.joe.toto'
\end{code}
\noindent
Notar que este c\'odigo no es especialmente eficiente dado que crea cadenas de caracteres intermedias y ser\'ia mejor usar un write stream para almacenar el resultado (ver \charef{streams}):
\begin{code}{@TEST}
String streamContents: [:stream | #('bob' 'joe' 'toto') asStringOn: stream delimiter: '.' ] --> 'bob.joe.toto'
\end{code}

% DAMIEN: I would write it:
%res := String streamContents: [:stream |
%  #('bob' 'joe' 'toto')
%       do: [:e | stream nextPutAll: e]
%       separatedBy: [stream nextPut: $.]].
%res --> 'bob.joe.toto'
%Or even simpler:
%res := String streamContents: [:stream | #('bob' 'joe' 'toto')
%asStringOn: stream delimiter: '.' ].
%res --> 'bob.joe.toto'


\paragraph{Diccionarios.}
Cuando el mensaje \mthind{Dictionary}{do:} es enviado a un diccionario, los elementos tomados en cuenta son valores, no las asociaciones. Los m\'etodos adecuados para usar son \mthind{Dictionary}{keysDo:}, \mthind{Dictionary}{valuesDo:}, y \mthind{Dictionary}{associationsDo:}, que iteran en las claves, valores o asociaciones respectivamente.

\begin{code}{}
colors := Dictionary newFrom: { #yellow -> Color yellow. #blue -> Color blue. #red -> Color red }.
colors keysDo: [:key | Transcript show: key; cr].                    "muestra las claves"
colors valuesDo: [:value | Transcript show: value;cr].            "muestra los valores"
colors associationsDo: [:value | Transcript show: value;cr].  "muestra las asociaciones"
\end{code}

%---------------------------------------------------------
\subsection{Colectando resultados (\lct{collect:})}
Si quiere procesar los elementos de una colecci\'on y producir una nueva como resultado, en vez de usar \ct{do:}, es mejor usar \ct{collect:}, o uno de los otros m\'etodos iteradores.
La mayor\'ia de \'estos pueden ser encontrados en el protocolo \protind{enumerating} de \ct{Collection} y sus subclases.

Imagine que queremos una colecci\'on que contenga los dobles de los elementos en otra colecci\'on. Usando el m\'etodo \ct{do:} debemos escribir lo siguiente:

\begin{code}{@TEST | double |}
double := OrderedCollection new.
#(1 2 3 4 5 6) do: [:e | double add: 2 * e].
double --> an OrderedCollection(2 4 6 8 10 12)
\end{code}

\noindent
El m\'etodo \mthind{Collection}{collect:} ejecuta su bloque argumento para cada elemento y retorna una nueva colecci\'on que contiene los resultados. 
Usando \ct{collect:} en cambio, el c\'odigo es mucho m\'as simple:
\begin{code}{@TEST}
#(1 2 3 4 5 6) collect: [:e | 2 * e] --> #(2 4 6 8 10 12)
\end{code}

Las ventajas de \ct{collect:} por sobre \mthind{Collection}{do:} son incluso m\'as dram\'aticas en el siguiente ejemplo, donde tomamos una colecci\'on de enteros y generamos como resultado una colecci\'o de los valores absolutos de esos enteros:

\begin{code}{@TEST |aCol result|}
aCol :=  #( 2 -3 4 -35 4 -11).
result := aCol species new: aCol size.
1 to: aCol size do: [ :each | result at: each put: (aCol at: each) abs].
result --> #(2 3 4 35 4 11)
\end{code}
\noindent
Contraste el c\'odigo anterior con la expresi\'on mucho m\'as simple a continuaci\'on:
\begin{code}{@TEST}
#( 2 -3 4 -35 4 -11) collect: [:each | each abs ] --> #(2 3 4 35 4 11)
\end{code}
\noindent
Una ventaja adicional de la segunda soluci\'on es que va a funcionar tambi\'en para conjuntos y bolsas (bags).

En general usted deber\'ia evitar el uso del \ct{do:}, a menos que quiera enviar mensajes a cada uno de los elementos de la colecci\'on.

Notar que el env\'io del mensaje \ct{collect:} retorna el mismo tipo de colecci\'on que el receptor.
Por esta raz\'on el siguiente c\'odigo falla.
(Un \ct{String} no puede contener valores enteros.)
\begin{code}{}
'abc' collect: [:ea | ea asciiValue ]      "errorBANG"
\end{code}
\noindent
Debemos primero convertir la cadena de caracteres a un \ct{Array} o a una \ct{OrderedCollection}:
\begin{code}{@TEST}
'abc' asArray collect: [:ea | ea asciiValue ] --> #(97 98 99)
\end{code}

En realidad \ct{collect:} no garantiza retornar una colecci\'on de exactamente la misma clase que el receptor, pero s\'i de la misma \emph{``especie''}. En el caso de un \ct{Interval}, la especie es en realidad un \ct{Array}!
\begin{code}{@TEST}
(1 to: 5) collect: [ :ea | ea * 2 ] --> #(2 4 6 8 10)
\end{code}

%---------------------------------------------------------
\subsection{Selecci\'on y rechazo de elementos}
% (\ct{select:}, \ct{reject:}, \ct{detect:})}

\mthind{Collection}{select:} retorna los elementos del receptos que satisfacen una condici\'on particular:

\begin{code}{@TEST}
(2 to: 20) select: [:each | each isPrime] --> #(2 3 5 7 11 13 17 19)
\end{code}

\mthind{Collection}{reject:} hace lo contrario:
\begin{code}{@TEST}
(2 to: 20) reject: [:each | each isPrime] --> #(4 6 8 9 10 12 14 15 16 18 20)
\end{code}

%---------------------------------------------------------
\subsection{Identificaci\'on de un elemento con \lct{detect:}}
El m\'etodo \mthind{OrderedCollection}{detect:} retorna el primer elemento del receptor que satisface el bloque argumento (el bloque retorna true al evaluarse). 

\begin{code}{@TEST}
'through' detect: [:each | each isVowel] --> $o
\end{code}

El m\'etodo \mthind{Collection}{detect:ifNone:} es una variante del m\'etodo \ct{detect:}. El segundo bloque es evaluado cuando no hay elementos que satisfacen el bloque.

\begin{code}{@TEST}
Smalltalk allClasses detect: [:each | '*cobol*' match: each asString] ifNone: [ nil ] --> nil
\end{code}

%---------------------------------------------------------
\subsection{Acumulaci\'on de resultados con \lct{inject:into:}}
Los lenguajes de programaci\'on funcionales ofrecen frecuentemente una funci\'on de alto orden llamada \emph{fold} \'o \emph{reduce} para acumular el resultado de aplicar alg\'un operador binario iterativamente sobre todos los elementos de una colecci\'on.
En \pharo \'esto se hace con \cmind{Collection}{inject:into:}.

El primer argumento es el valor inicial, y el segundo argumento es un bloque de dos argumentos que es aplicado al resultado parcial acumulado, y cada elemento de la colecci\'on a su vez.

Una aplicaci\'on trivial de \ct{inject:into:} es producir la suma de una colecci\'on de n\'umeros.
Siguiendo a Gauss, en \pharo podemos escribir esta expresi\'on para sumar los primeros 100 enteros:
\begin{code}{@TEST}
(1 to: 100) inject: 0 into: [:sum :each | sum + each ] --> 5050
\end{code}

Otro ejemplo es el siguiente bloque de un argumento que computa factoriales:
\begin{code}{@TEST |factorial|}
factorial := [:n | (1 to: n) inject: 1 into: [:product :each | product * each ] ].
factorial value: 10 --> 3628800
\end{code}

%---------------------------------------------------------
\subsection{Otros mensajes}

\paragraph{\mthind{Collection}{count:}} El mensaje \ct{count:} retorna el n\'umero de elementos que satisfacen una condici\'on. La condici\'on est\'a representada como un bloque booleano.

\begin{code}{@TEST}
Smalltalk allClasses count: [:each | 'Collection*' match: each asString ] --> 3
\end{code}

\paragraph{\mthind{Collection}{includes:}} El mensaje \ct{includes:} verifica si el argumento dado est\'a en la colecci\'on. 

\begin{code}{@TEST | colors |}
colors := {Color white . Color yellow. Color red . Color blue . Color orange}.
colors includes: Color blue. --> true
\end{code}

\paragraph{\mthind{OrderedCollection}{anySatisfy:}} El mensaje \ct{anySatisfy:} responde true si al menos un elemento de la colecci\'on satisface la condici\'on representada por el argumento (un bloque).

\begin{code}{@TEST | colors | colors := {Color white . Color yellow. Color red . Color blue . Color orange}.}
colors anySatisfy: [:c | c red > 0.5] --> true
\end{code}
%=========================================================
\section{Algunas sugerencias para usar colecciones}

\paragraph{Un error com\'un con \mthind{OrderedCollection}{add:}}. El siguiente error es uno de los m\'as frecuentes en \st.
\index{Collection!common errors}

\begin{code}{@TEST | collection | }
collection := OrderedCollection new add: 1; add: 2.
collection --> 2
\end{code}
\noindent
Aqu\'i la variable \ct{collection} no contiene la colecci\'on recientemente creada sino el \'ultimo n\'umero agregado. 
Esto se debe a que el m\'etodo \ct{add:} retorna el elemento agregado y no el receptor.

El siguiente c\'odigo produce el resultado esperado:
\begin{code}{@TEST | collection |}
collection := OrderedCollection new.
collection add: 1; add: 2.
collection --> an OrderedCollection(1 2)
\end{code}

Puede tambi\'en usar el mensaje \mthind{Object}{yourself} para retornar el receptor de una \ind{cascada} de mensajes:

\begin{code}{@TEST | collection |}
collection := OrderedCollection new add: 1; add: 2; yourself --> an OrderedCollection(1 2)
\end{code}

\paragraph{Remoci\'on de un elemento de la colecci\'on que se est\'a recorriendo.} Otro error que puede hacer es remover un elemento de una colecci\'on la cual usted est\'a recorriendo.
\mthind{Collection}{remove:}
\begin{code}{@TEST |range|}
range := (2 to: 20) asOrderedCollection.
range do: [:aNumber | aNumber isPrime ifFalse: [ range remove: aNumber ] ].
range --> an OrderedCollection(2 3 5 7 9 11 13 15 17 19)
\end{code}
\noindent
Este resultado es claramente incorrecto dado que 9 y 15 deber\'ian haber sido filtrados!

La soluci\'on es copiar la colecci\'on antes de recorrerla.
\begin{code}{@TEST |range|}
range := (2 to: 20) asOrderedCollection.
range copy do: [:aNumber | aNumber isPrime ifFalse: [ range remove: aNumber ] ].
range --> an OrderedCollection(2 3 5 7 11 13 17 19)
\end{code}

\paragraph{Redefinici\'on de \ct{=} y \ct{hash}.}
Un error dif\'icil de detectar es cuando redefine \ct{=} pero no \ct{hash}. Los s\'intomas son que perder\'a los elementos cuando los agrega a conjuntos u otros comportamientos extra\~{n}os. Una soluci\'on propuesa por Kent Beck es usar \ct{xor:} para redefinir \ct{hash}.
Suponga que queremos que dos libros sean considerados iguales si sus t\'itulos y autores son los mismos.
Entonces redefinir\'iamos no s\'olo \ct{=} sino tambi\'en \ct{hash} de la siguiente manera:
\index{Dictionary!overriding \ct{=} and \ct{hash}}

\begin{method}{Redefining \lct{=} and \lct{hash}.}
Book>>>= aBook
   self class = aBook class ifFalse: [^ false].
   ^ title = aBook title and: [ authors = aBook authors]

Book>>>hash 
   ^ title hash xor: authors hash
\end{method}

Otro problema grave surge si usa objetos mutables, \ie un objeto que puede cambiar su valor de hash a trav\'es del tiempo, como un elemento de un \ct{Set} o como clave de un \ct{Dictionary}.
No haga esto a no ser que le guste mucho la depuraci\'on de c\'odigo!

%=========================================================
\section{Resumen del cap\'itulo}

La jerarqu\'ia de colecciones de \st provee un vocabulario com\'un para manipular uniformemente una variedad de diferentes tipos de colecciones.

\begin{itemize}
  \item Una distinci\'on clave es entre colecciones secuenciables (subclases de \ct{SequenceableCollection}), que mantienen sus elementos en un orden dado, diccionarios (\ct{Dictionary}) y sus subclases, que mantienen asociaciones clave-valor, y conjuntos (\ct{Set}) y \ct{Bag}s, que no tienen orden.
  \item Puede convertir la mayor\'ia de las colecciones en otro tipo de colecci\'on envi\'andoles los mensajes \ct{asArray}, \ct{asOrderedCollection} \etc.
  \item Para ordenar una colecci\'on, enviar el mensaje \ct{asSortedCollection}.
  \item Los \ct{Array}s literales son creados con una sintaxis especial \ct{#( ... )}.  Los \ct{Array}s din\'amicos son creador con la sintaxis \ct|{ ... }|.
  \item Un \ct{Dictionary} compara las claves por igualdad. Es m{as {util cuando las claves sin instancias de \ct{String}. Un \ct{IdentityDictionary} sin embargo usa la identidad de los objetos para comparar las claves. Es m\'as adecuado cuando los s\'imbolos (\ct{Symbol}s) son usados como claves, o cuando mapping object references to values.
  \item Las cadenas de caracteres (\ct{String}s) tambi\'en entienden los mensajes usuales de colecciones.  Adem\'as, una cadena de caracteres soporta una forma simple de \textit{pattern-matching}. Para una aplicaci\'on m\'as avanzada, buscar en el paquete RegEx.
  \item El mensaje b\'asico de iteraci\'on es \ct{do:}. Es \'util para c\'odigo imperativo, tal como la modificaci\'on de cada elemento de una colecci\'on, o el env\'io de un mensaje a cada elemento.
  \item En vez de usar \ct{do:}, es m\'as usual usar \ct{collect:}, \ct{select:}, \ct{reject:}, \ct{includes:}, \ct{inject:into:} y otros mensajes de alto nivel para procesar colecciones de manera uniforme.
  \item Nunca remover un elemento de una colecci\'on que se est\'a recorriendo. Si se debe modificar, oterar sobre una copia de ella.
  \item Si redefine el m\'etodo \ct{=}, recuerde redefinir tambi\'en el m\'etodo \ct{hash}!
\end{itemize}

%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=========================================================

