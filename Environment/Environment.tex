% $Author: oscar $
% $Date: 2009-10-26 05:25:10 -0300 (lun 26 de oct de 2009) $
% $Revision: 29516 $

% HISTORY:
% 2006-10-24 - Pollet started
% 2006-12-09 - Andrew adds material
% 2007-08-30 - Andrew completes first draft
% 2007-08-31 - Oscar edits
% 2007-09-07 - Stef corrections
% 2007-10-08 - Cassou corrections

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
\chapter{El entorno de progamaci\'on Pharo}
\chalabel{env}

% Email 2009-10-21
El objetivo de este capitulo es mostrar la forma de desarrollar programas en el entorno de programaci\'on \pharo.
Ya se ha visto como definir m\'etodos y clases usando el buscador; este capitulo mostrar\'a m\'as caracteristicas del buscador, e introducir\'a algunos de los dem\'as buscadores.

Por supuesto, ocasionalmente puede suceder que el programa no realice la funci\'on que de \'el se espera. Por ello, \pharo tiene un excelente depurador, pero al igual que otras herramientas poderosas, puede resultar confuso cuando se lo usa por primera vez. En este capitulo se dar\'a un ejemplo de depuraci\'on y se demostrar\'an algunas de las caracter\'isticas de esta herramienta. 

Una de las caracter\'isticas \'unicas de Smalltalk es que mientras se est\'a programando, uno pertenece a un mundo de objetos vivos, muy distinto al de los programas est\'aticos. Esto hace posible obtener feedback de forma instantanea mientras se programa, lo cual permite al programador ser m\'as productivo. Hay dos herramientas que permiten analizar, e incluso cambiar, los objetos vivos: el \emph{inspector} y el \emph{explorer}.

La consecuencia de programar en un mundo de objetos vivos, en vez de hacerlo con archivos y un editor de texto, es que se debe realizar una acci\'on explicita para exportar el programa desde la imagen de Smalltalk.  
La forma antigua de hacerlo, posible en todos los dialectos Smalltalk, es mediante crear un \emph{fileout} o un \emph{change set}, los cuales son en esencia archivos de texto encriptados que pueden ser importados desde otro sistema.  
En cambio, la nueva forma de hacer esto en \pharo is subir el c\'odigo a un repositorio de versiones en un servidor.  Esto se logra usando una herramienta llamada \ind{Monticello}, y es una manera m\'as poderosa y eficiente de trabajar, especialmente en grupo.
\seeindex{change set}{file, filing out}
\index{file!filing out}

%Finally, you may find a bug in \pharo as you work; we explain how to report bugs, and how to submit bug fixes.
%\ab{Or I would, if I knew how.   We should do this, or remove the paragraph.}

%=========================================================
\section{Resumen}
\seclabel{overview}

Smalltalk y las interfaces gr\'aficas modernas fueron desarrolladas juntas.
Aun antes del primer lanzamiento p\'ublico de Smalltalk en 1983, este ten\'ia un entorno gr\'afico de desarrollo auto-alojado, y todo el desarrollo en Smalltalk tomaba lugar en \'el.
Para empezar, se ver\'an las herramientas principales de \pharo.

\begin{itemize}
	\item {El \menu{Browser}} es la principal herramienta de desarrollo. Se usa para crear, definir y organizar las clases y m\'etodos. Usandolo tambien se puede navegar por todas las librer\'ias de clase: a diferencia de otros entornos donde el c\'odigo fuente es almacenado en archivos diferentes, en Smalltalk todas las clases y m\'etodos est\'an contenidos en la imagen.
	\index{browser}

	\item{\menu{Message Names}} se usa para ver todos los m\'etodos con un selector particular, o con uno que contenga una subcadena de caracteres.
	\index{message name finder}
	
	\item{El \menu{Method Finder}} tambi\'en le ayudará a encontr\'ar m\'etodos, pero de acuerdo a lo que \emph{hacen} adem\'as de por su nombre.
	\index{method finder}
	
	\item{El \menu{Monticello Browser}} es el punto de partida para cargar c\'odigo desde, o guardar c\'odigo en, los paquetes \ind{Monticello}.

	\item{El \menu{Process Browser} permite ver todos los procesos (\emph{threads}) que se est\'an ejecutando en Smalltalk.}
	\index{process browser}
	
	\item{El \menu{Test Runner}} le permite correr y debbugear las pruebas \SUnit, y se describe en \charef{SUnit}.
	\index{Test Runner}
	\index{SUnit}
	
	\item{El \menu{Transcript}} es una ventana en el canal de salida del \glbind{Transcript}, el cual es \'util para escribir mensajes de registro y que ya se ha descripto en \secref{transcript}.
	
	\item{El \menu{Workspace}} es una ventana donde se pueden tipear entradas.  
	Puede ser usado con cualquier propósito, pero es m\'as usado para tipear expresiones de Smalltalk y 
	ejecutarlas con \menu{do it}. El uso del \ind{workspace} tambi\'en fue ilustrado en \secref{transcript}.

\end{itemize}

El \menu{Debugger} tiene una tarea obvia, pero descubrir\'a que tiene un rol más importante comparado con los debuggers de otros lenguajes de programaci\'on , porque en Smalltalk se puede \emph{programar} en el \ind{debugger}. El debugger no se lanza desde un men\'u; normalmente aparece al correr una prueba que falla, al tipear \short{\textbf{.}} para interrumpir un proceso en curso, o insertando una expreci\'on \ct{self halt} en el c\'odigo.
\index{process!interrupting}

%=========================================================
\section{El Navegador}
\seclabel{browser}

Muchos navegadores de clases diferentes se han desarrollado a trevez de los años para \st.
\pharo simplifica esta historia por medio de ofrecer un navegados que integra diversas vistas.
\figref{SystemBrowser0} muestra el navegador como aparece la primera vez que es abierto.\footnote{Recuerde que si el navegador que usted tenga no se ve como el mostrado en \figref{classBrowser}, quiz\'as necesite cambiar el navegador por defecto.  V\'ease \faqref{packagebrowser}.}

\begin{figure}[htbp]
   \centering
   \ifluluelse
	 {\includegraphics[width=\textwidth]{SystemBrowser0} }
	 {\includegraphics[width=0.7\textwidth]{SystemBrowser0} }
   \caption{El Navegador}
   \figlabel{SystemBrowser0}
\end{figure}

Los cuatro paneles pequeños en la parte superior del navegador representan una visi\'on jer\'arquica de los m\'etodos que se hallan en el sistema, de una manera muy similar a como el \textit{File Viewer} de \ind{NeXTstep} y el \textit{Finder} de Mac OS X en modo de columna, dan una vista de los archivos en el disco.
En el panel que se halla en el extremo ixquierdo se encuentran las listas de los \emph{paquetes} de clases; seleccione uno (por ejemplo \scat{Kernel}) y el panel a la derecha mostrar\'a entonces todas las clases en ese paquete.
% \on{I adopted the spelling of NeXTstep recommended by wikipedia}

\begin{figure}[htbp]
   \centering
   \ifluluelse
	   {\includegraphics[width=\textwidth]{SystemBrowser1} }
	   {\includegraphics[width=.7\textwidth]{SystemBrowser1} }
   \caption{El Navegador con la clase \ct{Model} seleccionada
   \figlabel{SystemBrowserModel}}
\end{figure}

De forma similar, si selecciona una de las clases en el segundo panel, por ejemplo, \menu{Model} (v\'ease \figref{SystemBrowserModel}), el tercer panel mostrar\'a todos los \emph{protocolos} definidos para esa clase, asi como un protocolo virtual \prot{-{}-all-{}-}, que est\'a seleccionado por defecto. 
Los protocolos son una forma de categorizar los m\'etodos; hacen m\'as facil hallar y pensar en en el comportamiento de una clase al separarla en piezas m\'as pequeñas y conceptualmente coherentes.
El cuarto panel muestra los nombres de todos los m\'etodos definidos en el protocolo seleccionado.
Si selecciona el nombre de un m\'etodo, el c\'odigo fuente del m\'etodo correspondiente aparece en el panel alergado en la parte inferior del navegador, donde puede verlo, editarlo, y guardar la versi\'on editada.
Si selecciona la clase \menu{Model}, el protocolo \protind{dependents} y el m\'etodo \menu{myDependents}, el navegador deber\'ia verse como en \figref{SystemBrowserMyDependents}.
\protindex{all}
\cmindex{Model}{myDependents}

\begin{figure}[htbp]
   \centering
   \ifluluelse
	   {\includegraphics[width=\textwidth]{SystemBrowserMyDependents}}
	   {\includegraphics[width=0.7\textwidth]{SystemBrowserMyDependents}}
   \caption{El Navegador mostrando el m\'etodo \ct{myDependents} en la clase \ct{Model}
   \figlabel{SystemBrowserMyDependents}}
\end{figure}

A diferencia de los directorios en el \emph{Finder} de Mac OS X, los cuatro paneles superiores no son exactamente iguales.  
Mientras que las clases y los m\'etodos son parte del lenguaje Smalltalk, los paquetes y protocolos no lo son: son una comodidad agregada por el navegador para limitar la cantidad de informaci\'on que debe ser mostrada en cada panel. Por ejemplo, si no hubiera protocolos, el navegador tendr\'ia que mostrar una lista de todos los m\'etodos en la clase seleccionada; para muchas clases esta lista ser\'ia muy extensa para ser recorrida convenientemente.
\index{Mac OS X Finder}

Por esta raz\'on, la manera de crear un nuevo paquete o protocolo es diferente de la forma en que se crea una nueva clase o m\'etodo. Para crear un nuevo paquete, haga click en el panel de paquetes y seleccione \menu{new package}; para crear un nuevo protocolo, haga click en el panel de protocolos y seleccione \menu{new protocol}.
Ingrese el nombre de este en el cuadro de dialogo, y est\'a listo: no hay nada m\'as en un paquete o protocolo que su nombre y su contenido.
\index{package!creating}

\begin{figure}[htbp]
   \centering
   \ifluluelse
	   {\includegraphics[width=\textwidth]{SystemBrowserClassCreation}}
	   {\includegraphics[width=0.7\textwidth]{SystemBrowserClassCreation}}
   \caption{El Navegador mostrando la plantilla(template??) de creaci\'on de clases
   \figlabel{SystemBrowserClassCreation}}
\end{figure}

In contrast, to create a new class or a new method, you will actually
have to write some Smalltalk code.  If you \click the currently
selected package (in the left-most pane), the bottom
browser pane will display a class creation template
(\figref{SystemBrowserClassCreation}).  You create a new class by
editing this template: replace \ct{Object} by the name of the existing
class of which you wish to create a subclass, replace
\ct{NameOfSubclass} by the name that you would like to give to your
new subclass, and fill in the instance variable names if you know
them.  The category for the new class is by default the category of the currently
selected package\footnote{Recall that packages and categories are not exactly the same thing. We will look at the precise relationship in \secref{packages}}, but you can change this too if you like.  If you
already have the browser focussed on the class that you wish to
subclass, you can get the same template with slightly different
initialization by \actclick{ing} in the class pane, and
selecting \menu{class templates \ldots \go subclass template}.  You can also just
edit the definition of an existing class, changing the class name to
something new.  In all cases, when you accept the new definition, the
new class (the one whose name follows the \ct{#}) is created (as is
the corresponding metaclass).  Creating a class also creates a global
variable that references the class, which is why you can refer to all
of the existing classes by using their names.  \index{class!creation}
\index{browser!defining a class}
Por otro lado, para crear una nueva clase o un nuevo m\'etodo, se deber\'a escribir
cierto c\'odigo Smalltalk. Si hace \click en el paquete
seleccionado(en el panel extremo izquierdo), el panel
inferior del navegador mostrar\'a la plantilla para la creaci\'on de la clase.
(\figref{SystemBrowserClassCreation}).  Se crea una nueva clase al
editar esta plantilla: reemplace \ct{Object} por el nombre de la clase existente
de la cual quiere crear una nueva subclase, reemplace
\ct{NameOfSubclass} por el nombre que desea darle a la nueva
subclase, y complete los nombres de las variables de instancia si los
conoce.  La categor\'ia de la nueva clase es por defecto la del paquete
que est\'e seleccionado\footnote{Recuerde que los paquetes y categor\'ias no son exactamente lo mismo. Se ver\'a la relaci\'on precisa en \secref{packages}}, pero puede cambiar esto tambi\'n si as\'i lo desea.  Si
ya tiene el navegador already have the browser focussed on the class that you wish to
subclass, you can get the same template with slightly different
initialization by \actclick{ing} in the class pane, and
selecting \menu{class templates \ldots \go subclass template}.  You can also just
edit the definition of an existing class, changing the class name to
something new.  In all cases, when you accept the new definition, the
new class (the one whose name follows the \ct{#}) is created (as is
the corresponding metaclass).  Creating a class also creates a global
variable that references the class, which is why you can refer to all
of the existing classes by using their names.  \index{class!creation}
\index{browser!defining a class}

Can you see why the name of the new class has to appear as a \clsind{Symbol} (\ie prefixed with \ct{#}) in the class creation template, but after the class is created, code can refer to the class by using the name as an identifier (\ie without the \ct{#})?

The process of creating a new method is similar.  First select the class in which you want the method to live, and then select a protocol.  The browser will display a method-creation template, as shown in \figref{SystemBrowserMethodTemplate}, which you can fill-in or edit.
\index{method!creation}
\index{browser!defining a method}

\begin{figure}[htbp]
   \centering
   \ifluluelse
	   {\includegraphics [width=\textwidth]{SystemBrowserMethodTemplate}}
	   {\includegraphics[width=0.7\textwidth]{SystemBrowserMethodTemplate}}
   \caption{Browser showing the method-creation template
   \figlabel{SystemBrowserMethodTemplate}}
\end{figure}

%---------------------------------------------------------
\subsection{Navigating the code space}

The browser provides several tools for exploring and analysing code.
These tools can be accessed by \actclick{ing} in the various contextual menus, or, in the case of the most frequently used tools, by means of keyboard shortcuts.

\subsubsection{Opening a new browser window}
\seclabel{browsing}

Sometimes you want to open multiple browser windows.
When you are writing code you will almost certainly need at least two: one for the method that you are typing, and another to browse around the system to see how things work.
You can open a browser on a class named by any selected text using the \short{b} \ind{keyboard shortcut}. 
\index{browser!browse button}
\index{keyboard shortcut!browse it}

\dothis{Try this: in a workspace window, type the name of a class (for instance \ct{Morph}), select it, and then press \short{b}. This trick is often useful; it works in any text window.}

\subsubsection{Senders and implementors of a message}
\seclabel{sendersImplementors}

\index{browser!senders}
\Actclick{ing} \menu{browse \ldots \go senders (n)} in the method pane will bring up a list of all methods that may use the selected method. With the browser open on \ct{Morph}, click on the \mthind{Morph}{drawOn:} method in the method pane; the body of \ct{drawOn:} displays in the bottom part of the browser. If you now select \menu{senders (n)} (\figref{SendersOfDrawOn}), a menu will appear with \ct{drawOn:} as the topmost item, and below it, all the messages that \ct{drawOn:} sends (\figref{SendersOfDrawOn2}).  Selecting an item in this menu will open a browser with the list of all methods in the image that send the selected message (\figref{CanvasDraw}).

%\begin{figure}[htb]
%\begin{minipage}[b]{0.74\textwidth}
%\centerline {\includegraphics[width=\textwidth]{SendersOfDrawOn}}
%\caption{The \menu{senders (n)} menu item.\figlabel{SendersOfDrawOn}}
%\end{minipage}
%\hfill
%\begin{minipage}[b]{0.24\textwidth}
%\centerline {\includegraphics[width=\textwidth]{SendersOfDrawOn2}}
%\caption{Choose senders of which message.\figlabel{SendersOfDrawOn2}}
%\end{minipage}
%\end{figure}

\begin{figure}[htb]
\centerline {\includegraphics[width=\textwidth]{SendersOfDrawOn}}
\caption{The \menu{senders (n)} menu item.\figlabel{SendersOfDrawOn}}
\end{figure}

\begin{figure}[htb]
\centerline {\includegraphics[width=0.4\textwidth]{SendersOfDrawOn2}}
\caption{Choose senders of which message.\figlabel{SendersOfDrawOn2}}
\end{figure}

The ``n'' in \menu{senders (n)} tells you that the keyboard shortcut for finding the senders of a message is \short{n}. This will work in \emph{any} text window.

\dothis{Select the text ``drawOn:'' in the code pane and press \short{n} to immediately bring up the senders of \ct{drawOn:}.}

\begin{figure}[htbp]
	\begin{center}
   \ifluluelse
		{\includegraphics[width=\textwidth]{CanvasDraw}}
		{\includegraphics[width=0.7\textwidth]{CanvasDraw}}
	\end{center}
	\caption{The Senders Browser showing that the \ct{Canvas>>>draw} method sends the \ct{drawOn:} message to its argument.	\figlabel{CanvasDraw}}
\end{figure}

If you look at the senders of \ct{drawOn:} in \ct{AtomMorph>>>drawOn:}, you will see that it is a super \subind{super}{send}.  So we know that the method that will be executed will be in \ct{AtomMorph}'s superclass.  What class is that?  \Actclick ~ \menu{browse \go hierarchy implementors} and you will see that it is \ct{EllipseMorph}. 
\index{browser!hierarchy button}

Now look at the sixth sender in the list, \ct{Canvas>>>draw}, shown in \figref{CanvasDraw}.
You can see that this method sends \ct{drawOn:} to whatever object is passed to it as an argument, which could potentially be an instance of any class at all.  
Dataflow analysis can help figure out the class of the receiver of some messages, but in general, there is no simple way for the browser to know which message-sends might cause which methods to be executed.
For this reason,  the ``senders'' browser shows exactly what its name suggests: all of the senders of the message with the chosen selector.  
The senders browser is nevertheless extremely useful when you need to understand how you can \emph{use} a method: it lets you navigate quickly through example uses.  
Since all of the methods with the same selector ought to be used in the same way, all of the uses of a given message ought to be similar.
\index{browser!senders}

\index{browser!implementors}
The implementors browser works in a similar way, but instead of listing the senders of a message, it lists all of the classes that implement a method with the same selector. To see this, select \lct{drawOn:} in the method pane and select \menu{browse \go implementors (m)} (or select the ``drawOn:'' text in the code pane and press \short{m}).
You should get a method list window showing a scrolling list of the 90-odd classes that implement a \ct{drawOn:} method.
It shouldn't be all that surprising that so many classes implement this method: \ct{drawOn:} is the message that is understood by every object that is capable of drawing itself on the screen.

\subsubsection{Versions of a method}
\seclabel{versions}

When you save a new \subind{method}{version} of a method, the old one is not lost.  \pharo keeps all of the old versions, and allows you to compare different versions and to go back (``revert'') to an old version.
\begin{figure}[btp]
   \centering
   \includegraphics[width=\textwidth]{Versions}
   \caption{The \ind{versions browser} showing two versions of the \ct{TheWorldMenu>>>buildWorldMenu:} method}
   \figlabel{buildWorldMenuVersions}
\end{figure}
The \menu{browse \go versions (v)} menu item gives access to the successive modifications made to the selected method.
In \figref{buildWorldMenuVersions} we can see two versions of the \ct{buildWorldMenu:} method.

\index{browser!versions button}
The top pane displays one line for each version of the method, listing the initials of the programmer who wrote it, the date and time at which it was saved, the names of the class and the method, and the protocol in which it was defined.  The current (active) version is at the top of the list;  whichever version is selected is displayed in the bottom pane.
% If the \menu{diffs} checkbox is selected, as it is in \figref{mouseUpVersions}, the display also shows the differences between the selected version and the one immediately older.  
Buttons are also provided for displaying the differences between the selected method and the current version, and for reverting to the selected version.
% The \menu{prettyDiffs} checkbox is useful if there have been changes to layout: it pretty-prints both versions before differencing, so that the differences that are displayed exclude formatting changes. 

The existence of the \ind{versions browser} means that you never have to worry about preserving code that you think might no longer be needed: just delete it.  If you find that you \emph{do} need it, you can always revert to the old version, or copy the needed code fragment out of the old version and paste it into a another method.
Get into the habit of using versions;  ``commenting out'' code that is no longer needed is a bad practice because it makes the current code harder to read.
Smalltalkers rate code readability extremely highly.

\hint{What if you delete a method entirely, and then decide that you want it back?  You can find the deletion in a change set, where you can ask to see versions by \actclick{ing}.
The change set browser is described in \secref{env:changeSet}}

\subsubsection{Method overridings}
\seclabel{overriding}

The inheritance browser displays all the methods overridden by the displayed method. 
To see how it works, select the \cmind{ImageMorph}{drawOn:} method in the browser.
Note the triangular icons next to the method name (\figref{OBinheritanceBrowser}).
The upward-pointing triangle tells you that \ct{ImageMorph>>>drawOn:} overrides an inherited method (\ie \ct{Morph>>>drawOn:}), and the downward-pointing triangle tells you that it is overridden by subclasses. (You can also click on the icons to navigate to these methods.)
Now select \menu{browse \go inheritance}.
The inheritance browser shows you the hierarchy of overridden methods (see \figref{OBinheritanceBrowser}).

\begin{figure}[btp]
	\begin{center}
   \ifluluelse
		{\includegraphics[width=\textwidth]{OBInheritanceOverriding}}
		{\includegraphics[width=0.7\textwidth]{OBInheritanceOverriding}}
	\end{center}
	\caption{\ct{ImageMorph>>>drawOn:} and the methods that it overrides. The siblings of the selected methods are shown in the scrolling lists.}
	\figlabel{OBinheritanceBrowser}
\end{figure}

\subsubsection{The Hierarchy view}
\seclabel{hierarchy}

By default, the browser presents a list of packages in the leftmost pane.
However it is possible to switch to a class hierarchy view.
Simply select a particular class of interest, such as \ct{ImageMorph} and then click on the \button{hier.} button.
You will then see in the left-most pane a class hierarchy displaying all superclasses and subclasses of the selected class.
The second pane lists the packages implementing methods of the selected class.
%The \button{hierarchy} button opens a \ind{hierarchy browser} on the current class; this
%browser can also be opened by using the \menu{browse hierarchy} menu item in the class pane.
%The hierarchy browser is similar to the browser, but instead of displaying the categories and the classes in each category, it shows a single list of classes, indented to represent inheritance.
%The category of the selected class is displayed in the small annotation pane at the top of the browser.
In \figref{hierarchyBrowser}, the hierarchy browser reveals that the direct superclass of \clsind{ImageMorph} is \clsind{Morph}.
\index{browser!hierarchy button}

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{hierarchyBrowser}}
		{\includegraphics[width=0.7\textwidth]{hierarchyBrowser}}
	\end{center}
	\caption{A hierarchy view of \ct{ImageMorph}.}
	\figlabel{hierarchyBrowser}
\end{figure}

\subsubsection{Finding variable references}
\seclabel{variables}

\index{browser!variables}
By \actclick{ing} on a class in the class pane, and selecting \menu{browse \go chase variables}, you can find out where an instance variable or a class variable is used.
You will be presented with a \emph{chasing browser} that will allow you to walk through the accessors of all instance variables and class variables, and, in turn, methods that send these accessors, and so on (\figref{chasingBrowser}).

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{chasingBrowser}}
		{\includegraphics[width=0.7\textwidth]{chasingBrowser}}
	\end{center}
	\caption{A chasing browser for \ct{Morph}.}
	\figlabel{chasingBrowser}
\end{figure}

% The menu also includes \menu{inst var defs}, which shows the subset of the instance variable references that assign to the variable. 
%Once you click on the button or select the menu item, you will be presented with a dialog that invites you to choose a variable from all of the variables defined in the current class, and all of the variables that it inherits.  The list is in inheritance order; it can often be useful to bring up this list just to remind yourself of the name of an instance variable.  If you click outside the list, it will go away and no variable browser will be created.

%Also available by \actclick{ing} the class pane is \menu{class vars}, which opens an inspector showing the class variables of the current class \emph{and their values}, and \menu{class refs (N)} which displays a list of all of the methods that directly reference the current class.

\subsubsection{Source}
\seclabel{sources}

\index{browser!view}
The \menu{various \go view \ldots} menu item available by \actclick{ing} in the method pane brings up the ``how to show'' menu, which allows you to choose how the browser shows the selected method in the source pane.  Options include the \menu{source} code, \menu{prettyPrint}ed source code, \menu{byteCode} and source code \menu{decompile}d from the byte codes.
% The label on the button changes if you select one of the other modes.  There are other options too; if you let the mouse linger over the names, a help balloon will appear.  Try some of them.
\index{method!pretty-print}
\index{method!decompile}
\index{method!byte code}

Note that selecting \menu{prettyPrint} in the ``how to show'' menu is \emph{not} the same as pretty printing a method before you save it\footnote{\menu{pretty print (r)} is the first menu item in the method pane, or half-way down in the code pane.}.  
The menu controls only how the browser displays, and has no effect on the code stored in the system.  
You can verify this  by opening two browsers, and selecting \menu{prettyPrint} in one and \menu{source} in the other.   
In fact, focussing two browsers on the same method and selecting \menu{byteCode} in one and \menu{decompile} in another is a good way to learn about the \pharo virtual machine's byte-coded instruction set.

\subsubsection{Refactoring}

The contextual menus offer a large number of standard refactorings.
Simply \actclick in any of the four panes to see the currently available refactoring operations.
See \figref{refactoring}.

Refactoring was formerly available only in a special browser called the refactoring browser, but it can now be accessed from any browser.

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{refactoring}}
		{\includegraphics[width=0.7\textwidth]{refactoring}}
	\end{center}
	\caption{Refactoring operations.}
	\figlabel{refactoring}
\end{figure}

%---------------------------------------------------------
\subsection{The browser menus}

Many additional functions are available by \actclick{ing} in the browser panes.  
Even if the labels on the menu items are the same, their \emph{meaning} may be context dependent.  
For example, the package pane, the class pane, the protocol pane and the method pane all have a \menu{file out} menu item.  However, they do different things: the package pane's \menu{file out} menu files out the whole package, the class pane's \menu{file out} menu files-out the whole class, the protocol pane's \menu{file out} menu files out the whole protocol, and the method pane's \menu{file out} menu files-out just the displayed method.
Although this may seem obvious, it can be a source of confusion for beginners. 
\index{file!filing in}
\index{file!filing out}

Possibly the most useful menu item is \menu{find class\ldots (f)} in the package pane.  Although the categories are useful for the code that we are actively developing, most of us do not know the categorization of the whole system, and it is much faster to type \short{f} followed by the first few characters of the name of a class than to guess which package it might be in.  \menu{recent classes\ldots} can also help you quickly go back to a class that you have browsed recently, even if you have forgotten its name.
\index{class!finding}
\index{class!recent}

You can also search for a specific class or method by typing the name into the query box at the top left of the browse.  When you enter return, a query will be posed on the system, and the query results will be displayed.  Note that by prefixing your query with \ct{#}, you can search for references to a class or senders of a message.
%To browse to a particular method, you can 
%In the class pane, there are two menu items \menu{find method} and \menu{find method wildcard\ldots} that can be useful if you want to browse a particular method.  
If you are searching for a particular method of the selected class, it is often quicker to browse the \prot{-{}-all-{}-} protocol (which is the default), place the mouse in the method pane, and type the first letter of the name of the method that you are looking for.
This will usually scroll the pane so that the sought-for method name is visible.
\index{method!finding}
\protindex{all}

\dothis{Try both ways of navigating to \cmind{OrderedCollection}{removeAt:}}

There are many other options available in the menus.  It pays to spend a few minutes working with the browser and seeing what is there.   

\dothis{Compare the result of \menu{Browse Protocol}, \menu{Browse Hierarchy},  and \menu{Show Hierarchy} in the class pane menu.}

%---------------------------------------------------------
\subsection{Browsing programmatically}

The class \glbind{SystemNavigation} provides a number of utility methods that are useful for navigating around the system.
Many of the functions offered by the classic browser are implemented by \ct{SystemNavigation}.
\index{browsing programmatically}

\dothis{
Open a workspace and evaluate the following code to browse the senders of \ct{drawOn:}:}
\begin{code}{}
SystemNavigation default browseAllCallsOn: #drawOn:
\end{code}
To restrict the search for senders to the methods of a specific class:
\begin{code}{}
SystemNavigation default browseAllCallsOn: #drawOn: from: ImageMorph
\end{code}
Because the development tools are objects, they are completely accessible from programs and you can develop your own tools or adapt the existing tools to your needs.

The programmatic equivalent to the \menu{implementors} menu item is:
\begin{code}{}
SystemNavigation default browseAllImplementorsOf: #drawOn:
\end{code}

To learn more about what is available, explore the class \ct{SystemNavigation} with the browser.
Further navigation examples can be found in the FAQ (\appref{faq}).

%=========================================================
\section{Monticello}

We gave you a quick overview of \ind{Monticello}, \pharo's packaging tool, in \secref{Monticello}.  
However, Monticello has many more features than were discussed there.  
Because Monticello manages \emph{packages}, before telling you more about Monticello, it's important that we first explain exactly what a \ind{package} is.

%---------------------------------------------------------
\subsection{Packages: declarative categorization of \pharo code}\seclabel{packages}

We have pointed out earlier, in \secref{categoriesPackages} that packages are more or less equivalent to categories. Now we will see exactly what the relationship is.
The package system is a simple, lightweight way of organizing Smalltalk source code that exploits a simple naming convention for categories and protocols.

Let's explain this using an example.
Suppose that you are developing a framework named to facilitate the use of relational databases from \pharo. You have decided to call your framework \ct{PharoLink}, and have created a series of categories to contain all of the classes that you have written, \eg
category \ct{'PharoLink-Connections'} contains \ct{OracleConnection MySQLConnection PostgresConnection} and category \ct{'PharoLink-Model'} contains \ct{DBTable DBRow DBQuery}, and so on. However, not all of your code will reside in these classes. For example, you may also have a series of methods to convert objects into an SQL-friendly format:

\begin{code}{}
Object>>>asSQL
String>>>asSQL
Date>>>asSQL
\end{code}

\noindent
These methods belong in
% \damien{don't we say 'belong to'?}
% \on{no -- belong in = they should be there; belong to = they are there}
the same package as the classes in the 
categories \ct{PharoLink-Connections} and \ct{PharoLink-Model}. 
But clearly the whole of class \ct{Object} does not belong in your package! 
So you need a way of putting certain \emph{methods} in a package, even though the rest of the class is in another package.
\index{package!extension}
\seeindex{extension package}{package, extension}

The way that you do this is by placing those methods in a protocol (of \ct{Object}, \ct{String}, \ct{Date}, and so on) named \prot{*PharoLink} (note the initial asterisk). The combination of the \scat{PharoLink-\ldots} categories and the \prot{*PharoLink} protocols form a package named \ct{PharoLink}.
To be precise, the rules for what goes in a package are as follows.

A package named \ct{Foo} contains:

\begin{enumerate}		\seclabel{packageRules}
	\item{} all \emph{class definitions} of classes in the category \scat{Foo}, or in categories with names starting with \scat{Foo-}, and
	\item{} \label{env:extensions} all \emph{methods} in \emph{any class} in protocols named \prot{*Foo} or \prot{*foo}\footnote{When performing this comparison, the case of the letters in the names is ignored.}, or whose name starts with \prot{*Foo-} or \prot{*foo-}, and
	\item{} all \emph{methods} in classes in the category \scat{Foo}, or in a category whose name starts with \scat{Foo-}, \emph{except} for those methods in protocols whose names start with \prot{*}.
	
\end{enumerate}
\noindent
A consequence of these rules is that each class definition and each method belongs to exactly one package. The \emph{except} in the last rule has to be there because those methods must belong to other packages.   The reason for ignoring case in rule \ref{env:extensions} is that, by convention, protocol names are typically (but not necessarily) lower case (and may include spaces), while category names use CamelCase (and don't include spaces).
\index{camelCase}

The class \ct{PackageInfo} implements these rules, and one way to get a feel for them is to experiment with this class.

\dothis{Evalute the following expression in a workspace:}

\begin{code}{}
mc := PackageInfo named: 'Monticello'
\end{code}

It is now possible to introspect on this package. 
For example, printing \ct{mc classes} in the workspace pane will return the long list of classes that make up the Monticello package.  
\ct{mc coreMethods}
will return a list of \ct{MethodReference}s for all of the methods in those classes. \ct{mc extensionMethods} is perhaps one of the most interesting queries: it will return a list of all methods contained in the \ct{Monticello} package but not contained within a \lct{Monticello} class.

Packages are a relatively new addition to \pharo, but since the package naming conventions were based on those already in use, it is possible to use \ct{PackageInfo} to analyze older code that has not been explicitly adapted to work with it.

\dothis{Print \ct{(PackageInfo named: 'Collections') externalSubclasses}; this expression will answer a list of all subclasses of  \ct{Collection} that are \emph{not} in the \ct{Collections} package. }

%---------------------------------------------------------
\subsection{Basic Monticello}

\ind{Monticello} is named after the mountaintop home of Thomas Jefferson, third president of the United States and author of the Statute of Virginia for Religious Freedom.  The name means ``little mountain'' in Italian, and so it is always pronounced with an Italian ``c'', which sounds like the ``ch'' in chair: Mont-y'-che-llo.


\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{freshMonticello}}
		{\includegraphics[width=0.7\textwidth]{freshMonticello}}
	\end{center}
	\caption{The Monticello browser.}
	\figlabel{freshMonticello}
\end{figure}

When you open the Monticello browser, you will see two list panes and a row of buttons, as shown in \figref{freshMonticello}.
The left-hand pane lists all of the packages that have been loaded into the image that you are running; the particular version of the package is shown in parentheses after the name.

The right-hand pane lists all of the source-code repositories that Monticello knows about, usually because it has loaded code from them.  If you select a package in the left pane, the right pane is filtered to show only those repositories that contain versions of the selected package.

One of the repositories is a directory named \emph{package-cache}, which is a sub-directory of the directory in which your image is running.  
When you load code from or write code to a remote repository, a copy is also saved in the package cache.  This can be useful if the network is not available and you need to access a package.  Also, if you are given a Monticello (.mcz) file directly, for example as an email attachment, the most convenient way to access it is to place it in the package-cache directory.
\index{package!cache}

To add a new repository to the list, click the \button{+Repository}, and choose the kind of repository from the pop-up menu.  Let's add an HTTP repository.

\dothis{Open Monticello, click on \button{+Repository}, and select \menu{HTTP}.
Edit the dialog to read:}
%\ab{How does one continue the $\backslash$dothis to include the code?}
%\on{Don't.  Just close the \dothis{} and follow with the code.}
\needlines{4}
\begin{code}{}
MCHttpRepository
	location: 'http://squeaksource.com/PharoByExample'
	user: ''
	password: ''
\end{code}

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=0.7\textwidth]{SqueakSource-PBE}}
		{\includegraphics[width=0.7\textwidth]{SqueakSource-PBE}}
	\end{center}
	\caption{A Repository browser.}
	\figlabel{SqueakSource:PBE}
\end{figure}
\noindent
Then click on \button{Open} to open a repository browser on this repository.  You should see something like \figref{SqueakSource:PBE}.  On the left is a list of all of the packages in the repository; if you select one, then the pane on the right will show all of the versions of the selected package in this repository. 

If you select one of the versions, you can \button{Browse} it (without loading it into your image), \button{Load} it, or look at the \button{Changes} that will be made to your image by loading the selected version.  You can also make a \button{Copy} of a version of a package, which you can then write to another repository.

As you can see, the names of versions contain the name of the package, the initials of the author of the version, and a version number.  The version name is also the name of the file in the repository.  Never change these names; correct operation of Monticello depends on them!   Monticello version files are just zip archives, and if you are curious you can unpack them with a zip tool, but the best way to look at their contents is using Monticello itself.  

To create a package with Monticello, you have to do two things: write some code, and tell Monticello about it.

\dothis{Create a package called \scat{PBE-Monticello}, and put a couple of classes in it, as shown in \figref{MCnewcategory}.  Also, create a method in an existing class, such as \ct{Object}, and put it in the same package as your classes, using the rules from page \pageref{sec:packageRules}\,---\,see \figref{MCnewmethod}.}

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{MCnewcategory}}
		{\includegraphics[width=0.7\textwidth]{MCnewcategory}}
	\end{center}
	\caption{Two classes in the ``PBE'' package.}
	\figlabel{MCnewcategory}
\end{figure}

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{MCnewmethod}}
		{\includegraphics[width=0.7\textwidth]{MCnewmethod}}
	\end{center}
	\caption{An extension method that will also be in the ``PBE'' package.}
	\figlabel{MCnewmethod}
\end{figure}

To tell Monticello about your package, click on \button{+Package}, and type the name of the package, in this case ``PBE''.  Monticello will add \ct{PBE} to its list of packages; the package entry will be marked with an asterisk to show that the version in the image has not yet been written to any repository. Note that you now should have two packages in Monticello, one called \ct{PBE} and another called \ct{PBE-Monticello}. That's alright because \ct{PBE} will contain \ct{PBE-Monticello}, and any other packages starting with \ct{PBE-}.

Initially, the only repository associated with this package will be your package cache, as shown in \figref{MC+PBE}.  That's OK: you can still save the code, which will cause it to be written to the package cache.  
Just click \button{Save} and you will be invited to provide a log message for the version of the package that you are about to save, as shown in \figref{PBE-on}; when you accept the message, Monticello will save your package.
To indicate this, the asterisk decorating the name in Monticello's package pane will be removed, and the version number added.

If you then make a change to the package\,---\,say by adding a method to one of the classes\,---\,the asterisk will re-appear, showing that you have unsaved changes.  If you open a repository browser on the package cache, you can select the saved version, and use \button{Changes} and the other buttons.  
You can of course save the new version to the repository too; once you \button{Refresh} the repository view, it should look like \figref{package-cache-browser}.
\index{package!cache}

\begin{figure}[tbp]
	\begin{center}
		\includegraphics[width=\textwidth]{MC+PBE}
	\end{center}
	\caption{The as-yet-unsaved PBE package in Monticello.}
	\figlabel{MC+PBE}
\end{figure}

\begin{figure}[tbp]
	\begin{center}
	\includegraphics[width=0.8\textwidth]{PBE-on}
	\end{center}
	\caption{Providing a log message for a new version of a package.}
	\figlabel{PBE-on}
\end{figure}

\begin{figure}[tbp]
	\begin{center}
	\includegraphics[width=\textwidth]{package-cache-browser}
	\end{center}
	\caption{Two versions of our package are now in the package cache.}
	\figlabel{package-cache-browser}
\end{figure}

To save the new package to a repository other than the package cache, you need to first make sure that Monticello knows about the repository, adding it if necessary.  
Then you can use the \button{Copy} in the package-cache repository browser, and select the repository to which the package should be copied.  
You can also associate the desired repository with the package by \actclick{ing} on the repository and selecting \menu{add to package \ldots}, as shown in \figref{associateRepository}.  
Once the package knows about a repository, you can save a new version by selecting the repository and the package in the Monticello Browser, and clicking \button{Save}.  
Of course, you must have permission to write to a repository.  
The \ct{PharoByExample} repository on \emphind{\sqsrc} is world readable but not world writable, so if you try and save there, you will see an error message.  
However, you can create your own repository on \sqsrc by using the web interface at \url{http://www.squeaksource.com}, and use this to save your work. 
This is especially useful as a mechanism to share your code with friends, or if you use multiple computers.

\begin{figure}[tbp]
	\begin{center}
		\includegraphics[width=\textwidth]{MCaddToPackage}
	\end{center}
	\caption{Adding a repository to the set of repositories associated with a package.}
	\figlabel{associateRepository}
\end{figure}

If you do try and save to a repository where you don't have write permission, a version will nevertheless be written to the package-cache.  
So you can recover by editing the repository information (\actclick in the Monticello Browser) or choosing a different repository, and then using \button{Copy} from the package-cache browser.

%=========================================================
\section{The Inspector and the Explorer}
\seclabel{inspector} % (fold)

One of the things that makes \st so different from many other programming environments is that it is provides you with a window onto a world of live objects, not a world of static code.
Any of those objects can be examined by the programmer, and even changed\,---\,although some care is necessary when changing the basic objects that support the system.  
By all means experiment, but save your image first!

%---------------------------------------------------------
\subsection{The Inspector}

\dothis{As an illustration of what you can do with an \ind{inspector}, type  \ct{TimeStamp now} in a workspace, and then \actclick and choose \menu{inspect it}.} 
(It's not necessary to select the text before using the menu; if no text is selected, the menu operations work on the whole of the current line.
You can also type \short{i} for \menu{\textbf{i}nspect it}.)
\clsindex{TimeStamp}
\index{keyboard shortcut!inspect it}

\begin{figure}[btp]
	\begin{center}
		\includegraphics[width=\textwidth]{inspectTimeNow1}
	\end{center}
	\caption{Inspecting \ct{TimeStamp now}}
	\figlabel{inspectTimeNow1}
\end{figure}

A window like that shown in \figref{inspectTimeNow1} will appear.   
This is an inspector, and can be thought of as a window onto the internals of a particular object\,---\,in this case, the particular instance of \mbox{\ct{TimeStamp}} 
% the \mbox is here because without it, the listings macros puts a space between TimeStamp 
% and the following word, and that space happens to come out at the start of a line.
that was created when you evaluated the expression \ct{TimeStamp now}.
The title bar of the window shows the printable representation of the object that is being inspected.
If you select \menu{self} at the top of the left pane, the right pane will show the printstring of the object.
% If you select \menu{all inst vars} in the left pane, the right pane will show a list of the instance variables in the object, and the printstring for each one.  
% The remaining items in the left pane represent the instance variables; this makes it easy to examine them one at a time, and also to change them.
The left pane shows a tree view of the object, with \self at the root.
Instance variables can be explored by expanding the triangles next to their names.

The horizontal pane at the bottom of the inspector is a small workspace window.  It is useful because in this window, the pseudo-variable \ct{self} is bound to the object that you have selected in the left pane.
So, if you \menu{inspect it} on
\begin{code}{}
self - TimeStamp today
\end{code}
in the workspace pane, the result will be a \clsind{Duration} object that represents the time interval between midnight today and the instant at which you evaluated  \ct{TimeStamp now} and created the \ct{TimeStamp} object that you are inspecting.
You can also try evaluating \ct{TimeStamp now - self}; this will tell you how long you have spent reading this section of this book!

In addition to \ct{self}, all the instance variables of the object are in scope in the workspace pane, so you can use them in expressions or even assign to them.  For example, if you select the root object in the left pane and evaluate \ct{jdn  := jdn - 1} in the workspace pane, you will see that the value of the \ct{jdn} instance variable will indeed change, and the value of \ct{TimeStamp now - self} will increase by one day.

% ON: Does not work anymore
%You can change instance variables directly by selecting them, replacing the old value in the right-hand  pane by a \pharo expression, and accepting.  
%\pharo will evaluate the expression and assign the result to the instance variable.

There are special variants of the inspector for Dictionaries, OrderedCollections, CompiledMethods and a few other classes that make it easier to examine the contents of these special objects.

%---------------------------------------------------------
\subsection{The Object Explorer}

The \emph{object explorer} is conceptually similar to the inspector, but presents its information in a different way.
To see the difference, we'll \emph{explore} the same object that we were just inspecting.

\begin{figure}[tbp]
\begin{minipage}{0.48\textwidth}
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{exploreTimeStampNow}}
		{\includegraphics[width=0.7\textwidth]{exploreTimeStampNow}}
	\end{center}
	\caption{Exploring \ct{TimeStamp now}}
	\figlabel{exploreTimeStampNow}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{exploreTimeStampNow2}}
		{\includegraphics[width=0.7\textwidth]{exploreTimeStampNow2}}
	\end{center}
	\caption{Exploring the instance variables}
	\figlabel{exploreTimeStampNow2}
\end{minipage}
\end{figure}

\dothis{Select \menu{self} in the inspector's left-hand pane, then \actclick and choose \menu{explore (I)}.}
The \ind{explorer} window looks like \figref{exploreTimeStampNow}.
If you click on the small triangle next to \ct{root}, the view will change to \figref{exploreTimeStampNow2}, which shows the instance variables of object that you are exploring.
Click on the triangle next to \ct{offset}, and you will see \emph{its} instance variables.  
The explorer is really useful when you need to explore a complex hierarchic structure\,---\,hence the name.
\index{keyboard shortcut!explore it}

The workspace pane of the object explorer works slightly differently from that of the inspector.
\ct{self} is not bound to the root object, but rather to the object that is currently selected; the instance variables of the selected object are also in scope.

To see the value of the explorer, let's use it to explore a deeply-nested structure of objects.

\dothis{Evaluate \ct{Object explore} in a workspace.}
This is the object that represents the class \ct{Object} in \pharo.
Note that you can navigate directly to the objects representing the method dictionary and even the compiles methods of this class (see \figref{ExploreObject}).

\begin{figure}[tbp]
	\begin{center}
		\includegraphics[width=0.5\textwidth]{ExploreObject}
	\end{center}
	\caption{Exploring a \ct{ExploreObject}}
	\figlabel{ExploreObject}
\end{figure}

%\dothis{Open a browser, and \metaclick five times on the method pane to bring-up the Morphic halo on the \ct{OBPluggableListMorph} that is used to represent the list of messages. 
%Click on the \emph{debug} handle \debugHandle{} and select \menu{explore morph}
%from the menu that appears.  This will open an Explorer on the \clsind{OBPluggableListMorph} object that represents the method list on the screen.  
%Open the root object (by clicking in its triangle), open its \ct{submorphs}, and continue exploring the structure of the objects that underlie this Morph, as shown in \figref{explorePluggableListMorph}.}
%
%\begin{figure}[tbp]
%	\begin{center}
%		\includegraphics[width=0.7\textwidth]{explorePluggableListMorph}
%	\end{center}
%	\caption{Exploring a \ct{PluggableListMorph}}
%	\figlabel{explorePluggableListMorph}
%\end{figure}

%=========================================================
\section{The Debugger}
\seclabel{debugger} % (fold)

The \ind{debugger} is arguably the most powerful tool in the \pharo tool suite.  It is used not just for debugging, but also for writing new code.
To demonstrate the debugger, let's start by creating a bug!

\dothis{Using the browser, add the following method to the class \ct{String}:}

\needlines{7}
\begin{method}[buggy]{A buggy method}
suffix
	"assumes that I'm a file name, and answers my suffix, the part after the last dot"
	| dot dotPosition |
	dot := FileDirectory dot.
	dotPosition := (self size to: 1 by: -1) detect: [ :i | (self at: i) = dot ].
	^ self copyFrom: dotPosition to: self size 
\end{method}

Of course, we are sure that such a trivial method will work, so instead of writing an SUnit test, we just type
\ct{'readme.txt' suffix} in a workspace and \menu{print it (p)}.
What a surprise!  Instead of getting the expected answer \ct{'txt'}, a \clsind{PreDebugWindow} pops up, as shown in \figref{PreDebugWindow}.

\begin{figure}[btp]
	\begin{center}
	\includegraphics[width=0.8\textwidth]{PreDebugWindow}
	\end{center}
	\caption{A \ct{PreDebugWindow} notifies us of a bug.}
	\figlabel{PreDebugWindow}
\end{figure}

The \ct{PreDebugWindow} has a title-bar that tells us what error occurred, and shows us a \emphind{stack trace} of the messages that led up to the error. 
Starting from the bottom of the trace, \ct{UndefinedObject>>>DoIt} represents the code that was compiled and run when we selected \ct{'readme.txt' suffix} in the workspace and asked \pharo to \menu{print it}.
This code, of course, sent the message \ct{suffix} to a \clsind{ByteString} object (\ct{'readme.txt'}). 
This caused the inherited \ct{suffix} method in class \ct{String} to execute; all this information is encoded in the next line of the stack trace, \ct{ByteString(String)>>>suffix}.  
Working up the stack, we can see that \ct{suffix} sent \ct{detect:}\ldots and eventually \ct{detect:ifNone} sent \ct{errorNotFound}.
\clsindex{UndefinedObject}

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{debuggerDetectIfNone}}
		{\includegraphics[width=0.7\textwidth]{debuggerDetectIfNone}}
	\end{center}
	\caption{The debugger.}
	\figlabel{debuggerDetectIfNone}
\end{figure}

To find out \emph{why} the dot was not found, we need the debugger itself, so click on \button{Debug}.

%\dothis{You can also open the debugger by clicking on any of the lines on the stack trace.  If you do this, the debugger will open already focussed on the corresponding method.}

The debugger is shown in \figref{debuggerDetectIfNone}; it looks intimidating at first, but it is quite easy to use.
The title-bar and the top pane are very similar to those that we saw in the \lct{PreDebugWindow}.  
However, the debugger combines the stack trace with a method browser, so when you select a line in the stack trace, the corresponding method is shown in the pane below.
It's important to realize that the execution that caused the error is still in your image, but in a suspended state.  
Each line of the stack trace represents a frame on the execution stack that contains all of the information necessary to continue the execution.  This includes all of the objects involved in the computation, with their instance variables, and all of the temporary variables of the executing methods.

In \figref{debuggerDetectIfNone} we have selected the \ct{detect:ifNone:} method in the top pane.
The method body is displayed in the center pane; the blue highlight around the message \ct{value} shows that the current method has sent the message \ct{value} and is waiting for an answer.

The four panes at the bottom of the debugger are really two mini-inspectors (without workspace panes).
The inspector on the left shows the current object, that is, the object named \self in the center pane.
As you select different stack frames, the identity of \self may change, and so will the contents of the 
\self{}-inspector.
If you click on \self in the bottom-left pane, you will see that \self is the interval \ct{(10 to: 1 by -1)}, which is what we expect.
The workspace panes are not needed in the debugger's mini-inspectors because all of the variables are also in scope in the method pane; you should feel free to type or select expressions in this pane and evaluate them.  
You can always \menu{cancel (l)} your changes using the menu or \short{\textit{l}}. 
% apb: that lower-case-L is in italics so that it doesn't look like a 1 or a |
\index{keyboard shortcut!cancel}

The inspector on the right shows the temporary variables of the current context.
In \figref{debuggerDetectIfNone},
\ct{value} was sent to the parameter \ct{exceptionBlock}.

%\dothis{To see the current value of this parameter, click on \ct{exceptionBlock} in the context inspector.
%This will tell you that \ct{exceptionBlock} is \ct{[self errorNotFound: ...]}.
%\on{no longer true!}

As we can see one method lower in the stack trace, the \ct{exceptionBlock} is \ct{[self errorNotFound: ...]}, so, it is not surprising that we see the corresponding error message.

Incidentally, if you want to open a full inspector or explorer on one of the variables shown in the mini-inspectors, just double-click on the name of the variable, or select the name of the variable and \actclick to choose \menu{inspect (i)} or \menu{explore (I)}.
This can be useful if you want to watch how a variable changes while you execute other code. 
\index{keyboard shortcut!inspect it}
\index{keyboard shortcut!explore it}

Looking back at the method window, we see that we expected the penultimate line of the method to find \ct{dot} in the string \ct{'readme.txt'}, and that execution should never have reached the final line.
\pharo does not let us run an execution backwards, but it does let us start a method again, which works very well in code such as this that does not mutate objects, but instead creates new ones.  

\dothis{Click \button{Restart}, and you will see that the locus of execution returns to the first statement of the current method.  
The blue highlight shows that the next message to be sent will be {\ct{do:}} (see \figref{RestartDetectIfNone}).}

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{RestartDetectIfNone}}
		{\includegraphics[width=0.7\textwidth]{RestartDetectIfNone}}
	\end{center}
	\caption{The debugger after restarting the \ct{detect: ifNone:} method}
	\figlabel{RestartDetectIfNone}
\end{figure}

The \button{Into} and \button{Over} buttons give us two different ways to step through the execution.  If you click \button{Over}, \pharo executes the current message-send (in this case the \ct{do:}) in one step, unless there is an error.  
So \button{Over} will take us to the next message-send in the current method, which is \ct{value}\,---\,this is exactly where we started, and not much help. 
What we need to do is to find out why the \ct{do:} is not finding the character that we are looking for.

\dothis{After clicking \button{Over}, click \button{Restart} to get back to the situation shown in \figref{RestartDetectIfNone}.}

\dothis{Click \button{Into}; \pharo will go into the method corresponding to the highlighted message-send, in this case, \ct{Collection>>>do:}.}

However, it turns out that this is not much help either: we can be fairly confident that \ct{Collection>>>do:} is not broken.  The bug is much more likely to be in \emph{what} we asked \pharo to do.
\button{Through} is the appropriate button to use in this case: we want to ignore the details of the \ct{do:} itself and focus on the execution of the argument block. 

\dothis{Select the \ct{detect:ifNone:} method again and \button{Restart} to get back to the state shown in \figref{RestartDetectIfNone}.
Now click on \button{Through} a few times.  Select \ct{each} in the context window as you do so.
You should see \ct{each} count down from \ct{10} as the \ct{do:} method executes.}

When \ct{each} is \ct{7} we expect the \ct{ifTrue:} block to be executed, but it isn't.
To see what is going wrong, go \button{Into} the execution of \ct{value:} as illustrated in \figref{steppingIntoValue}.

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{steppingIntoValue}}
		{\includegraphics[width=0.7\textwidth]{steppingIntoValue}}
	\end{center}
	\caption{The debugger after stepping \lct{Through} the \ct{do:} method several times.}
	\figlabel{steppingIntoValue}
\end{figure}

After clicking \button{Into}, we find ourselves in the position shown in \figref{dotIsAString}.
It looks at first that we have gone \emph{back} to the \ct{suffix} method, but this is because we are now executing the block that \ct{suffix} provided as argument to \ct{detect:}.
%\on{does not work any more! the debugger does not know about block variables!}
%If you select \ct{i} in the context inspector, you can see its current value, which should be \ct{7} if you have been following along.  
%You can then select the corresponding element of \self from the \self{}-inspector.
%In  \figref{dotIsAString} you can see that element \ct{7} of the string is character 46, which is indeed a dot.
If you select \ct{dot} in the context inspector, you will see that its value is \ct{'.'}.
And now you see why they are not equal: the seventh character of \ct{'readme.txt'} is of course a \ct{Character}, while \ct{dot} is a \ct{String}.

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{dotIsAString}}
		{\includegraphics[width=0.7\textwidth]{dotIsAString}}
	\end{center}
	\caption{The debugger showing why \ct{'readme.txt' at: 7} is not equal to \ct{dot}}
	\figlabel{dotIsAString}
\end{figure}

Now that we see the bug, the fix is obvious: we have to convert \ct{dot} to a character before starting to search for it.  

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{revertDialog}}
		{\includegraphics[width=0.7\textwidth]{revertDialog}}
	\end{center}
	\caption{Changing the \ct{suffix} method in the debugger: asking for confirmation of the exit from an inner block}
	\figlabel{revertDialog}
\end{figure}

\dothis{Change the code right in the debugger so that the assignment reads \ct{dot := FileDirectory dot first} and \menu{accept} the change.}

Because we are executing code inside a block that is inside a \lct{detect:}, several stack frames will have to be abandoned in order to make this change.  \pharo asks us if this is what we want (see \figref{revertDialog}), and, assuming that we click \menu{yes}, will save (and compile) the new method.

%\dothis{Click \button{Restart} and then \button{Proceed}; the debugger window will vanish, and the evaluation of the expression \ct{'readme.txt' suffix} will complete, and print the answer \ct{'.txt'}}

The evaluation of the expression \ct{'readme.txt' suffix} will complete, and print the answer \ct{'.txt'}.

Is the answer correct?  Unfortunately, we can't say for sure.  Should the suffix be \ct{.txt} or \ct{txt}?
The method comment in \ct{suffix} is not very precise.  
The way to avoid this sort of problem is to write an \ind{SUnit} test that defines the answer.

\begin{method}[testSuffix]{A simple test for the \ct{suffix} method}
testSuffixFound
	self assert: 'readme.txt' suffix = 'txt'
\end{method}

The effort required to do that was little more than to run the same test in the workspace, but using \sunit saves the test as executable documentation, and makes it easy for others to run.
Moreover, if you add \mthref{testSuffix} to the class \ct{StringTest} and run that test suite with \sunit, you can very quickly get back to debugging the error.
\sunit opens the debugger on the failing assertion, but you need only go back down the stack one frame, \button{Restart} the test and go \button{Into} the \ct{suffix} method, and you can correct the error, as we are doing in \figref{fixOffByOne}.
It is then only  a second of work to click on the \button{Run Failures} button in the \sunit Test Runner, and confirm that the test now passes.

\begin{figure}[btp]
	\begin{center}
		\includegraphics[width=\textwidth]{fixOffByOne}
	\end{center}
	\caption{Changing the \ct{suffix} method in the debugger: fixing the off-by-one error after an \sunit assertion failure}
	\figlabel{fixOffByOne}
\end{figure}

Here is a better test:

\begin{method}[testSuffix2]{A better test for the \ct{suffix} method}
testSuffixFound
	self assert: 'readme.txt' suffix = 'txt'.
	self assert: 'read.me.txt' suffix = 'txt'
\end{method}
\noindent
Why is this test better?  Because it tells the reader what the method should do if there is more than one dot in the target String.

There are a few other ways to get into the debugger in addition to catching errors and assertion failures.
If you execute code that goes into an infinite loop, you can interrupt it and open a debugger on the computation by typing \short{.} (that's a full stop or a period, depending  on where you learned English).\footnote{It is also useful to know that you can bring up an emergency debugger at any time by typing \short{{\sc shift--}.}}
You can also just edit the suspect code to insert \ct{self halt}.
So, for example, we might edit the \ct{suffix} method to read as follows:
\index{process!interrupting}

\needspace{11ex}
\begin{method}[suffix]{Inserting a \ct{halt} into the \ct{suffix} method.}
suffix
	"assumes that I'm a file name, and answers my suffix, the part after the last dot"
	| dot dotPosition |
	dot := FileDirectory dot first.
	dotPosition := (self size to: 1 by: -1) detect: [ :i | (self at: i) = dot ].
	self halt.
	^ self copyFrom: dotPosition to: self size 
\end{method}

When we run this method, the execution of the \ct{self halt} will bring up the \ind{pre-debugger}, from where we can proceed, or go into the debugger and look at variables, step the computation, and edit the code.

That's all there is to the debugger, but it's not all there is to the \ct{suffix} method.  
The initial bug should have made you realize that if there is no dot in the target string, the \ct{suffix} method will raise an error.  
This isn't the behaviour that we want, so let's add a second test to specify what should happen in this case.

\needlines{3}
\begin{method}[testNoSuffix]{A second test for the \ct{suffix} method: the target has no suffix}
testSuffixNotFound
	self assert: 'readme' suffix = ''
\end{method}

\needlines{2}
\dothis{Add \mthref{testNoSuffix} to the test suite in class \clsind{StringTest}, and watch the test raise an error.
Enter the debugger by selecting the erroneous test in \sunit, and edit the code so that the test passes.
The easiest and clearest way to do this is to replace the \ct{detect:} message by \ct{detect: ifNone:}, where  the second argument is a block that simply returns the string size.}

We will learn more about SUnit in \charef{SUnit}.

% section debugger (end)

%=========================================================
\section{The Process Browser}

\st is a multi-threaded system: there are many lightweight processes (also known as threads) running concurrently in your image. 
In the future the \pharo virtual machine may take advantage of multiprocessors when they are available, but at present concurrency is implemented by time-slicing.

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{processBrowser}}
		{\includegraphics[width=0.7\textwidth]{processBrowser}}
	\end{center}
	\caption{The Process Browser}
	\figlabel{processBrowser}
\end{figure}

The process \subind{process}{browser} is a cousin of the debugger that lets you look at the various processes running inside \pharo.
\figref{processBrowser} shows a screenshot.
The top-left pane lists all of the processes in \pharo, in priority order, from the timer interrupt watcher at priority 80 to the idle process at priority 10.
Of course, on a uniprocessor, the only process that can be running when you look is the UI process; all others will be waiting for some kind of event.
%:===> Process browser context menu is broken!
\on{broken -- to be fixed!}
By default, the display of processes is static; it can be updated by \actclick{ing} and selecting \menu{turn on auto-update (a)}

If you select a process in the top-left pane, its stack trace is displayed in the top-right pane, just as with the debugger.
If you select a stack frame, the corresponding method is displayed in the bottom pane.
The process browser is not equipped with mini-inspectors for \self and \lct{thisContext}, but \actclick{ing} on the stack frames provide equivalent functionality.

%=========================================================
\section{Finding methods}
\seclabel{methodFinder} 

There are two tools in \pharo to help you find messages.
They differ in both interface and functionality.

The \emph{method finder} was described at some length in \secref{quick:methodFinder}; you can use it to find methods by name or by functionality. 
However, to look at the body of a method, the method finder opens a new browser.
This can quickly become overwhelming.

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{methodNamesRandom}}
		{\includegraphics[width=0.7\textwidth]{methodNamesRandom}}
	\end{center}
	\caption{The message names browser showing all methods containing the substring \ct{random} in their selectors.}
	\figlabel{methodNamesRandom} % should be *message* names!
\end{figure}

\index{message names browser}
The \emph{message names} browser has more limited search functionality: you type a fragment of a message selector in the search box, and the browser lists all methods that contain that fragment in their names, as shown in \figref{methodNamesRandom}.
However, it is a full-fledged browser:
if you select one of the names in the left pane, all of the methods with that name are listed in the right pane, and can be browsed in the bottom pane.
As with the browser, the message names browser has a button bar that can be used to open other  browsers on the selected method or its class.


% section methodFinder (end)

%=========================================================
\section{Change sets and the Change Sorter}
\seclabel{env:changeSet} % (fold)

Whenever you are working in \pharo, any changes that you make to methods and classes are recorded in a \ct{change set}.
This includes creating new classes, re-naming classes, changing categories, adding methods to existing classes\,---\,just about everything of significance.  
However, arbitrary \emph{doits} are not included, so if, for example, you create a new global variable by assigning to it in a workspace, the variable creation will not make it into a \subind{file}{change set}.
\index{change sorter}

At any time, many change sets exist, but only one of them\,---\,\ct{ChangeSet current}\,---\,is collecting the changes that are being made to the image.  
You can see which change set is current and can examine all of the change sets using the  change sorter, available by selecting \menu{World \go Tools \ldots \go Change Sorter}.

\begin{figure}[btp]
	\begin{center}
		\includegraphics[width=\linewidth]{changeSorter}
	\end{center}
	\caption{The Change Sorter}
	\figlabel{changeSorter}
\end{figure}

\figref{changeSorter} shows this browser.  The title bar shows which change set is current, and this change set is selected when the change sorter opens. 

Other change sets can be selected in the top-left pane; the \actclick menu allows you to make a different change set current, or to create a new change set.
The next pane lists all of the classes affected by the selected change set (with their categories).
Selecting one of the classes displays the names of those of its methods that are also in the change set (\emph{not} all of the methods in the class) in the left central pane, and selecting a method name displays the method definition in the bottom pane.
Note that the change sorter does \emph{not} show you whether the creation of the class itself is part of the change set, although this information is stored in the object structure that is used to represent the change set.

The change sorter also lets you delete classes and methods from the change set using the \actclick menu on the corresponding items.
%  However, for more elaborate editing of change sets, you should use a second tool, the \textit{change sorter}, available by selecting \menu{World\go{}open \ldots \go{}dual change sorter}, which is shown in \figref{changeSorter}.
% The change sorter is essentially two change set browsers side by side; each side can focus on a different change set, class, or method.

The change sorter allows you to simultaneously view two change sets, one on the left hand side and the other on the right.
This layout supports the change sorter's main feature, which is the ability to move or copy changes from one change set to another, as shown by the \actclick menu in \figref{changeSorter}.
It is also possible to copy individual methods from one side to the other.

You may be wondering why you should care about the composition of a change set.
the answer is that change sets provide a simple mechanism for exporting code from \pharo to the file system, from where it can be imported into another \pharo image, or into another non-\pharo \st.
Change set export is known as ``filing-out'', and can be accomplished using the \actclick menu on any change set, class or method in either browser.
Repeated file outs create new versions of the file, but change sets are not a versioning tool like Monticello:
they do not keep track of dependencies.
\index{file!filing out}

Before the advent of Monticello, change sets were the main means for exchanging code between \pharo{}ers.
They have the advantage of simplicity (the file out is just a text file, although we \emph{don't} recommend that you try to edit them with a text editor), and a degree of portability.  
%It's also quite easy to create a change set that makes changes to many different, unrelated parts of the system\,---\,something that Monticello is not yet equipped to do.
%\ab{Or is it?}
%\on{you mean something different than extensions to foreign packages using the *package protocol notation?}

The main drawback of change sets, compared to \ind{Monticello} packages, is that they do not support the notion of dependencies.
A filed-out change set is a set of \emph{actions} that change any image into which it is loaded. To successfully load a change set requires that the image be in an appropriate state.
For example, the change set might contain an action to add a method to a class; this can only be accomplished if the class is already defined in the image.
Similarly, the change set might rename or re-categorize a class, which obviously will only work if the class is present in the image; methods may use instance variables that were declared when they were filed out, but which do not exist in the image into which they are imported.
The problem is that change sets do not explicitly describe the conditions under which they can be filed in:
the file in process just hopes for the best, usually resulting in a cryptic error message and a stack trace when things go wrong.
Even if the file in works, one change set might silently undo a change made by another change set.

In contrast, Monticello packages represent code in a declarative fashion: they describe the state of the image should be in after they have been loaded.
This permits Monticello to warn you about conflicts (when two packages require contradictory final states)
and to offer to load a series of packages in dependency order.

In spite of these shortcomings, change sets still have their uses; in particular, you may find change sets on the Internet that you want to look at and perhaps use.
So, having filed out a change set using the change sorter, we will now tell you how to file one in.
This requires the use of another tool, the file list browser.

% section changeSet (end)

%=========================================================
\section{The File List Browser}

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{fileList}}
		{\includegraphics[width=0.7\textwidth]{fileList}}
	\end{center}
	\caption{A file list browser}
	\figlabel{fileList}
\end{figure}

The \ind{file list browser} is in fact a general-purpose tool for browsing the file system (and also FTP servers) from \pharo. 
You can open it from the \menu{World\go{}Tools \ldots \go{}File Browser} menu.
What you see of course depends on the contents of your local file system, but a typical view is shown in \figref{fileList}.
\seeindex{file!browsing}{file list browser}

When you first open a file list browser it will be focussed on the current directory, that is, the one from which you started \pharo. The title bar shows the path to this directory.
The larger pane on the left-hand side can be used to navigate the file system in the conventional way.
When a directory is selected, the files that it contains (but not the directories) are displayed on the right.
This list of files can be filtered by entering a Unix-style pattern in the small box at the top-left of the window.  
Initially, this pattern is \ct{*}, which matches all file names, but you can type a different string there and accept it, changing the pattern.  (Note that a \ct{*} is implicitly prepended and appended to the pattern that you type.)
The sort order of the files can be changes using the \button{name}, \button{date} and \button{size} buttons.
The rest of the buttons depend on the name of the file selected in the browser.
In \figref{fileList}, the file name has the suffix \ct{.cs}, so the browser assumes that it is a change set, and provides buttons to \button{install} it (which \textit{files it in} to a new change set whose name is derived from the name of the file),  to browse the \button{changes} in the file, to examine the \button{code} in the file, 
and to \button{filein} the code into the \emph{current} change set.
You might think that the \button{conflicts} button would tell you about changes in the change set that conflicted with existing code in the image, but it doesn't.
\ab{Does anyone know what it does do?  I've never found it useful.}
\on{I tried it and found that it complained about linefeeds.}
Instead it just checks for potential problems in the file that might indicate that the file cannot properly be loaded (such as the presence of linefeeds).

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{fileContentsBrowser}}
		{\includegraphics[width=0.7\textwidth]{fileContentsBrowser}}
	\end{center}
	\caption{A File Contents Browser}
	\figlabel{fileContentsBrowser}
\end{figure}

Because the choice of buttons to display depends on the file's \emph{name}, and not on its contents, sometimes the button that you want won't be on the screen.  
However, the full set of options is always available from the \actclick \menu{more \ldots} menu, so
you can easily work around this problem.

The \button{code} button is perhaps the most useful for working with change sets; it opens a browser on the contents of the change set file; an example is shown in \figref{fileContentsBrowser}.
The file contents browser is similar to the browser except that it does not show categories, just classes, protocols and methods.
For each class, the browser will tell you whether the class already exists in the system and whether it is defined in the file (but \emph{not} whether the definitions are identical).  
It will show the methods in each class, and (as shown in \figref{fileContentsBrowser}) will show you the differences between the current version and the version in the file.
Contextual menu items in each of the top four panes will also let you file in the whole of the change set, or the corresponding class, protocol or method. 

%=========================================================
\section{In Smalltalk, you can't lose code}
\seclabel{cantLoseCode} % (fold)

It is quite possible to crash \pharo: as an experimental system, \pharo lets you change anything, including things that are vital to make \pharo work! 

\dothis{To maliciously crash \pharo, try \ct{Object become: nil}.}

The good news is that you need never lose any work, even if you crash and go back to the last saved version of your image, which might be hours old.
This is because all of the code that you executed is saved in the \emph{.changes} file.
All of it!
This includes one liners that you evaluate in a workspace, as well as code that you add to a class while programming.
\index{changes}

So here are the instructions on how to get your code back.
There is no need to read this until you need it. 
However, when you do need it, you'll find it here waiting for you.

In the worst case, you can use a text editor on the \emph{.changes} file, but since it is many megabytes in size, this can be slow and is not recommended. 
\pharo offers you better ways.

%---------------------------------------------------------
\subsection{How to get your code back}
Restart \pharo from the most recent snapshot, and select \menu{World\go{}Tools \ldots \go{}Recover lost changes}. 
%This will open a workspace full of useful expressions. The first three,

%\begin{code}{}
%Smalltalk recover: 10000.
%ChangeList browseRecentLog.
%ChangeList browseRecent: 2000.
%\end{code}

%\noindent
%are most useful for recovery.

% If you execute \ct{ChangeList browseRecentLog}, you will be given 

This will give the opportunity to decide how far back in history you wish to browse. 
Normally, it's sufficient to browse changes as far back as the last snapshot. (You can get much the same effect by editing \ct{ChangeList browseRecent: 2000} so that the number \ct{2000} becomes something else, using trial and error.)

One you have a \emph{recent changes} browser, showing, say, changes back as far as your last snapshot, you will have a list of everything that you have done to \pharo during that time. 
You can delete items from this list using the \actclick menu.
When you are satisfied, you can file-in what is left, thus incorporating the changes into your new image.
It's a good idea to start a new change set, using the ordinary change set browser, before you do the file in, so that all of your recovered code will be in a new change set. 
You can then file out this change set.

One useful thing to do in the \emph{recent changes} browser is to \menu{remove doIts}. 
Usually, you won't want to file in (and thus re-execute) doIts. 
However, there is an exception. 
Creating a class shows up as a \menu{doIt}.
\emph{Before you can file in the methods for a class, the class must exist.}
So, if you have created any new classes, \emph{first} file-in the class creation doIts, then \menu{remove doIts} and file in the methods.
\lr{Maybe mention that class renames are not logged and completely screw up the change-set mechanism. (p. 174)}

When I am finished with the recovery, I like to file out my new change set, quit \pharo without saving the image, restart, and make sure that the new change set files back in cleanly.
% section cantLoseCode (end)

%=========================================================
\section{Chapter summary}

In order to develop effectively with \pharo, it is important to invest some effort into learning the tools available in the environment.

\begin{itemize}
  \item The standard \emph{browser} is your main interface for browsing existing categories, classes, method protocols and methods, and for defining new ones.
  The browser offers several useful buttons to directly jump to senders or implementors of a message, versions of a method, and so on.
  \item There exist several different browsers (such as the OmniBrowser and the Refactoring Browser), and several specialized browsers (such as the hierarchy browser) which provide different views of classes and methods.
  \item From any of the tools, you can highlight the name of a class or a method and immediately jump to a browser by using the keyboard shortcut \short{b}.
  \item You can also browse the \st system programmatically by sending messages to \ct{SystemNavigation default}.
  \item \emph{Monticello} is a tool for exporting, importing, versioning and sharing packages of classes and methods.
  A Monticello package consists of a category, subcategories, and related methods protocols in other categories.
  \item The \emph{inspector} and the \emph{explorer} are two tools that are useful for exploring and interacting with live objects in your image.
  You can even inspect tools by \metaclick{ing} to bring up their morphic halo and selecting the debug handle \debugHandle.
  \item The \emph{debugger} is a tool that not only lets you inspect the run-time stack of your program when an error is raised, but it also enables you to interact with all of the objects of your application, including the source code. In many cases you can modify your source code from the debugger and continue executing. The debugger is especially effective as a tool to support test-first development in tandem with SUnit (\charef{SUnit}).
  \item The \emph{process browser} lets you monitor, query and interact with the processes current running in your image.
  \item The \emph{method finder} and the \emph{message names browser} are two tools for locating methods. The first is more useful when you are not sure of the name, but you know the expected behaviour. The second offers a more advanced browsing interface when you know at least a fragment of the name.
  \item \emph{Change sets} are automatically generated logs of all changes to the source code of your image. They have largely been superseded by Monticello as a means to store and exchange versions of your source code, but are still useful, especially for recovering from catastrophic failures, however rare these may be.
  \item The \emph{file list browser} is a tool for browsing the file system. It also allows you to \menu{filein} source code from the file system.
  \item In case your image crashes before you could save it or backup your source code with Monticello, you can always recover your most recent changes using a \emph{change list browser}. You can then select the changes you want to replay and file them into the most recent copy of your image.
\end{itemize}

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%=========================================================
%---------------------------------------------------------
