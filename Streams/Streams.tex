% $Author$
% $Date$
% $Revision$

% HISTORY:
% 2007-03-30 - Cassou splits of Streams from Collection chapter
% 2007-07-05 - Cassou partial draft complete?
% 2007-08-02 - Stef pass
% 2007-08-16 - Cassou continues
% 2007-08-21 - Oscar edit
% 2007-08-21 - Cassou review
% 2009-07-07 - Oscar migrate to Pharo; fixed broken tests
% 2011-06-16 - NicoPaez started spanish translation

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
\chapter{Streams}\chalabel{streams}

\ew{Streams are presented as a way to navigate collection. From my point of view, stream are important not to navigate collection, but to produce/consume data:
(a)	memory constraint. Data can not hold into memory and must be processed in a stream fashion, e.g: encryption
(b)	blocking IO. A stream is a nice abstraction to deal with, and the stream manages internally data availability, buffering, etc. to simplify the consumption/production of data
Only few streams have random access capability.}

\clsindexmain{Stream}
Los Streams son usados para iterar sobre secuencias de elementos como colecciones secuenciadas, archivos y streams de red.
Los Streams pueden ser de lectura, de escritura o de ambos.
Leer o escribir es siempre relativo a la posici\'on en el stream.
Los Streams pueden ser f\'acilmente convertidos en colecciones y vice versa.

\lr{"Streams can easily be converted into collections." I wouldn't say it like this, because it is not true for all streams (infinite streams). According to Kent Beck we should only talk about conversion when the same protocol is supported. Collections and Streams do not support the same protocol. (p. 249)}

%=============================================================
\section{Dos secuencias de elementos}
Una buena met\'afora para entender un stream es las siguiente: Un stream puede ser representado como dos secuencias de elementos: una secuencia de 
elementos pasados y una secuencias de elementos futuros.
El stream es posicionado entre las dos secuencias. Entender este modelo es importante ya que toda operaci\'on en \st se basa en el.
The stream is positioned between the two

Por esta raz\'on, la mayoria de las classes \clsind{Stream} son subclases de \clsind{PositionableStream}.
\figref{_abcde} presenta un stream con cinco caracteres. Este stream est\'a es su posici\'on original, \ie no hay elementos anteriores. 
Puedes volver a esta posici\'on usando el mensaje \mthind{PositionableStream}{reset}.

\begin{figure}[ht]
\centerline{\includegraphics[scale=0.5]{_abcdeStef}}
\caption{Un stream posicionado en su comienzo.}
\figlabel{_abcde}
\vspace{.2in}
\end{figure}

Leer un elemento conceptualmente significa sacar el primer elemento de la secuencia de elementos futuros y ponerlo despues del \'ultimo en
la secuencia de elementos pasados. Luego de haber leido un elemento usando el mensaje \ct{next}, el estado de tu stream es el mostrado en \figref{a_bcde}.

\begin{figure}[ht]
\centerline{\includegraphics[scale=0.5]{a_bcdeStef}}
\caption{El mismo stream despues de la ejecuci\'on del m\'etodo \ct{next}: ell caracter \ct{a} est\'a ``en el pasado'' mientras \ct{b}, \ct{c}, \ct{d} y
 \ct{e} estan ``en el futuro''.}
\figlabel{a_bcde}
\vspace{.2in}
\end{figure}

Escribir un elemento significa reemplazar el primer elemento de la secuencia futura por el nuevo y moverlo hacia atras.
 \figref{ax_cde} muestra el estado del mismo stream despues de haber escrito a \ct{x} usando el mensaje \mthind{Stream}{nextPut:} \ct{anElement}.

\begin{figure}[h!t]
\centerline{\includegraphics[scale=0.5]{ax_cdeStef}}
\caption{El mismo stream despues de haber escrito una \ct{x}.}
\figlabel{ax_cde}
\vspace{.2in}
\end{figure}

%=============================================================
\section{Streams vs. colecciones}

El protocolo de colecci\'on soporte el almacenamiento, la remoci\'on y enumeraci\'on de los elementos de una colecci\'on, 
but no permite que estas operaciones sean entremezcladas.  Por ejemplo, si los elementos de una \clsind{OrderedCollection} son
procesados por un m\'etodo \mthind{OrderedCollection}{do:}, no es posible agregar o remover elementos desde el interior del bloque \ct{do:}.
El protocolo de colecci\'on tampoco ofrece formas de interar sobre dos colecciones al mismo tiempo, eligiendo cual colecci\'on avanza y cual no.
Procedimientos como estos requieren que un \'indice transversal o una posici\'on de referencia sea mantenida fuera de la propia colecci\'on:
este es exactamente el rol de \clsind{ReadStream}, \clsind{WriteStream} y \clsind{ReadWriteStream}.

Estas tres clases estan definidas para trabajar sobre alguna colecci\'on.
Por ejemplo, el siguiente fragmento de c\'odigo crea un stream sobre un int\'ervalo y luego lee dos elementos
\needlines{5}
\begin{code}{@TEST |r|}
r := ReadStream on: (1 to: 1000).
r next.   --> 1
r next.   --> 2
r atEnd.--> false
\end{code}

\ct{WriteStream}s pueden escribir datos en una colecci\'on:
\begin{code}{@TEST |w|}
w := WriteStream on: (String new: 5).
w nextPut: $a.
w nextPut: $b.
w contents. -->  'ab'
\end{code}

Tambi\'en es posible crear \ct{ReadWriteStream}s que soporte ambos protocolos de escritura y lectura.

El principal problema con \ct{WriteStream} y \ct{ReadWriteStream} es que solo soportan arreglos y cadenas de caracteres en \pharo. Esto estÃ¡ siendo
cambiado actualmente con el desarrollo de una nueva biblioteca llamada Nile, pero por ahora si intentas trabajar sobre otra clase de colecci\'on, obtendr\'as un error:

\needlines{3}
\begin{code}{}
w := WriteStream on: (OrderedCollection new: 20).
w nextPut: 12. -->  raises an error
\end{code}

Los Streams no estan solo pensados para colecciones, tambi\'en pueden ser usados con archivos o sockets.
El siguiente ejemplo crea un archivo llamado \ct{test.txt}, escribe dos cadenas de caracteres separadas por un retorno de carro
y cierra el archivo.

\needlines{3}
\begin{code}{}
StandardFileStream
  fileNamed: 'test.txt'
  do: [:str | str
                nextPutAll: '123';
                cr;
                nextPutAll: 'abcd'].
\end{code}
\cmindex{FileStream class}{fileNamed:do:}

Las siguientes secciones presentan los protocoles en mayor profundidad.

%=============================================================
\section{Streaming over collections}

Los streams son realmente \'utiles para trabajar con colecciones de elementos. Pueden ser usados para leer y escribir elementos en colecciones
Ahora exploraremos las caracteristicas de los streams para las colecciones.

%-----------------------------------------------------------------
\subsection{Leyendo colecciones}

Esta secci\'on presenta caracteristicas usadas para leer colecciones. Usar un stream para leer una colecci\'on provee un puntero a la colecci\'on.
Dicho puntero se mover\'a hacia adelante leyendo y podr\'as ubicarlo donde gustes.

La clase \clsindmain{ReadStream} deberia usarse para leer elementos de la colecci\'on.

Los m\'etodos \mthind{ReadStream}{next} ay \mthind{ReadStream}{next:} son utilizados para obtener uno o m\'as elementos de una colecci\'on.


\begin{code}{@TEST |stream|}
stream := ReadStream on: #(1 (a b c) false).
stream next. -->   1
stream next. -->   #(#a #b #c)
stream next. -->   false
\end{code}
\cmindex{PositionableStream class}{on:}

\begin{code}{@TEST |stream|}
stream := ReadStream on: 'abcdef'.
stream next: 0. -->   ''
stream next: 1. -->   'a'
stream next: 3. -->   'bcd'
stream next: 2. -->   'ef'
\end{code}

El mensaje \mthind{PositionableStream}{peek} es usado cuando quieres conocer el siguiente elemento en el stream sin avanzar.

\begin{code}{@TEST |stream negative number|}
stream := ReadStream on: '-143'.
negative := (stream peek = $-).    "look at the first element without reading it"
negative. --> true
negative ifTrue: [stream next].       "ignores the minus character"
number := stream upToEnd.
number. --> '143'
\end{code}
\noindent

%$

% This code sets the boolean variable \ct{negative} according to the sign of the
% number in the stream and \ct{number} to its absolute value. The method
% \mthind{ReadStream}{upToEnd} returns everything from the current position to the end
% of the stream and sets the stream to its end. This code can be
% simplified using \mthind{PositionableStream}{peekFor:}, which moves forward if the following element equals the parameter and doesn't move otherwise.
Este c\'odigo establece la variable booleana \ct{negative} de acuerdo al signo del n\'umero
en el stream y \ct{number} a su valor absoluto. El m\'etodo \mthind{ReadStream}{upToEnd} devuelve
todo desde la posici\'on actual hasta el final del stream y establece el stream hasta su final. 
Este c\'odigo puede ser simplificado usando \mthind{PositionableStream}{peekFor:}, que adelanta si el siguiente
elemento es igual al par\'ametro y no se mueve en otro caso.

\begin{code}{@TEST |stream negative number|}
stream := '-143' readStream.
(stream peekFor: $-) --> true
stream upToEnd         --> '143'
\end{code}
\noindent

%$
%\ct{peekFor:} also returns a boolean
%indicating if the parameter equals the element.
\ct{peekFor:} tambi\'en devuelve un booleano indicanto si el par\'ametro es igual al elemento.

Puede que hayas notado un nuevo modo de construir un stream en el ejemplo anterior: uno puede simplemente enviar 
\mthind{SequenceableCollection}{readStream} a una colecci\'on secuenciable para obtener un stream de lectura de una colecci\'on particular.
collection.

\paragraph{Posicionamiento.} Hay m\'etodos para posicionar el puntero del stream. Si tienes el \'indice, puedes
usarlo directamente usando \mthind{PositionableStream}{position:}. Puedes pedir la posici\'on usando \mthind{PositionableStream}{position}. 
Por favor recuerda que un stream no est\'a posicionado en un elemento, sino entre dos elementos. El \'indice correspondiente al comienzo del stream es 0.

Puedes obtener el estado del stream representado en \figref{ab_cde} con el siguiente c\'odigo

\begin{code}{@TEST |stream|}
stream := 'abcde' readStream.
stream position: 2.
stream peek --> $c
\end{code}
%$

\begin{figure}[h!t]
\centerline{\includegraphics[scale=0.5]{ab_cdeStef}}
\caption{Un stream en la posici\'on 2}
\figlabel{ab_cde}
\vspace{.2in}
\end{figure}

%To position the stream at the beginning or the end, you can use
Para posicionar el stream al principio o al final, puedes usar \mthind{PositionableStream}{reset} \'o \mthind{PositionableStream}{setToEnd}.
\mthind{PositionableStream}{skip:} y \mthind{PositionableStream}{skipTo:} son usados para
% go forward to a location relative to the current position: \ct{skip:}
% accepts a number as argument and skips that number of elements whereas
% \ct{skipTo:} skips all elements in the stream until it finds an
% element equal to its parameter. Note that it positions the stream
% after the matched element.
adelantar hasta una posici\'on relativa a la posici\'on actual: \ct{skip:}
toma un n\'umero como par\'ametro y saltea ese n\'umero de elementos, mientras que
\ct{skipTo:} saltea todos los elementos en el stream hasta que encuentra un elemento
igual a su par\'ametro. Notar que posiciona el stream despu\'es del elemento encontrado.

\begin{code}{@TEST |stream|}
stream := 'abcdef' readStream.
stream next.        --> $a    "stream is now positioned just after the a"
stream skip: 3.                           "stream is now after the d"
stream position.  -->   4
stream skip: -2.                          "stream is after the b"
stream position.  --> 2
stream reset.
stream position.  --> 0
stream skipTo: $e.                      "stream is just after the e now"
stream next.        --> $f
stream contents. --> 'abcdef'
\end{code}
%$
%As you can see, the letter \ct{e} has been skipped.
Como puedes ver, la letra \ct{e} ha sido salteada. 

%The method \mthind{PositionableStream}{contents} always returns a copy of the entire stream.
El m\'etodo \mthind{PositionableStream}{contents} siempre devuelve una copia completa del stream.

%\paragraph{Testing.} Some methods allow you to test the state of the current stream:
%\mthind{PositionableStream}{atEnd} returns true if and only if no more elements can be read whereas \mthind{PositionableStream}{isEmpty} returns true if and only if there is no element at all in the collection.
\paragraph{Testing.} Algunos m\'etodos te permiten probar el estado del stream actual:
%Traducimos Testing?
\mthind{PositionableStream}{atEnd} devuelve verdadero si y solo si no hay m\'as elementos que puedan ser le\'idos, 
mientras que \mthind{PositionableStream}{isEmpty} devuelve verdadero si y solo si no hay m\'as elementos en la colecci\'on.

%Here is a possible implementation of an algorithm using \ct{atEnd} that takes two sorted collections as parameters and merges those collections into another sorted collection:
Aqu\'i hay una posible implementaci\'on de un algoritmo usando \ct{{atEnd} que toma dos colecciones ordenadas como 
par\'ametros y las mezcla, creando otra colecci\'on ordenada. 

\needlines{4}
\begin{code}{@TEST |stream1 stream2 result|}
stream1 := #(1 4 9 11 12 13) readStream.
stream2 := #(1 2 3 4 5 10 13 14 15) readStream.

"The variable result will contain the sorted collection."
result := OrderedCollection new.
[stream1 atEnd not & stream2 atEnd not]
  whileTrue: [stream1 peek < stream2 peek
    "Remove the smallest element from either stream and add it to the result."
    ifTrue: [result add: stream1 next]
    ifFalse: [result add: stream2 next]].

"One of the two streams might not be at its end. Copy whatever remains."
result
  addAll: stream1 upToEnd;
  addAll: stream2 upToEnd.

result. -->   an OrderedCollection(1 1 2 3 4 4 5 9 10 11 12 13 13 14 15)
\end{code}

%-----------------------------------------------------------------
%\subsection{Writing to collections}
\subsection{Escribiendo colecciones}

% We have already seen how to read a collection by iterating over its
% elements using a \ct{ReadStream}. We'll now learn how to create
% collections using \clsindmain{WriteStream}{}s.
Ya hemos visto como leer una colecci\'on iterando sobre sus elementos, usando un \ct{ReadStream}. 
Ahora aprenderemos como crear colecciones usando \clsindmain{WriteStream}{}s.

%\ct{WriteStream}s are useful for appending a lot of data to a collection at various locations. They are often used to construct strings that are based on static and dynamic parts as in this example:
Los \ct{WriteStream}s son \'utiles para agregar muchos datos a una colecci\'on en varias posiciones. A menudo son usados para construir cadenas de caracteres basadas en partes est\'aticas o din\'amicas, como en este ejemplo:

\begin{code}{NB: can't be tested due to the changing number of classes}
stream := String new writeStream.
stream
  nextPutAll: 'This Smalltalk image contains: ';
  print: Smalltalk allClasses size;
  nextPutAll: ' classes.';
  cr;
  nextPutAll: 'This is really a lot.'.

stream contents. --> 'This Smalltalk image contains: 2322 classes.
This is really a lot.'
\end{code}

% This technique is used in the different implementations of the method
% \ct{printOn:} for example. There is a simpler and more efficient way
% of creating streams if you are only interested in the content of the
% stream:
Esta t\'ecnica es usada en diferentes implementaciones del m\'etodo \ct{printOn:} por ejemplo.
Hay una manera m\'as simple y eficiente de crear streams, si solo estas interesado en el contenido
del stream:

\begin{code}{@TEST |string|}
string := String streamContents:
		[:stream |
			stream
                 print: #(1 2 3);
                 space;
                 nextPutAll: 'size';
                 space;
                 nextPut: $=;
                 space;
                 print: 3.	].
string. -->   '#(1 2 3) size = 3'
\end{code}
%$
%The method \mthind{SequenceableCollection class}{streamContents:} \seclabel{streamContents} creates a collection and a stream on
%that collection for you. It then executes the block you gave passing
%the stream as a parameter. When the block ends, \ct{streamContents:}
%returns the content of the collection.
El m\'etodo \mthind{SequenceableCollection class}{streamContents:} \seclabel{streamContents} crea una colecci\'on y un stream
en esa colecci\'on por ti. Luego ejecuta el bloque que le has indicado, pasandoo el stream como par\'ametro. Cuado el bloque
termina, \ct{streamContents:} devuelve el contenido de la colecci\'on.

%The following \ct{WriteStream} methods are especially useful in this context:
Los siguientes m\'etodos \ct{WriteStream} son especialmente \'utiles en este contexto:

\begin{description}
%\item[\lct{nextPut:}] adds the parameter to the stream;
\item[\lct{nextPut:}] agrega el par\'ametro al stream;
%\item[\lct{nextPutAll:}] adds each element of the collection, passed as a parameter, to the stream;
\item[\lct{nextPutAll:}] agrega cada elemento de la colecci\'on, pasado como par\'ametro, al stream;
%\item[\lct{print:}] adds the textual representation of the parameter to the stream.
\item[\lct{print:}] agrega la representaci\'on textual del par\'ametro al stream.
	\cmindex{Stream}{print:}
\end{description}

% There are also methods useful for printing different kinds of characters to
% the stream like \mthind{WriteStream}{space}, \mthind{WriteStream}{tab} and
% \mthind{WriteStream}{cr} (carriage return). Another useful
% method is \mthind{WriteStream}{ensureASpace} which ensures that the last character
% in the stream is a space; if the last character isn't a space it adds one.
Tambi\'en hay m\'etodos \'utiles para imprimir diferentes tipos de caracteres en el stream, 
como \mthind{WriteStream}{space}, \mthind{WriteStream}{tab} y \mthind{WriteStream}{cr} (carriage return).
Otro m\'etodo de utilidad es \mthind{WriteStream}{ensureASpace}, que asegura que el \'ultimo caracter
en el stream es un espacio; si el \'ultimo caracter no es un espacio, agrega uno. 

%\paragraph{About Concatenation.}
\paragraph{Sobre la Concatenaci\'on.}
%Using \mthind{WriteStream}{nextPut:} and \mthind{WriteStream}{nextPutAll:} on a \ct{WriteStream} is often the best way to
%concatenate characters. Using the comma concatenation operator (\ct{,}) is far
%less efficient:
%\index{Collection!comma operator}
Usar \mthind{WriteStream}{nextPut:} y \mthind{WriteStream}{nextPutAll:} en un \ct{WriteStream} es a menudo la mejora forma de concatenar caracteres. Usar el operador de concatenaci\'on por comas (\ct{,}) es mucho menos eficiente. 

\begin{code}{}
[| temp |
  temp := String new.
  (1 to: 100000)
    do: [:i | temp := temp, i asString, ' ']] timeToRun --> 115176 "(milliseconds)"

[| temp |
  temp := WriteStream on: String new.
  (1 to: 100000)
    do: [:i | temp nextPutAll: i asString; space].
  temp contents] timeToRun --> 1262 "(milliseconds)"
\end{code}

The reason that using a stream can be much more efficient is that 
comma creates a new string containing
the concatenation of the receiver and the argument, so it must copy both of them.
When you repeatedly concatenate onto the same receiver, it gets longer and longer each time,
so that the number of characters that must be copied goes up exponentially.
This also creates a lot of garbage, which must be collected. Using
a stream instead of string concatenation is a well-known optimization.
\lr{About Concatenation. This is not true for real world examples (the example benchmark is unrealistic). Most of the time concatenation is simpler, cleaner and much faster, for example when being used on a small number of longer strings. (p. 257)}
In fact, you can use \mthind{SequenceableCollection class}{streamContents:} (mentioned on page \pageref{sec:streamContents}) to help you do this:

\begin{code}{}
String streamContents: [ :tempStream |
  (1 to: 100000)
       do: [:i | tempStream nextPutAll: i asString; space]] 
\end{code}

%-----------------------------------------------------------------
\subsection{Reading and writing at the same time}

It's possible to use a stream to access a collection for reading and
writing at the same time.
Imagine you want to create an \ct{History} class which will manage
backward and forward buttons in a web browser.
A history would react as in figures from \ref{fig:emptyStream} to
\ref{fig:page4}.

\begin{figure}[!ht]
\centerline{\includegraphics[scale=0.5]{emptyStef}}
\caption{A new history is empty. Nothing is displayed in the web browser.}
\figlabel{emptyStream}
\vspace{.2in}
\end{figure}

\begin{figure}[!ht]
\centerline{\includegraphics[scale=0.5]{page1Stef}}
\caption{The user opens to page 1.}
\figlabel{page1}
\vspace{.2in}
\end{figure}

\begin{figure}[!ht]
\centerline{\includegraphics[scale=0.5]{page2Stef}}
\caption{The user clicks on a link to page 2.}
\figlabel{page2}
\vspace{.2in}
\end{figure}

\begin{figure}[!ht]
\centerline{\includegraphics[scale=0.5]{page3Stef}}
\caption{The user clicks on a link to page 3.}
\figlabel{page3}
\vspace{.2in}
\end{figure}

\begin{figure}[!ht]
\centerline{\includegraphics[scale=0.5]{page2_Stef}}
\caption{The user clicks on the back button. He is now viewing page 2 again.}
\figlabel{page2_}
\vspace{.2in}
\end{figure}

\begin{figure}[!ht]
\centerline{\includegraphics[scale=0.5]{page1_Stef}}
\caption{The user clicks again the back button. Page 1 is now displayed.}
\figlabel{page1_}
\vspace{.2in}
\end{figure}

\begin{figure}[!ht]
\centerline{\includegraphics[scale=0.5]{page4Stef}}
\caption{From page 1, the user clicks on a link to page 4. The history forgets pages 2 and 3.}
\figlabel{page4}
\vspace{.2in}
\end{figure}

This behaviour can be implemented using a \clsind{ReadWriteStream}.

\needlines{6}
\begin{code}{}
Object subclass: #History
  instanceVariableNames: 'stream'
  classVariableNames: ''
  poolDictionaries: ''
  category: 'PBE-Streams'

History>>initialize
    super initialize.
    stream := ReadWriteStream on: Array new.
\end{code}

Nothing really difficult here, we define a new class which contains a
stream. The stream is created during the \ct{initialize} method.

We need methods to go backward and forward:

\begin{code}{}
History>>goBackward
  self canGoBackward ifFalse: [self error: 'Already on the first element'].
  stream skip: -2.
  ^ stream next.

History>>goForward
  self canGoForward ifFalse: [self error: 'Already on the last element'].
  ^ stream next
\end{code}

Until then, the code was pretty straightforward. Now, we have to deal
with the \ct{goTo:} method which should be activated when the user
clicks on a link. A possible solution is:

\begin{code}{}
History>>goTo: aPage
    stream nextPut: aPage.
\end{code}

This version is incomplete however. This is because when the user
clicks on the link, there should be no more future pages to go to,
\ie the forward button must be deactivated. To do this, the simplest
solution is to write \ct{nil} just after to indicate the history end:

\begin{code}{}
History>>goTo: anObject
  stream nextPut: anObject.
  stream nextPut: nil.
  stream back.
\end{code}

Now, only methods \ct{canGoBackward} and \ct{canGoForward} have to be
implemented.

A stream is always positioned between two elements. To go backward,
there must be two pages before the current position: one page is the
current page, and the other one is the page we want to go to.

\begin{code}{}
History>>canGoBackward
  ^ stream position > 1

History>>canGoForward
  ^ stream atEnd not and: [stream peek notNil]
\end{code}

Let us add a method to peek at the contents of the stream:
\begin{code}{}
History>>contents
  ^ stream contents
\end{code}

And the history works as advertised:
\begin{code}{}
History new
	goTo: #page1;
	goTo: #page2;
	goTo: #page3;
	goBackward;
	goBackward;
	goTo: #page4;
	contents --> #(#page1 #page4 nil nil)
\end{code}

%=============================================================
\section{Using streams for file access}

You have already seen how to stream over collections of elements. It's
also possible to stream over files on your hard disk.
Once created, a stream on a file is really like a stream on a
collection: you will be able to use the same protocol to read, write
or position the stream.
The main difference appears in the creation of the stream.
There are several different ways to create file streams, as we shall now see.

%-----------------------------------------------------------------
\subsection{Creating file streams}
\seclabel{creat-file-stre}

To create file streams, you will have to use one of the following
instance creation methods offered by the class \clsindmain{FileStream}:

\begin{description}

\item[\lct{fileNamed:}] Open a file with the given name for reading and
  writing. If the file already exists, its prior contents may be
  modified or replaced, but the file will not be truncated on
  close. If the name has no directory part, then the file will be
  created in the default directory.
  \cmindex{FileStream class}{fileNamed:}
  
\item[\lct{newFileNamed:}] Create a new file with the given name,
  and answer a stream opened for writing on that file. If the file
  already exists, ask the user what to do.
  \cmindex{FileStream class}{newFileNamed:}
  
\item[\lct{forceNewFileNamed:}] Create a new file with the given
  name, and answer a stream opened for writing on that file. If the
  file already exists, delete it without asking before creating the
  new file.
  \cmindex{FileStream class}{forceNewFileNamed:}

\item[\lct{oldFileNamed:}] Open an existing file with the given
  name for reading and writing. If the file already exists, its prior
  contents may be modified or replaced, but the file will not be
  truncated on close. If the name has no directory part, then the file
  will be created in the default directory.
  \cmindex{FileStream class}{oldFileNamed:}

\item[\lct{readOnlyFileNamed:}] Open an existing file with the
  given name for reading.
  \cmindex{FileStream class}{readOnlyFileNamed:}

\end{description}

You have to remember that each time you open a stream on a file, you
have to close it too. This is done through the \mthind{FileStream}{close} method.

\begin{code}{@TEST |stream|}
stream := FileStream forceNewFileNamed: 'test.txt'.
stream
    nextPutAll: 'This text is written in a file named ';
    print: stream localName.
stream close.

stream := FileStream readOnlyFileNamed: 'test.txt'.
stream contents. --> 'This text is written in a file named ''test.txt'''
stream close.
\end{code}

% \on{need way to clean up test files afterwards}

%[:fileName | (FileDirectory forFileName: fileName)
%	deleteFileNamed: fileName
%	ifAbsent: [ 'Could not delete ', fileName ] ]
%	value: 'test.txt'

The method \mthind{FileStream}{localName} answers the last component of the name of the file. You can
also access the full path name using the method
\mthind{StandardFileStream}{fullName}.

You will soon notice that manually closing the file stream is
painful and error-prone. That's why \ct{FileStream} offers a message called \mthind{FileStream class}{forceNewFileNamed:do:} to
automatically close a new stream after evaluating a block that
sets its contents.

\begin{code}{@TEST |string|}
FileStream
    forceNewFileNamed: 'test.txt'
    do: [:stream |
        stream
            nextPutAll: 'This text is written in a file named ';
            print: stream localName].
string := FileStream
            readOnlyFileNamed: 'test.txt'
            do: [:stream | stream contents].
string --> 'This text is written in a file named ''test.txt'''
\end{code}

The stream-creation methods that take a block as an argument first
create a stream on a file, then execute the block with the stream
as an argument, and finally close the stream. These methods return what
is returned by the block, which is to say, the value of the last
expression in the block. This is used in the previous example to get
the content of the file and put it in the variable \ct{string}.

%-----------------------------------------------------------------
\subsection{Binary streams}
\seclabel{binary-streams}

By default, created streams are text-based which means you will read
and write characters. If your stream must be binary, you have to send
the message \mthind{FileStream}{binary} to your stream.

When your stream is in binary mode, you can only write numbers from 0
to 255 (1 Byte). If you want to use \ct{nextPutAll:} to write more
than one number at a time, you have to pass a \clsind{ByteArray} as
argument.

\begin{code}{@TEST}
FileStream
  forceNewFileNamed: 'test.bin'
  do: [:stream |
          stream
            binary;
            nextPutAll: #(145 250 139 98) asByteArray].

FileStream
  readOnlyFileNamed: 'test.bin'
  do: [:stream |
          stream binary.
          stream size.         --> 4
          stream next.         --> 145
          stream upToEnd. --> #[250 139 98]
      ].
\end{code}

Here is another example which creates a picture in a file named
``test.pgm'' (portable graymap file format). You can open this file with your favorite drawing program.

% The following does not assert anything, but @TEST is used to ensure
% that no error is thrown.
\begin{code}{@TEST}
FileStream
  forceNewFileNamed: 'test.pgm' 
  do: [:stream |
	stream
		nextPutAll: 'P5'; cr;
		nextPutAll: '4 4'; cr;
		nextPutAll: '255'; cr;
		binary;
		nextPutAll: #(255 0 255 0) asByteArray;
		nextPutAll: #(0 255 0 255) asByteArray;
		nextPutAll: #(255 0 255 0) asByteArray;
		nextPutAll: #(0 255 0 255) asByteArray
	]
\end{code}

This creates a 4x4 checkerboard as shown in \figref{checkerboard4x4}.

\begin{figure}[!ht]
\centerline{\includegraphics[width=0.25\textwidth]{checkerboard4x4}}
\caption{A 4x4 checkerboard you can draw using binary streams.}
\figlabel{checkerboard4x4}
\vspace{.2in}
\end{figure}

%=============================================================
%\section{Chapter summary}

Streams offer a better way than collections to incrementally read and write a sequence of elements. There are easy ways to convert back and forth between streams and collections.

\begin{itemize}
  \item Streams may be either readable, writeable or both readable and writeable.
  \item To convert a collection to a stream, define a stream ``on'' a collection, \eg \ct{ReadStream on: (1 to: 1000)}, or send the messages \ct{readStream}, \etc to the collection.
  \item To convert a stream to a collection, send the message \ct{contents}.
  \item To concatenate large collections, instead of using the comma operator, it is more efficient to create a stream, append the collections to the stream with \ct{nextPutAll:}, and extract the result by sending \ct{contents}.
  \item File streams are by default character-based. Send \ct{binary} to explicitly make them binary.
\end{itemize}

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%-----------------------------------------------------------------

%%% Local Variables: 
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:
