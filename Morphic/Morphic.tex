% $Author$
% $Date$
% $Revision$

% HISTORY:
% 2006-11-19 - Stef added French version of Hilaire's morphic article
% 2006-12-10 - Pollet translating
% 2007-08-16 - Oscar edit
% 2007-11-05 - Andrew edit
% 2009-07-07 - Oscar migrate to Pharo
% 2011 - NicoPaez translation to Spanish

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
\renewcommand\yellowbox[1]{\relax}
\renewcommand\nnbb[2]{\relax} 

%=================================================================
\chapter{Morphic}

%\sd{We should first give a conceptual overview.
%Then we need a cookbook of how to do simple things in Morphic.
%The observer pattern and its implementation with changed:  and update: messages could go here.  Or in ``Idiomatic design patterns'' later.}

\indmain{Morphic} es el nombre de la interface gr\'afica de \pharo.
Morphic est\'a escrito en \st, por lo que es complementamente portable entre distintos sistemas operativos; como consecuencia de ello, \pharo se ve exactamente igual en Unix, MacOS y Windows.
Lo que distingue a Morphic de la mayoria de los otros toolkits de interface de usuario es que no tiene modos separados para  ``composici\'on' y ``ejecuci\'on'' de la interface: todos los elementos gráficos pueden ser ensamblados y desensamblados por el usuario en cualquier momento.\footnote{Le agradecemos a Hilaire Fernandes por permitir basar este cap\'itulo en su art\'iculo original en franc\'es.}

\ab{After the first printing, I took an editing pass, correcting some errors and grammatical infelicities.}

\on{I have commented out the LabelstickerMorph and PyramidMorph examples, as they do not really add much over the other examples we have already. The source code is now available in the example subdirectory, in case someone would like to try and use them after all.}

%=================================================================
\section{La historia de Morphic}

Morphic fue desarrollado por John Maloney and Randy Smith para el lenguaje de programaci\'on \ind{Self} , all\'a por 1993. 
Posteriormente Maloney escribi\'o una nueva versi\'on de Morphic para \squeak, pero las ideas b\'asicas detras de la versi\'on de Self son a\'un vigentes en el Morphic de \pharo: \emph{directness} and \emph{liveness}.\nicopaez{alguna idea de como traducir estos términos?}
Directness significa que las formas en la pantalla son objetos que pueden ser examinados o modificados directamente apuntandolos con el mouse.
Liveness significa que la interface de usuario siempre es capaz de responder a las acciones del usuario: la informaci\'on en la pantalla es continuamente actualizada a medida que cambia el mundo que esta describe.
Un simple ejemplo de esto es que uno puede desacoplar un ítem de men\'u item y mantenerlo como un bot\'on.

\dothis{Abre el men\'u World. \Metaclick para traer su halo morphic\footnote{Recuerda que debes setear \button{halosEnabled} en el explorador de Preferencias. Alternativamente, puedes evaluar \ct{Preferences enable: \#halosEnabled} en un workspace.}, luego \metaclick otra vez el el \'item de men\'u que deseas desacoplar para traer su halo.  Ahora arrastra el \'item a alg\'un otro lugar de la pantalla agarr\'andolo del manejador negro \grabHandle, como se muestra en \figref{detachingMenu}.}
\index{Morphic!halo}
\index{blue button}

\begin{figure}[ht]
	\centerline{\includegraphics[width=0.3\textwidth]{detachingMenu}}
	\caption{Desacoplando un morph, aqu\'i el \'item de men\'u \menu{Workspace}, para hacerlo un bot\'on independiente.
		\figlabel{detachingMenu}}
\end{figure}

Todos los objetos que ves en la pantalla cuando ejecutas \pharo son \emph{Morphs}, eso es, son instancias de subclases de la clase \ct{Morph}.
\mbox{\ct{Morph}} en si mismo es una clase grande con muchos m\'etodos; esto hace posible para las subclases implementar comportamiento interesante con poco c\'odigo.
Tu puedes crear un morph para representar cualquier objeto, aunque cuan buena sea esa representanci\'on, depende del objeto!

\dothis{Para crear un morph que represente a un objeto cadena de caracteres, ejecuta el siguiente c\'odigo en un workspace.} % , una l\'inea a la vez.}
\begin{code}{}
'Morph' asMorph openInWorld
\end{code}
\cmindex{Morph}{openInWorld}

%\begin{code}{}
%s := 'Morph' asMorph openInWorld.
%s openViewerForArgument
%\end{code}
%\cmindex{Morph}{openInWorld}
% ON: openViewerForArgument is gone in pharo!

Esto crea un Morph para representar la cadena de caracteres \ct{'Morph'}, y luego lo abre (esto es, lo muestra) en el ``mundo'', que es el nombre que \pharo le da a la pantalla.
Deberias obtener un elemento gráfico\,---\,un Morph\,---\,al que podrias manipular con \metaclick.
%The second line opens a ``viewer'' that shows you attributes of this Morph, such as its \ct{x} and \ct{y}  coordinates on the screen.  Clicking on one of the yellow exclamation marks sends a message to the Morph, which responds appropriately.

Por supuesto, que es posible definir morphs que sean representaciones gr\'aficas  m\'as interesantes que la que hemos visto.
El m\'etodo \mthind{Object}{asMorph} tiene una implementaci\'on por defecto en la clase  \ct{Object} que simplemente crea un StringMorph.
Entonces, por ejemplo, \ct{Color tan asMorph} devuelve un StringMorph etiquetado con el resultado de \clsind{Color} \ct{tan printString}.
Cambiemos esto para obtener un rect\'angulo coloreado en su lugar.


\dothis{Abre un browser en la clase \ct{Color} y agrega el siguiente m\'etodo:}
\needlines{3}
\begin{method}{Getting a morph for an instance of \ct{Color}.}
Color>>>asMorph
	^ Morph new color: self
\end{method}
\noindent
Ahora ejecuta \ct{Color orange asMorph} \mthind{Morph}{openInWorld} en un workspace. En lugar de morph tipo string, obtienes ¡un rect\'angulo naranja!



%=================================================================
\section{Manipulando morphs}

Los morphs son objetos, por lo tanto podemos manipularlos como cualquier otro objeto en \st: envi\'andoles mensajes, podemos cambiar sus propiedades, crear nuevas subclases de Morph y demás.

Cada morph, incluso si no est\'a actualmente abierto en la pantalla, tiene una posición y un tama\~no.
Para conveniencia, todo morph es considerado ocupando un regi\'on rectangular de la pantalla; si son de forma irregular, su posici\'on y tama\~no son aquellos de la ``caja'' rectangular de menor tama\~no que los rodea, que es conocida como caja de delimitaci\'on del morph, o simplemente su ``delimitador''.


El método \mthind{Morph}{position} devuelve un \ct{Point} que describe la ubicaci\'on de la esquina superior izquierda del morph  (o la esquina superior izquierda de su caja delimitadora).
El origen del sistema de coordenadas es la esquina superior izquierda de la pantalla, con la coordenada $y$  increment\'andose hacia abajo en la pantalla y con las coordenada $x$ increment\'andose hacia la derecha.

El m\'etodo \ct{extent} tambi\'en devuelve un punto, pero este punto especifica el ancho y alto del morph en vez de su posici\'on.


\dothis{Tipea lo siguiente en un workspace y \menu{do it}:}
\begin{code}{}
joe := Morph new color: Color blue.
joe openInWorld.
bill := Morph new color: Color red .
bill openInWorld.
\end{code}
\noindent
Luego tipea \ct{joe position} y \menu{print it}.
Para mover joe, ejecuta \ct{joe position: (joe position + (10@3))} repetidamente.

Es posible hacer algo similar con el tama\~no.

\ct{joe} \mthind{Morph}{extent} devuelve el tamanio de joe; para agrandar a joe, ejecuta \ct{joe extent: (joe extent * 1.1)}.
Para cambiar el color de un morph, env\'iale el mensaje \mthind{Morph}{color:} con el objecto \ct{Color} deseado como argumento, por ejemplo, \ct{joe color: Color orange}.
Para agregar transparencia, prueba \ct{joe color: (Color orange alpha: 0.5)}.

\dothis{Para hacer que bill siga a joe, puedes ejecutar repetidamente este c\'odigo:}
\begin{code}{}
bill position: (joe position + (100@0))
\end{code}
\noindent
Si mueves a joe usando el rat\'on y luego ejecutas este c\'odigo, bill se mover\'a de manera de colocarse a 100 pixels a la derecha de joe.
\ab{Para ser un buen lugar para presentar el m\'etodo \ct{step}}.

%=================================================================
\section{Componiendo morphs}

Una forma de crear nuevas representaciones gr\'aficas es colocando un morph dentro de otro.
Esto es llamado \emph{composici\'on}; los morphs pueden ser compuesto en cualquier nivel de profundidad.
%
%Para crear nuevos morphs, hay dos t\'ecnicas principales que tu puedes combinar:
%\begin{enumerate}
%	\item combinar morphs uno dentro de otro,
%	\item subclasear \ct{Morph} y sobreescribir \mthind{Morph}{drawOn:} para dibuhar formas morphs originales.
%\end{enumerate}
%}
\index{Morph!composing}
Puedes colocar un morph dentro de otro enviando en mensaje \mthind{Morph}{addMorph:} al morph contenedor.

\dothis{Prueba agregar un morph dentro de otro:}
\begin{code}{}
star := StarMorph new color: Color yellow.
joe addMorph: star.
star position: joe position.
\end{code}

\noindent
La \'ultima l\'inea posiciona la estrella en las mismas coordenadas que joe.
Nota que las coorodenadas del morph contenido son a\'un relativas a la pantalla, no al morph contenedor.

Hay muchos m\'etodos disponibles para posicionar un morph, navega el protocolo \protind{geometry} de la clase \ct{Morph} para verlos por ti mismo.
Por ejemplo,
para centrar la estrella dentro de joe, ejecuta \ct{star} \mthind{Morph}{center:} \ct{joe center}.

\begin{figure}[ht]
	\centerline{\includegraphics{joeStar}}
	\caption{La estrella es contenida dentro de joe, el morph azul transl\'ucido.
		\figlabel{joeStar}}
\end{figure}

Si ahora intentas agarrar la estrella con el rat\'on, encontrar\'as que en realidad agarras a joe, y los dos morphs se mueven juntos: la estrella est\'a \emph{embebida} en joe.
Es posible embeber m\'as morphs dentro de joe.
Adem\'as de poder hacer esto program\'aticamente, tambi\'en puedes embeber morphs manipulandolos directamente.

%=================================================================
\section{Creando y dibujando tus propios morphs}

Mientras que es posible hacer muchas representaciones gr\'aficas \'utilies e interesantes componiendo morphs, en ocasiones necesitar\'as crear algo completamente diferente.
\index{Morph!subclassing}
Para hacer esto define una subclase de \ct{Morph} y sobreescribe el m\'etodo \mthind{Morph}{drawOn:} para cambiar su apariencia.

El framework morphic envia el mensaje \ct{drawOn:} a un morph cuando necesita volver a mostrar el morph en la pantalla. El par\'ametro pasado a \ct{drawOn:} es de tipo \clsind{Canvas}; el comportamiento esperado es que el morph se dibuje en ese canvas, dentro de sus límites.

Usemos este conocimiento para crear un morph con forma de cruz.
\index{Morph!subclassing}

\dothis{Usando el browser, define una nueva clase \clsind{CrossMorph} heredando de \ct{Morph}:}
\begin{classdef}{Definiendo \ct{CrossMorph}}
Morph subclass: #CrossMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-Morphic'
\end{classdef}

Podemos definir el m\'etodo \ct{drawOn:} de esta forma:
\begin{method}[firstDrawOn]{Dibujando un \ct{CrossMorph}.}
drawOn: aCanvas 
	| crossHeight crossWidth horizontalBar verticalBar |
	crossHeight := self height / 3.0 .
	crossWidth := self width / 3.0 .
	horizontalBar := self bounds insetBy: 0 @ crossHeight.
	verticalBar := self bounds insetBy: crossWidth @ 0.
	aCanvas fillRectangle: horizontalBar color: self color.
	aCanvas fillRectangle: verticalBar color: self color
\end{method}


\begin{figure}[hbt]
	\ifluluelse
		{\centerline{\includegraphics[width=0.3\textwidth]{NewCross}}}
		{\centerline{\includegraphics{NewCross}}}
	\caption{Un \ct{CrossMorph} con su halo; puedes cambiarle el tama\~no a tu gusto.
		\figlabel{cross}}
\end{figure}


Enviando el mensaje \mthind{Morph}{bounds} a un morph, este contesta su caja delimitadora, que es una instancia de \clsind{Rectangle}.  Los rect\'angulos entiende muchos mensajes que crean otros rect\'angulos de geometria relacionada; aqui usamos el mensaje \ct{insetBy:} con un punto como argumento para crear primero un  rect\'angulo con altura reducida, y luego otro con archo reducido.

\dothis{Para probar tu nuevo morph, ejecuta \ct{CrossMorph new} \mthind{Morph}{openInWorld}.}
El resultado deber\'ia verse similar a la \figref{cross}.
De todas formas, notar\'as que la zona sentiva\,---\,donde puedes hacer click para agarrar el morph\,---\,es a\'un la caja delimitadora completa.  Arreglemos esto.

Cuando el framework Morphic necesita encontrar qu\'e morphs estan bajo el cursor, env\'ia el mensaje \ct{containsPoint:} a todos los morphs cuyas cajas delimitadoras se encuentran bajo el puntero del rat\'on.
Entonces, para limitar la zona sensitiva del morph a la forma de la cruz, necesitamos sobreescribir el m\'etodo \ct{containsPoint:}.

\dothis{Define el siguiente m\'etodo en la clase \ct{CrossMorph}:}

\needlines{4}
\begin{method}[firstContains]{Ajustando la zona sensitiva de \ct{CrossMorph}.}
containsPoint: aPoint
	| crossHeight crossWidth horizontalBar verticalBar |
	crossHeight := self height / 3.0.
	crossWidth := self width / 3.0.
	horizontalBar := self bounds insetBy: 0 @ crossHeight.
	verticalBar := self bounds insetBy: crossWidth @ 0.
	^ (horizontalBar containsPoint: aPoint)
		or: [verticalBar containsPoint: aPoint]
\end{method}

Este m\'etodo usa la misma l\'ogica que \ct{drawOn:}, entonces podemos estar seguros que los puntos para los cuales  \ct{containsPoint:} contesta \ct{true} son los mismos que ser\'an coloreados por \ct{drawOn}.
Nota como aprovechamos el m\'etodo \mthind{Rectangle}{containsPoint:} en la clase \ct{Rectangle} para hacer el trabajo dif\'icil.

Hay dos problemas con el c\'odigo en los m\'etodos \ref{mth:firstDrawOn} y \ref{mth:firstContains}.
El m\'as obvio es que hemos duplicado c\'odigo.
Este es un error cardinal: si encontramos que necesitamos cambiar la forma en que \ct{horizonatalBar} o \ct{verticalBar} son calculadas, podriamos olvidarnos de cambiar una de las dos ocurrencias.
La solución es factorizar estos c\'alculos en dos nuevos m\'etodos, que pondremos en el protocolo  \ct{private}:

\needlines{4}
\begin{method}{\ct{horizontalBar}.}
horizontalBar
	| crossHeight |
	crossHeight := self height / 3.0.
	^ self bounds insetBy: 0 @ crossHeight
\end{method}

\needlines{4}
\begin{method}{\ct{verticalBar}.}
verticalBar
	| crossWidth |
	crossWidth := self width / 3.0.
	^ self bounds insetBy: crossWidth @ 0
\end{method}

\noindent
Podemos entonces definir ambos \ct{drawOn:} y \ct{containsPoint:} usando estos m\'etodos:

\needlines{4}
\begin{method}{Refactored \ct{CrossMorph>>>drawOn:}.}
drawOn: aCanvas 
	aCanvas fillRectangle: self horizontalBar color: self color.
	aCanvas fillRectangle: self verticalBar color: self color
\end{method}
r
\needlines{4}
\begin{method}{Refactored \ct{CrossMorph>>>containsPoint:}.}
containsPoint: aPoint 
	^ (self horizontalBar containsPoint: aPoint)
		or: [self verticalBar containsPoint: aPoint]
\end{method}

Este c\'odigo es mucho m\'as simple de entender, en gran medida porque hemos dado nombres con significado a los m\'etodos privados.
De hecho, es tanto m\'as simple que puedes haber notado el segundo problema: el \'area en el centro de la cruz, que est\'a bajo la barra horizontal y la barra vertical, es dibujada dos veces.
Esto no importa cuando llenamos la cruz con un color opaco, pero el defecto se vuelve evidente inmediatable si dibujamos una cruz semitransparente, como se muestra en la \figref{overdrawBug}.

\begin{figure}[t]
\begin{minipage}{0.48\textwidth}
	\ifluluelse
		{\centerline{\includegraphics[scale=0.6]{overdrawBug}}}
		{\centerline{\includegraphics{overdrawBug}}}
	\caption{El centro de la cruz es llenado dos veces con el color.
		\figlabel{overdrawBug}}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
	\ifluluelse
		{\centerline{\includegraphics[scale=0.6]{hairlineBug}}}
		{\centerline{\includegraphics{bug}}}
	\caption{El morph con forma de cruz, mostrando una fila de pixeles sin llenar.
		\figlabel{bug}}
\end{minipage}
\end{figure}

\needlines{4}
\dothis{Ejecuta el siguiente c\'odigo en un workspace, l\'inea por l\'inea:}

\begin{code}{}
m := CrossMorph new bounds: (0@0 corner: 300@300).
m openInWorld.
m color: (Color blue alpha: 0.3).
\end{code}

\noindent
La soluci\'on a esto es dividir la barra vertical en 3 partes, y llenar solo la parte superior y la inferior.
Una vez m\'as encontramos un m\'etodo en la clase \ct{Rectangle} que hace el trabajo dif\'icil por nosotros: \ct{r1 areasOutside: r2} devuelve un arreglo de rect\'angulos con las partes de \ct{r1} fuera de \ct{r2}. 
Aqu\'i est\'a el c\'odigo revisado:

\begin{method}{El m\'etodo revisado \ct{drawOn:}, que llena el centro de la una vez.}
drawOn: aCanvas 
	| topAndBottom |
	aCanvas fillRectangle: self horizontalBar color: self color.
	topAndBottom := self verticalBar areasOutside: self horizontalBar. 
	topAndBottom do: [ :each | aCanvas fillRectangle: each color: self color]
\end{method}

Este c\'odigo parece funcionar, pero si lo pruebas con algunas cruces y le cambias el tama\~no, notar\'as que en ciertos tama\~nos, una l\'inea de un pixel separa la parte inferior de la cruz, del resto, como se muestra en \figref{bug}.
Esto es debido al redondeo: cuando el tama\~no del rect\'angulo a ser llenado no es un entero, \ct{fillRectangle: color:} parece redondear consistentemente, dejando una fila de pixeles sin llenar.
Podemos trabajar sobre esto redondeando expl\'icitamente cuando calculamos los taman\~os de las barras.

\needlines{5}
\begin{method}{\ct{CrossMorph>>>horizontalBar} con redondeo expl\'icito.}
horizontalBar
	| crossHeight |
	crossHeight := (self height / 3.0) rounded.
	^ self bounds insetBy: 0 @ crossHeight
\end{method}

\needlines{5}
\begin{method}{\ct{CrossMorph>>>verticalBar} con redondeo expl\'icito.}
verticalBar
	| crossWidth |
	crossWidth := (self width / 3.0) rounded.
	^ self bounds insetBy: crossWidth @ 0
\end{method}



%=================================================================
%\section{Composing Morphs}

%\on{The source code is in the examples directory.
%For the moment I prefer to leave out the examples, as they do not add much.}

%Below, we present a few morphs that were designed for a course project.

%\paragraph{An adhesive Label} The \ct{LabelStickerMorph} is a metaphor for an adhesive label with a colored border and three lines of text (\figref{labeler}, \egref{labeler}).

%\begin{figure}[ht]
%	\centerline{\includegraphics[width=0.25\textwidth]{labeler}}
%	\caption{The sticker label morph.
%		\figlabel{labeler}}
%\end{figure}

%\begin{example}[labeler]{Creating a sticker label}{}
%label := LabelstickerMorph new openInWorld.
%label text1: 'Confiture sans sucre';
%	text2: 'Fraises du jardin';
%	text3: '9 mai 2006'.
%label lineColor: Color blue
%\end{example}

%\paragraph{A Number Pyramid}
%The previous morph is designed by overriding the \ct{drawOn:} method.
%We built \ct{PyramidMorph} by composing morphs: we used \ct{TextMorph}s to make the blocks and added them to a base morph (\figref{pyramid}, \egref{pyramid}). \damien{figure does not match text... no numbers? Where is the code?}
%\begin{figure}[ht]
%	\centerline{\includegraphics{pyramid}}
%	\caption{The number pyramid morph.
%		\figlabel{pyramid}}
%\end{figure}

%\begin{example}[pyramid]{Manipulating the number pyramid}{}
%pyramid := (PyramidMorph base: 4) openInWorld.
%pyramid block: 8 value: 2
%\end{example}


%=================================================================
\section{Interacci\'on y animaci\'on }

Para construir interfaces de usuario vivas usando morphs, necesitamos poder interactuar con ellos usando el rat\'on y el teclado. 
Más aún, los morphs necesitan ser capaces de responder a la entrada del usuario cambiando su apariencia y posici\'on\,---\,esto es, anim\'andose asimismos.


\subsection{Eventos del rat\'on}

Cuando un bot\'on del rat\'on es presionado, Morphic env\'ia el mensaje \mthind{Morph}{mouseDown:} a cada morph ubicado bajo el puntero del rat\'on y también envia el mensaje \mthind{Morph}{mouseUp:} cuando el usuario libera el bot\'on del rat\'on.
Si todos los morphs contestan \ct{false}, entonces Morphic inicia una operaci\'on drap-and-drop.
Como discutiremos m\'as abajo, los mensajes \ct{mouseDown:} y \ct{mouseUp:} son enviados con el argumento\,---\,a \clsind{MouseEvent} \,---\,que codifica los detalles de la acci\'on del rat\'on.

Extendamos el \ct{CrossMorph} para manejar eventos del rat\'on, 
Comenzamos por asegurarnos que todos los crossMorphs contestan \ct{true} al mensaje\mthind{Morph}{handlesMouseDown:}. 

\dothis{Agrega este método a \ct{CrossMorph}:}
\begin{method}{Declarando que \ct{CrossMorph} reaccionar\'a clics del rat\'on.}
CrossMorph>>>handlesMouseDown: anEvent
	^true
\end{method}

Supongamos que cuando hacemos clic en la cruz, queremos cambiar el color de la cruz a rojo, y que cuando \actclick en esta, queremos cambiar el color a amarillo.
Esto se puede hacer con \mthref{mouseDown}.

\needlines{7}
\begin{method}[mouseDown]{Reaccionando a clics del rat\'on para cambiar el color del morph.}
CrossMorph>>>mouseDown: anEvent
	anEvent redButtonPressed "click"
		ifTrue: [self color: Color red].
	anEvent yellowButtonPressed "action-click"
		ifTrue: [self color: Color yellow].
	self changed
\end{method}

\ab{I added this note:}
Nota que adicionalmente al cambiar el color de un morph, este m\'etodo tambi\'en envia \ct{self changed}.
Esto asegura que el morphic env\'ia \ct{drawOn:} de manera oportuna.

\ab{De todas formas, el mensaje \ct{self changed} parece ser enteramente innecesario; el color cambia instantaneamente sin este.}
Nota tambi\'en que una vez que el morph maneja los eventos del rat\'on, ya no puedes agarrarlo con el rat\'on y moverlo.
En lugar de ello tienes que utilizar el halo: \metaclick en el morph para hacer aparecer el halo y agarrar el manejador marr\'on \moveHandle{}  o el manejador negro \grabHandle{} en la parte superior del morph,

El argumento \ct{anEvent} de \ct{mouseDown:} es una instancia de \mbox{\clsind{MouseEvent},} que es una subclase de  \lct{Mor\-phic\-Event}. \ct{MouseEvent} define los m\'etodos \mthind{MouseEvent}{redButtonPressed} y \mthind{MouseEvent}{yellowButtonPressed}. Navega esta clase para ver qu\'e otros m\'etodos provee para interrogar los eventos del rat\'on.

\subsection{Eventos del teclado}

Para atrapar \ind{eventos del teclado}, necesitamos hacer tres pasos.
\begin{enumerate}
	\item Dar el ``foco de teclado'' a un morph espec\'ifico: por ejemplo podemos dar el foco a nuestro morph cuando el rat\'on se mueve sobre \'el.
	\item Manejar el evento del teclado con el \mthind{Morph}{handleKeystroke:} method: este mensaje es enviado al morph que tiene el foco de teclado cuando el usuario presiona una tecla.
	\item Liberar el foco de teclado cuando el rat\'on ya no est\'a sobre nuestro morph.
\end{enumerate}

Extendamos el \ct{CrossMorph} para que reaccione a las pulsaciones de teclas.
Primero necesitamos ser notificados cuando el rat\'on est\'a sobre el morph.
Esto suceder\'a si nuestro morph responde \ct{true} al mensaje \mthind{Morph}{handlesMouseOver:}

\dothis{Declara que \ct{CrossMorph} reaccionar\'a cuando este bajo el puntero del rat\'on.}
\begin{method}{Queremos manejar los eventos de ``mouse over''.} 
CrossMorph>>>handlesMouseOver: anEvent
	^true
\end{method}

\noindent
Este mensaje es el equivalente a \mthind{Morph}{handlesMouseDown:} para la posici\'on del rat\'on.
Cuando el puntero del rat\'on entra o sale del morph, los mensajes \mthind{Morph}{mouseEnter:} y \mthind{Morph}{mouseLeave:} son enviados a este.

\dothis{Define dos m\'etodos para que el \ct{CrossMorph} atrape y libere el foco del teclado, y un tercer m\'etodo para manejar las pulsaciones de teclado.}
\begin{method}{Obteniendo el foco de teclado cuando el rat\'on entra al morph.}
CrossMorph>>>mouseEnter: anEvent
	anEvent hand newKeyboardFocus: self
\end{method}

\begin{method}{Devolviendo el foco cuando el puntero se va.}
CrossMorph>>>mouseLeave: anEvent
	anEvent hand newKeyboardFocus: nil
\end{method}

\begin{method}[handleKeystroke]{Recibiendo y manejando eventos de teclado.}
CrossMorph>>>handleKeystroke: anEvent
	| keyValue |
	keyValue := anEvent keyValue.
	keyValue = 30	 "up arrow"
		ifTrue: [self position: self position - (0 @ 1)].
	keyValue = 31	 "down arrow"
		ifTrue: [self position: self position + (0 @ 1)].
	keyValue = 29	 "right arrow"
		ifTrue: [self position: self position + (1 @ 0)].
	keyValue = 28	 "left arrow"
		ifTrue: [self position: self position - (1 @ 0)]
\end{method}

Hemos escrito este m\'etodo  para poder mover el morph usando las teclas de flechas.
Nota que cuando el rat\'on ya no est\'a sobre el morph, el mensaje \mthind{Morph}{handleKeystroke:} no es enviado, por lo que el morph deja de responder a los comandos del teclado.
Para descubrir los valores de las teclas, puedes abrir un Transcript y agregar \glbind{Transcript} \ct{show: anEvent keyValue} al método \mthref{handleKeystroke}. 

El argumento \ct{anEvent} de \ct{handleKeystroke:} es una instancia de \clsind{KeyboardEvent}, otra subclase de \clsind{MorphicEvent}. Navega esta clase para aprender m\'as sobre los eventos de teclado. 

\subsection{Animaciones Morphic}

Morphic provee un sistema simple de animaci\'on con dos m\'etodos: \mthind{Morphic}{step} es enviado a un morph en intervalos regulares de tiempo, mientras que \mthind{Morphic}{stepTime} especifica el tiempo en milisegundos entre \ct{step}s.\footnote{\ct{stepTime} es en realidad el \emph{m\'inimo} tiempo entre \ct{step}s.}

Si preguntas por un \ct{stepTime} de 1\,ms, no te sorprendas si \pharo est\'a muy ocupado para step tu morph tan seguido.

In addition, 
\mthind{Morphic}{startStepping} turns on the stepping mechanism, while \mthind{Morphic}{stopStepping} turns it off again;  \mthind{Morphic}{isStepping} can be used to find out whether a morph is currently being stepped.
\index{Morphic!animation}

\dothis{Make \ct{CrossMorph} blink by defining these methods as follows:}
\begin{method}{Defining the animation time interval.}
CrossMorph>>>stepTime
	^ 100
\end{method}
\begin{method}{Making a step in the animation.}
CrossMorph>>>step
	(self color diff: Color black) < 0.1
		ifTrue: [self color: Color red]
		ifFalse: [self color: self color darker]
\end{method}
\noindent

Para comenzar, puedes abrir un inspector en un \ct{CrossMorph}  (usando el manejador de debug \debugHandle{} en una halo de morphic), tipea \ct{self startStepping} en el peque\~no workspace de abajo, y \menu{do it}.
Alternativamente, puedes modificar el m\'edtodo \ct{handleKeystroke:}  para que puedas usar las teclas $+$ and $-$  para comenzar y deterner el paso a paso.


\dothis{Agregar el siguiente c\'odigo a \mthref{handleKeystroke}:}

\begin{code}{}
	keyValue = $+ asciiValue 
		ifTrue: [self startStepping].
	keyValue = $- asciiValue
		ifTrue: [self stopStepping].
\end{code}

% \on{You can also \menu{debug \go inspect morph} and evaluate: \ct{self currentWorld startStepping: self}.}

%=================================================================
\section{Interactores}

Para pedirle al usuario una entrada, la clase \clsind{UIManager} provee una gran n\'umero de  cajas de di\'alogo listas para usar.
Por ejemplo, el m\'etodo \mthind{UIManager}{request:initialAnswer:} revuelve un cadena ingresada por le usuario (\figref{dialogName}).

\begin{code}{}
UIManager default request: 'What''s your name?' initialAnswer: 'no name'
\end{code}

\begin{figure}[htb]
\begin{minipage}{0.48\textwidth}
	\centerline{\includegraphics[width=0.8\textwidth]{dialog}}
	\caption{Un di\'alogo de entrada.}\figlabel{dialogName}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
	\vfill
	\centerline{\includegraphics [width=0.8\textwidth]{popup}}
	\vfill
	\vspace{4ex}
	\caption{Men\'u emergente.}\figlabel{popup}
\end{minipage}
\end{figure}

Para desplegar un men\'u emergente, usa uno de los varios m\'etodos \ct{chooseFrom:} (\figref{popup}):
\begin{code}{}
UIManager default
	chooseFrom: #('circle' 'oval' 'square' 'rectangle' 'triangle')
	lines: #(2 4) message: 'Choose a shape'
\end{code}

\dothis{Nageva la clase \clsind{UIManager} y prueba algunos de los m\'etodos de interacci\'on ofrecidos.}

%\begin{figure}[ht]
%	\centerline{\includegraphics[width=5cm]{dialog}}
%	\caption{Dialog displayed by \ct{FillInTheBlank request: 'What''s your name?' initialAnswer: 'no name'}.
%		\figlabel{dialogName}}
%\end{figure}

%To display a pop-up menu, use the \clsind{PopupMenu} class:
%\begin{code}{}
%UIManager default chooseFrom: #('circle' 'oval' 'square' 'rectangle' 'triangle') lines: #(2 4) message: 'Choose a shape'
%\end{code}

%\begin{figure}[ht]
%	\centerline{\includegraphics[width=3cm]{popup}}
%	\caption{PopUp displayed by \ct{PopUpMenu>>>startUpWithCaption:}.}
%\end{figure}

%=================================================================
\section{Drag-And-Drop}
Morphic tambi\'en soporta drag-and-drop. Examinemos un simple ejemplo con dos morphs, un morph receptor y un morph arrojado. 
El receptor aceptar\'a un morph solo si el morph arrastrado coincide con una condici\'on dada: en nuestro ejemplo, el morph debe ser azul. Si es rechazado el  morph arrastrado decide que hacer.

\dothis{Primero definamos el morph receptor:}
\begin{classdef}{Definiendo un morph en el que podamos arrastrar otros morphs}
Morph subclass: #ReceiverMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-Morphic'
\end{classdef}

\dothis{Ahora define el m\'etodo de inicializaci\'on de la manera usual:}
\begin{method}{Inicializando \ct{ReceiverMorph}.}
ReceiverMorph>>>initialize
	super initialize.
	color := Color red.
	bounds := 0 @ 0 extent: 200 @ 200
\end{method}

?`Como dedicir si el receptor aceptar\'a o rechazar\'a el morph arrastrado?
En general ambos morphs tendr\'an que acordar en la interacci\'on.

El receptor hace esto respondiendo a \mthind{Morph}{wantsDroppedMorph:event:}; el primer argumento es el morph arrastrado, y el segundo es el evento del rat\'on, de esta forma el receptor puede por ejemplo ver si alguna tecla modificadora fue presionada al momento del arrastre.
El morph arrastrado tambi\'en tiene la oportunidad de chequear y ver si le gusta el morph sobre el que está siendo arrojado; se le env\'ia el mensaje \ct{wantsToBeDroppedInto:}. La implementaci\'on por defecto de este m\'etodo (en la clase \ct{Morph}) responde \ct{true}.

\begin{method}{Aceptar el morph arrojado en base a su color.}
ReceiverMorph>>>wantsDroppedMorph: aMorph event: anEvent
	^ aMorph color = Color blue
\end{method}

Que ocurre con el morph arrojado si el morph receptor no lo quiere? El comportamiento por defecto es no hacer nada, eso es, sentarse encima del  morph receptor, pero sin interactuar con el. Un comportamiento m\'as intuitivo es que el morph arrojado vuelva a su posici\'on original. Esto puede lograrse en el receptor, contestando \ct{true}  al mensaje \mthind{Morph}{repelsMorph:event:} cuando no quiere al morph arrojado:


\needlines{4}
\begin{method}{Changing the behaviour of the dropped morph when it is rejected.}
ReceiverMorph>>>repelsMorph: aMorph event: ev
	^ (self wantsDroppedMorph: aMorph event: ev) not
\end{method}

Eso es todo lo que necesitamos en lo que respecta al receptor.

\dothis{Crea instancias de \clsind{ReceiverMorph} y \clsind{EllipseMorph} en un workspace:}
\begin{code}{}
ReceiverMorph new openInWorld.
EllipseMorph new openInWorld.
\end{code}
\noindent
Intenta hacer drag-and-drop  el \ct{EllipseMorph}  amarillo sobre el receptor. Este ser\'a rechazado y enviado de vuelta a su posici\'on original.

\dothis{Para cambiar este comportamiento, cambia el color de la morph elipse a \ct{Color blue} usando un inspector. Los morphs azules deben ser aceptado por el \ct{ReceiverMorph}.}


Creemos una subclase de \ct{Morph}, llamada \ct{DroppedMorph}, para que podamos experimentar un poco m\'as:

\begin{classdef}{Definiendo un morph que podamos arrastrar y soltar sobre el \ct{ReceiverMorph}}
Morph subclass: #DroppedMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-Morphic'
\end{classdef}

\needlines{5}
\begin{method}{Inicializando \ct{DroppedMorph}.}
DroppedMorph>>>initialize
	super initialize.
	color := Color blue.
	self position: 250@100
\end{method}

Ahora podemos especificar qu\'e debe hacer el morph arrastrado cuando es rechazado por el receptor; aqui este permanecer\'a adjunto al puntero del rat\'on:

\begin{method}{Reaccionando cuando el morph fue arrojado pero rechazado.}
DroppedMorph>>>rejectDropMorphEvent: anEvent
	| h |
	h := anEvent hand.
	WorldState
		addDeferredUIMessage: [h grabMorph: self].
	anEvent wasHandled: true
\end{method}

Enviar el mensaje \mthind{MorphicEvent}{hand} a un evento, responde una \emph{hand}, que es una instancia de \ct{HandMorph} que representa el puntero del rat\'on y lo que sea que sostenga.

Aqui le decimos al \ct{World} que la mano debe agarrar \ct{self}, el morph rechazado.

\dothis{Crea dos intancias de \ct{DroppedMorph}, y luego drag-and-drop sobre el receptor.}
\begin{code}{}
ReceiverMorph new openInWorld.
(DroppedMorph new color: Color blue) openInWorld.
(DroppedMorph new color: Color green) openInWorld.
\end{code}
\noindent
El morph verde es rechazado y por lo tanto se mantiene adjunto al puntero del rat\'on.

%=================================================================
\section{Un ejmeplo completo}

Dese\~nemos un morph para tirar un dado. Haciendo clic en el, se mostrar\'an los valores de todas sus caras en un ciclo, y otro clic detendr\'a la animaci\'on.

\begin{figure}[ht]
	\centerline{\includegraphics[scale=0.65]{die}}
	\caption{El dado en Morphic.
		\figlabel{dialogDie}}
\end{figure}

\dothis{Define un dado como una subclase de \clsind{BorderedMorph} en lugar de \ct{Morph}, porque haremos uso del borde.}

\needlines{6}
\begin{classdef}{Definiendo un dado morph}
BorderedMorph subclass: #DieMorph
	instanceVariableNames: 'faces dieValue isStopped'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-Morphic'
\end{classdef}

La variable de instancia \ct{faces} registra el n\'umero de caras del dado; !`nos permitir\'a dados con hasta 9 caras! \ct{dieValue} registra los valores de la cara que est\'a actualmente mostrada, y \ct{isStopped} es verdadero si la animaci\'on est\'a detenida.

Para crear una instancia de dado, definimos el m\'etodo caras en el lado \emph{class}  de \clsind{DieMorph} para crear un nuevo dado con \ct{n} caras.

\begin{method}{Creado un new dado con el n\'umero de caras que nos gusta.}
DieMorph class>>>faces: aNumber
	^ self new faces: aNumber
\end{method}

El m\'etodo \ct{initialize} est\'a definido en la instancia como de costumbre; recuerda que \ct{new} env\'ia \ct{initialize} a la nueva instancia creada.
\begin{method}{Inicializando instancias de \ct{DieMorph}.}
DieMorph>>>initialize
	super initialize.
	self extent: 50 @ 50.
	self useGradientFill; borderWidth: 2; useRoundedCorners.
	self setBorderStyle: #complexRaised.
	self fillStyle direction: self extent.
	self color: Color green.
	dieValue := 1.
	faces := 6.
	isStopped := false
\end{method}

Usamos unos pocos m\'etodos de \ct{BorderedMorph}  para dar una apariencia agradable al dado: un borde grueso con una efecto elevado, esquinas redondeadas, y un color gradiente en la cara visible.

Definimos el m\'etodo de instancia \ct{faces:} para chequear par\'ametros v\'alidos como sigue:

\begin{method}{Seteando el n\'umero de caras del dado.}
DieMorph>>>faces: aNumber
	"Set the number of faces"
	(aNumber isInteger
			and: [aNumber > 0]
			and: [aNumber <= 9])
		ifTrue: [faces := aNumber]
\end{method}
\on{Why not make this a pre-condition, \ie an assertion?}

Podr\'ia ser bueno reveer el orden en que se envian los mensajes cuando un dado es creado. Por ejemplo, si comenzamos por
evaluar \ct{DieMorph faces: 9}:
\begin{enumerate}
	\item El m\'etodo de clase \ct{DieMorph class>>>faces:} envia \ct{new} a \ct{DieMorph class}.
	\item El m\'etodo para \ct{new} (heredado por \ct{DieMorph class} de \ct{Behavior}) crea la nueva instacia y le env\'ia el mensaje \ct{initialize}.
	\item El m\'etodo  \ct{initialize} en \ct{DieMorph} establece \ct{faces} al valor inicial 6.
	\item \ct{DieMorph class>>>new} retorna el m\'etodo de clase \ct{DieMorph class>>>faces:}, que env\'ia el mensaje \ct{faces: 9} a la nueva instancia.
	\item El m\'etodo de instancia \ct{DieMorph>>>faces:} ahora se ejecuta, estableciendo la variable de instancia \ct{faces} en 9.
\end{enumerate}

Antes de definir \ct{drawOn:}, necesitamos unos pocos m\'etodos para poner los puntos en la cara mostrada:
\begin{methods}{Nueve m\'etodos para ubicar los puntos en las caras del dado.}
DieMorph>>>face1
	^{0.5@0.5}
DieMorph>>>face2
	^{0.25@0.25 . 0.75@0.75}
DieMorph>>>face3
	^{0.25@0.25 . 0.75@0.75 . 0.5@0.5}
DieMorph>>>face4
	^{0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75}
DieMorph>>>face5
	^{0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75 . 0.5@0.5}
DieMorph>>>face6
	^{0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75 . 0.25@0.5 . 0.75@0.5}
DieMorph>>>face7
	^{0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75 . 0.25@0.5 . 0.75@0.5 . 0.5@0.5}
DieMorph >>>face8
	^{0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75 . 0.25@0.5 . 0.75@0.5 . 0.5@0.5 . 0.5@0.25}
DieMorph >>>face9
	^{0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75 . 0.25@0.5 . 0.75@0.5 . 0.5@0.5 . 0.5@0.25 . 0.5@0.75}
\end{methods}
\on{kind of ugly boilerplate code -- should be a nice way to map these more elegantly to coordinates.}

Estos m\'etodos definen colecciones de coordenadas de puntos para cada cara. Las coordenadas estan en un cuadrado de tama\~no $1\times1$; simplemente necesitaremos escalarlas para ubicar los verdaderos puntos.

El m\'etodo \ct{drawOn:} hace dos cosas: dibuja el fondo del dado con \ct{super}-send, y luego dibuja los puntos.
\begin{method}{Dibujando el dado morph.}
DieMorph>>>drawOn: aCanvas
	super drawOn: aCanvas.
	(self perform: ('face' , dieValue asString) asSymbol)
		do: [:aPoint | self drawDotOn: aCanvas at: aPoint]
\end{method}

La segunda parte de este m\'etodo usa las capacidades refletivas de \st.
Dibujar los puntos de una cara es una simple cuesti\'on de iterar sobre la colecci\'on dada por el m\'etodo \ct{faceX} para esa cara, enviando el mensaje \ct{drawDotOn:at:} para cada coordenada. Para llamar al correcto m'etodo \ct{faceX}, usamos el m\'etodo \mthind{Object}{perform:} que envia un mensaje a partir de una cadena, aqu\'i \lct{('face', dieValue asString) asSymbol}. Encotrar\'as este uso de \ct{perform:} bastante seguido.
\index{reflection}
\begin{method}{Dibujando un punto en una cara.}
DieMorph>>>drawDotOn: aCanvas at: aPoint
	aCanvas
		fillOval: (Rectangle
			center: self position + (self extent * aPoint)
			extent: self extent / 6)
		color: Color black
\end{method}
\ew{I would not use reflection to call faceX on p.234. A statically filled Dictionary would be more appropriate. Get the point set with "MyDict at: X".}

Como las coordenadas est\'an normalizadas al intervalo $[0{:}1]$, podemos escalarlas a las dimensiones de nuestro dado: \ct{self extent * aPoint}.

\dothis{Ya podemos crear una instancia de dado desde un workspace:}
\begin{code}{}
(DieMorph faces: 6) openInWorld.
\end{code}

Para cambiar la cara mostrada, creamos un accesor que podemos usar como \ct{myDie dieValue: 4}:
\begin{method}{Estableciendo el valor del dado.}
DieMorph>>>dieValue: aNumber
	(aNumber isInteger
			and: [aNumber > 0]
			and: [aNumber <= faces])
		ifTrue:
			[dieValue := aNumber.
			self changed]
\end{method}

Ahora vamos usar el sistema de animaci\'on para mostrar r\'apidamente todas las caras:
\needlines{3}
\index{Morphic!animation}
\begin{methods}{Animando el dado.}
DieMorph>>>stepTime
	^ 100

DieMorph>>>step
	isStopped ifFalse: [self dieValue: (1 to: faces) atRandom]
\end{methods}
!`Ahora el dado est\'a rodando!

Para comenzar o deterner la animaci\'on haciendo clic, usaremos lo que hemos aprendido previamente sobre los eventos del  rat\'on.
Primero, activamos la recepci\'on de los eventos del rat\'on:

\begin{methods}{Manejando clics del rat\'on para iniciar y detenar la animaci\'on.}
DieMorph>>>handlesMouseDown: anEvent
	^ true

DieMorph>>>mouseDown: anEvent
	anEvent redButtonPressed
		ifTrue: [isStopped := isStopped not]
\end{methods}
Ahora el dado rodar\'a o se detendr\'a hagamos clic en \'el.

% That's all for the essentials of Morphic!

% Most of the work on \ct{DieMorph} was done with an instance of it living in the environment; this is quite nice when to tweak programs.

%=================================================================
\section{M\'as acerca del canvas}

El método \ct{drawOn:} tiene una instancia de \clsindmain{Canvas} como su \'unico argumento;
el canvas es un \'area en donde el morph se dibuja asimismo.
Usando los m\'etodos gr\'aficos del canvas, eres libre de dar la apariencia que quieras a un morph.
Si navegas la jerarqu\'ia de herencia de la clase \ct{Canvas}, ver\'as que tiene varias variantes.

La variante por defecto de \ct{Canvas} es \clsind{FormCanvas}; encontrar\'as los m\'etodos gr\'aficos clave en \ct{Canvas} y \ct{FormCanvas}.
Estos m\'etodos pueden dibujar puntos, l\'ineas, pol\'igonos, rect\'angulos, elipses, textos e im\'agenes con rotaci\'on y escalamiento.

Tambi\'en es posible usar otras clases de canvas, para obtener morphs transparentes, m\'as m\'etodos gr\'aficos, antialising, y otros.

Para usar estas funcionalidades necesitar\'as un \clsind{AlphaBlendingCanvas} o un \clsind{BalloonCanvas}.

Pero, ?`como puedes obtener un canvas as\'i en un m\'etodo \ct{drawOn:} cuando \ct{drawOn:} recibe una instancia de \ct{FormCanvas} como argumento?
Afortunadamente, puedes transformar un tipo de canvas en otro.

\dothis{Para usar un canvas con alpha-transparency 0.5 en \ct{DieMorph}, redefine \ct{drawOn:} de esta forma:}
\needlines{7}
\begin{method}{Dibujando un dado translucido.}
DieMorph>>>drawOn: aCanvas
	| theCanvas |
	theCanvas := aCanvas asAlphaBlendingCanvas: 0.5.
	super drawOn: theCanvas.
	(self perform: ('face' , dieValue asString) asSymbol)
		do: [:aPoint | self drawDotOn: theCanvas at: aPoint]
\end{method}
\noindent
!`Eso es todo lo que necesitas hacer!

\begin{figure}[ht]
	\centerline{\includegraphics[scale=0.7]{multiMorphs}}
	\caption{El dado mostrado con alpha-transparency.
		\figlabel{multiMorphs}}
\end{figure}

% ON: This appears to be broken:

%If you're curious, have a look at the \mthind{Canvas}{asAlphaBlendingCanvas:} method.
%You can also get antialiasing by using \clsind{BalloonCanvas} and transforming the die drawing methods as shown in \mthsref{aadie}.

%\needlines{6}
%\begin{methods}[aadie]{Drawing an antialiased die.}
%DieMorph>>>drawOn: aCanvas
%	| theCanvas |
%	theCanvas := aCanvas asBalloonCanvas aaLevel: 3.
%	super drawOn: aCanvas.
%	(self perform: ('face' , dieValue asString) asSymbol)
%		do: [:aPoint | self drawDotOn: theCanvas at: aPoint]

%DieMorph>>>drawDotOn: aCanvas at: aPoint
%	aCanvas
%		drawOval: (Rectangle
%			center: self position + (self extent * aPoint)
%			extent: self extent / 6)
%		color: Color black
%		borderWidth: 0
%		borderColor: Color transparent
%\end{methods}

%=================================================================
\section{Resumen del cap\'itulo}

Morphic es un marco de trabajo gr\'afico en que los elementos de la interface gr\'afica pueden ser compuestos din\'amicamente.

\begin{itemize}
  \item Puedes convertir un objeto en un morph y mostrarlo en la pantalla envi\'andole los mensajes \ct{asMorph openInWorld}.
  \item Puedes manipular a un morph  \metaclick{ing} sobre el y usando los manejadores que aparecen. (Los manejadores tiene balones de ayuda que explican lo que hacen.)
  \item Puedes componer morphs embebi\'endolos uno dentro de otro, o arrastr\'ando y soltando o enviando el mensaje \ct{addMorph:}.
  \item Puedes subclasear un clase morph existente y redefinir los m\'etodos clave, como \ct{initialize} y \ct{drawOn:}.
  \item Puedes controlar como un morph reacciona a los eventos de rat\'on y teclado redefiniendo los m\'etodos \ct{handlesMouseDown:}, \ct{handlesMouseOver:}, \etc
  \item Puedes animar un morph definiendo los m\'etodos \ct{step} (qu\'e hacer) y \ct{stepTime} (el n\'umero de milisegundos entre pasos)
  \item Varios morphs predefinidos, como \ct{PopUpMenu} y \ct{FillInTheBlank}, est\'an disponibles para interactuar con los usuarios.
\end{itemize}

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%-----------------------------------------------------------------
