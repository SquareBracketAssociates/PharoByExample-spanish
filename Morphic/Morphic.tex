% $Author$
% $Date$
% $Revision$

% HISTORY:
% 2006-11-19 - Stef added French version of Hilaire's morphic article
% 2006-12-10 - Pollet translating
% 2007-08-16 - Oscar edit
% 2007-11-05 - Andrew edit
% 2009-07-07 - Oscar migrate to Pharo

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
\chapter{Morphic}

%\sd{We should first give a conceptual overview.
%Then we need a cookbook of how to do simple things in Morphic.
%The observer pattern and its implementation with changed:  and update: messages could go here.  Or in ``Idiomatic design patterns'' later.}

\indmain{Morphic} es el nombre de la interface gr\'afica de \pharo.
Morphic est\'a escrito es \st, por lo que es complementamente portable entre distintos sistemas operativos; como consecuencia de ello, \pharo se ve exactamente igual en Unix, MacOS y Windows.
Lo que distingue a Morphic de la mayoria de los otros toolkits de interface de usuario es que no tiene modos separados para  ``composici\'on' y ``ejecuci\'on'' de la interface: todos los elementos gr\'aficos pueden ser ensamblados y desensamblados por el usuario en cualquier momento.\footnote{Le agradecemos a Hilaire Fernandes por permitir basar este cap\'itulo en su art\'iculo original en franc\'es.}

\ab{After the first printing, I took an editing pass, correcting some errors and grammatical infelicities.}

\on{I have commented out the LabelstickerMorph and PyramidMorph examples, as they do not really add much over the other examples we have already. The source code is now available in the example subdirectory, in case someone would like to try and use them after all.}

%=================================================================
\section{La historia de Morphic}

Morphic fue desarrollado por John Maloney and Randy Smith para el lenguaje de programaci\'on \ind{Self} , all\'a por 1993. 
Posteriormente Maloney escribi\'o una nueva versi\'on de Morphic para \squeak, pero las ideas b\'asicas detras de la versi\'on de Self son a\'un vigentes en el Morphic de \pharo: \emph{directness} and \emph{liveness}.
Directness significa que las formas en la pantalla son objetos que pueden ser examinados o modificados directamente apuntandolos con el mouse.
Liveness significa que la interface de usuario siempre es capaz de responder a las acciones del usuario: la informaci\'on en la pantalla es continuamente actualizada a medida que cambia el mundo que esta describe.
Un simple ejemplo de esto es que uno puede desatachar un item de men\'u item y mantenerlo como un bot\'on.

\dothis{Abre el men\'u World. \Metaclick para traer su halo morphic\footnote{Recuerdda que debes setear \button{halosEnabled} en el explorador de Preferencias. Alternativamente, puedes evaluar \ct{Preferences enable: \#halosEnabled} en un workspace.}, luego \metaclick otra vez el el \'item de men\'u que deseas desacoplar para traer su halo.  Ahora arrastra el el \'item a alg\'un otro lugar de la pantalla agarr\'andolo del manejador negro \grabHandle, como se muestra en \figref{detachingMenu}.}
\index{Morphic!halo}
\index{blue button}

\begin{figure}[ht]
	\centerline{\includegraphics[width=0.3\textwidth]{detachingMenu}}
	\caption{Desacoplar un morph, aqu\'i el \'item de men\'u \menu{Workspace}, para hacerlo un bot\'on independiente.
		\figlabel{detachingMenu}}
\end{figure}

Todos los objetos que ves en la pantalla cuando ejecutas \pharo son \emph{Morphs}, eso es, son instancias de subclases de la clase \ct{Morph}.
\mbox{\ct{Morph}} en si mismo es una clase grande con mucho m\'etodos; esto hace posible para las subclases implementar comportamiento interesante con poco c\'odigo.
Tu puedes crear un morph para representar cualquier objeto, aunque cuan buena sea esa representanción depende del objeto!

\dothis{Para crear un morph que represente a un objeto cadena de caracteres, ejecuta el siguiente c\'odigo en un workspace.} % , una l\'inea a la vez.}
\begin{code}{}
'Morph' asMorph openInWorld
\end{code}
\cmindex{Morph}{openInWorld}

%\begin{code}{}
%s := 'Morph' asMorph openInWorld.
%s openViewerForArgument
%\end{code}
%\cmindex{Morph}{openInWorld}
% ON: openViewerForArgument is gone in pharo!

Esto crea un Morph para representar la cadena de caracteres \ct{'Morph'}, y luego lo abre (esto es, lo muestra) en el ``mundo'', que es el nombre que \pharo le da a la pantalla.
You should obtain a graphical element\,---\,a Morph\,---\,which you can manipulate by \metaclick{ing}.
%The second line opens a ``viewer'' that shows you attributes of this Morph, such as its \ct{x} and \ct{y}  coordinates on the screen.  Clicking on one of the yellow exclamation marks sends a message to the Morph, which responds appropriately.

Por supuesto, es posible definir morphs que sean representaciones gr\'aficas  m\'as interesante que la que hemos visto.
El m\'etodo \mthind{Object}{asMorph} tiene una implementaci\'on por defecto en la clase  \ct{Object} que simplemente crea un StringMorph.
Entonces, por ejemplo, \ct{Color tan asMorph} devuelve un StringMorph etiquetado con el resultado de \clsind{Color} \ct{tan printString}.
Cambiemos estoy para obtener un rect\'angulo coloreado en su lugar.


\dothis{Abre un browser en la clase \ct{Color} y agrega el siguiente m\'etodo:}
\needlines{3}
\begin{method}{Getting a morph for an instance of \ct{Color}.}
Color>>>asMorph
	^ Morph new color: self
\end{method}
\noindent
Ahora ejecuta \ct{Color orange asMorph} \mthind{Morph}{openInWorld} en un workspace. En lugar de morph tipo string, obtienes un rect\'angulo naranja!



%=================================================================
\section{Manipulando morphs}

Los Morphs son objetos, por lo tanto podemos manipularlos como cualquier otro objeto en \st: envi\'andoles mensajes, podemos cambiar sus propiedades, creat nuevas subclases de Morph y demás.

Cada morph, incluso si no est\'a actualmente abierto en la pantalla, tiene una posición y un tamaño.
Para conveniencia, todo morph es considerado ocupando un regi\'on rectangular de la pantalla; si son de forma irregular, su posici\'on y tamanio son aquellos de la ``caja'' rectangular de menor tamaño que los rodea, que es conocida como caja de delimitaci\'on del morph, o simplemente su ``delimitador''.


El método \mthind{Morph}{position} devuelve un \ct{Point} que describe la ubicaci\'on de la esquina superior izquierda del morph  (o la esquina superior izquierda de su caja delimitadora).
El origen del sistema de coordenadas es la esquina superior izquierda de la pantalla, con la coordenada $y$  increment'nadose hacia abajo en la pantlla y con las coordenada $x$ increment\'andose hacia la derecha.

El m\'etodo \ct{extent} tambi\'en devuelve un punto, pero este punto especifica el ancho y alto del morph en vez de su posici\'on.


\dothis{Tipea lo siguiente en un workspace y \menu{do it}:}
\begin{code}{}
joe := Morph new color: Color blue.
joe openInWorld.
bill := Morph new color: Color red .
bill openInWorld.
\end{code}
\noindent
Luego tipea \ct{joe position} y \menu{print it}.
Para mover joe, ejecuta \ct{joe position: (joe position + (10@3))} repetidamente.

Is posible hacer algo similar con el tamanio.

\ct{joe} \mthind{Morph}{extent} devuelve el tamanio de joe; para agrandar a joe, ejecuta \ct{joe extent: (joe extent * 1.1)}.
Para cambiar el color de un morph, env\'iale el mensaje \mthind{Morph}{color:} con el objecto \ct{Color} deseado como argumento, por ejemplo, \ct{joe color: Color orange}.
Para agregar transparencia, prueba \ct{joe color: (Color orange alpha: 0.5)}.

\dothis{Para hacer que bill siga a joe, puedes ejecutar repetidamente este c\'odigo:}
\begin{code}{}
bill position: (joe position + (100@0))
\end{code}
\noindent
Si mueves a joe usando el rat\'on y luego ejecutas este c\'odigo, bill se mover\'a de manera de colocarse a 100 pixels a la derecha de joe.
\ab{Para ser un buen lugar para presentar el m\'etodo \ct{step}}.

%=================================================================
\section{Componiendo morphs}

Una forma de crear nuevas representaciones gr\'aficas es colocando un morph dentro de otro.
Esto es llamado \emph{composici\'on}; los morphs pueden ser compuesto en cualquier nivel de profundidad.
%
%Para crear nuevos morphs, hay dos t\'ecnicas principales que tu puedes combinar:
%\begin{enumerate}
%	\item combinar morphs uno dentro de otro,
%	\item subclasear \ct{Morph} y sobreescribir \mthind{Morph}{drawOn:} para dibuhar formas morphs originales.
%\end{enumerate}
%}
\index{Morph!composing}
Puedes colocar un morph dentro de otro enviando en mensaje \mthind{Morph}{addMorph:} al morph contenedor.

\dothis{Prueba agregar un morph dentro de otro:}
\begin{code}{}
star := StarMorph new color: Color yellow.
joe addMorph: star.
star position: joe position.
\end{code}

\noindent
La \'ultima l\'inea posiciona la estrella en las mismas coordenadas que joe.
Nota que las coorodenadas del morph contenido son a\'un relativas a la pantalla, no al morph contenedor.

Hay muchos m\'etodos disponibles para posicionar un morph, navega el protocolo \protind{geometry} de la clase \ct{Morph} para verlos por ti mismo.
Por ejemplo,
para centrar la estrella dentro de joe, ejecuta \ct{star} \mthind{Morph}{center:} \ct{joe center}.

\begin{figure}[ht]
	\centerline{\includegraphics{joeStar}}
	\caption{La estrella es contenido dentro de joe, el morph azul transl\'ucido.
		\figlabel{joeStar}}
\end{figure}

Si ahora intentas agarrar la estrella con el rat\'on, encontrar\'as que en realidad agarras a joe, y los dos morphs se mueven juntos: la estrella es \emph{embebida} en joe.
Es posible embeber m\'as morphs dentro de joe.
Adem\'as de poder hacer esto program\'aticamente, tambi\'en puede embeber morphs manipulandolos directamente.

%=================================================================
\section{Creando y dibujando tus propios morphs}

Mientras que es posible hacer muchas utilies e interesantes representaciones gr\'aficas componiendo morphs, en ocasiones necesitar\'as crear algo completamente diferente.
\index{Morph!subclassing}
Para hacer esto define una subclase de \ct{Morph} y sobreescribe el m\'etodo \mthind{Morph}{drawOn:} para cambiar su apariencia.

El framework morphic envia el mensaje \ct{drawOn:} a un morph cuando necesita volver a mostrar el morph en la pantalla. El par\'ametro pasado a \ct{drawOn:} es de tipo \clsind{Canvas}; el comportamiento experado es que el morph se dibuje en ese canvas, dentro de sus límites.

Usemos este conocimiento para crear un morph con forma de cruz.
\index{Morph!subclassing}

\dothis{Usando el browser, define una nueva clase \clsind{CrossMorph} heredando de \ct{Morph}:}
\begin{classdef}{Defining \ct{CrossMorph}}
Morph subclass: #CrossMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-Morphic'
\end{classdef}

Podemos definir el m\'etodo \ct{drawOn:} de esta forma:
\begin{method}[firstDrawOn]{Drawing a \ct{CrossMorph}.}
drawOn: aCanvas 
	| crossHeight crossWidth horizontalBar verticalBar |
	crossHeight := self height / 3.0 .
	crossWidth := self width / 3.0 .
	horizontalBar := self bounds insetBy: 0 @ crossHeight.
	verticalBar := self bounds insetBy: crossWidth @ 0.
	aCanvas fillRectangle: horizontalBar color: self color.
	aCanvas fillRectangle: verticalBar color: self color
\end{method}


\begin{figure}[hbt]
	\ifluluelse
		{\centerline{\includegraphics[width=0.3\textwidth]{NewCross}}}
		{\centerline{\includegraphics{NewCross}}}
	\caption{A \ct{CrossMorph} with its halo; you can resize it as you wish.
		\figlabel{cross}}
\end{figure}


Enviando el mensaje \mthind{Morph}{bounds} a un morph contesta su caja delimitadora, que es una instancia de \clsind{Rectangle}.  Rectangles entiende muchos mensajes que crean otros rect\'angulos de geometria relacionada; aqui usamos el mensaje \ct{insetBy:} con un punto como argumento para crear primero un  rect\'angulo con altura reducida, y luego otro con archo reducido.

\dothis{Para probar tu nuevo morph, ejecuta \ct{CrossMorph new} \mthind{Morph}{openInWorld}.}
El resultado deberia verse similar a una \figref{cruz}.
De todas formas, notar\'as que la zona sentiva\,---\,donde puedes hacer click para agarrar el morph\,---\,es a\'un la caja delimitadora completa.  Arreglemos esto.

Cuando el framework Morphic necesita encontrar que morphs estan bajo el cursor, env\'ia el mensaje \ct{containsPoint:} a todos los morphs cuyas caja delimitadoras se encuentran bajo el puntero del rat\'on.
Entonces, para limitar la zona sensitiva del morph a la forma de la cruz, necesitamos sobreescribir el m\'etodo \ct{containsPoint:}.

\dothis{Define el siguiente m\'etodo en la clase \ct{CrossMorph}:}

\needlines{4}
\begin{method}[firstContains]{D\'Shaping the sensitive zone of the \ct{CrossMorph}.}
containsPoint: aPoint
	| crossHeight crossWidth horizontalBar verticalBar |
	crossHeight := self height / 3.0.
	crossWidth := self width / 3.0.
	horizontalBar := self bounds insetBy: 0 @ crossHeight.
	verticalBar := self bounds insetBy: crossWidth @ 0.
	^ (horizontalBar containsPoint: aPoint)
		or: [verticalBar containsPoint: aPoint]
\end{method}

Este m\'etodo usa la misma l\'ogica que \ct{drawOn:}, entonces podemos estar seguros que los puntos para los cuales  \ct{containsPoint:} contesta \ct{true} son los mismos que ser\'an coloreados por \ct{drawOn}.
Nota como 
Notice how we aprovechamos el m\'etodo \mthind{Rectangle}{containsPoint:} en la clase \ct{Rectangle} para hacer el trabajo duro.

Hay dos problemas con el c\'odigo en \mthsref{firstDrawOn} y \ref{mth:firstContains}.
El m\'as obvio es que hemos duplicado c\'odigo.
Este es un error cardinal: si encontramos que necesitamos cambiar la forma en que \ct{horizonatalBar} o \ct{verticalBar} son calculadas, podriamos olvidarnos de cambiar una de las dos ocurrencias.
La solución es factorizar estos c\'alculos en dos nuevos m\'etodos, que pondremos en el protocolo  \ct{private}:

\needlines{4}
\begin{method}{\ct{horizontalBar}.}
horizontalBar
	| crossHeight |
	crossHeight := self height / 3.0.
	^ self bounds insetBy: 0 @ crossHeight
\end{method}

\needlines{4}
\begin{method}{\ct{verticalBar}.}
verticalBar
	| crossWidth |
	crossWidth := self width / 3.0.
	^ self bounds insetBy: crossWidth @ 0
\end{method}

\noindent
Podemos entonces definir ambos \ct{drawOn:} y \ct{containsPoint:} usando estos m\'etodos:

\needlines{4}
\begin{method}{Refactored \ct{CrossMorph>>>drawOn:}.}
drawOn: aCanvas 
	aCanvas fillRectangle: self horizontalBar color: self color.
	aCanvas fillRectangle: self verticalBar color: self color
\end{method}
r
\needlines{4}
\begin{method}{Refactored \ct{CrossMorph>>>containsPoint:}.}
containsPoint: aPoint 
	^ (self horizontalBar containsPoint: aPoint)
		or: [self verticalBar containsPoint: aPoint]
\end{method}

Este c\'odigo es mucho m\'as simple de entender, en gran medida porque hemos dado nombres con significado a los m\'etodos privados.
De hecho, es tanto m\'as simple que puedes haber notado el segundo problema: el \'area en el centro de la cruz, que est\'a bajo la barra horizontal y la barra vertical, es dibujada dos veces.
Esto no importa cuando llenamos la cruz con un color opaco, pero el defecto se vuelve evidente inmediatable si dibujamos una cruz semitransparente, como se muestra en la \figref{overdrawBug}.

\begin{figure}[t]
\begin{minipage}{0.48\textwidth}
	\ifluluelse
		{\centerline{\includegraphics[scale=0.6]{overdrawBug}}}
		{\centerline{\includegraphics{overdrawBug}}}
	\caption{The center of the cross is filled twice with the colour.
		\figlabel{overdrawBug}}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
	\ifluluelse
		{\centerline{\includegraphics[scale=0.6]{hairlineBug}}}
		{\centerline{\includegraphics{bug}}}
	\caption{The cross-shaped morph, showing a row of unfilled pixels.
		\figlabel{bug}}
\end{minipage}
\end{figure}

\needlines{4}
\dothis{Ejecuta el siguiente c\'odigo en un workspace, l\'inea por l\'inea:}

\begin{code}{}
m := CrossMorph new bounds: (0@0 corner: 300@300).
m openInWorld.
m color: (Color blue alpha: 0.3).
\end{code}

\noindent
La soluci\'on a esto es divider la barra vertical en 3 partes, y llenar solo la parte superior y la inferior.
Una vez m\'as encontramos un m\'etodo en la clase  \ct{Rectangle} que hace el trabajo duro por nosotros: \ct{r1 areasOutside: r2} devuelve un arreglo de rect\'angulos con las parte de of \ct{r1} fuera de \ct{r2}. 
Aqu\'i est\'a el c\'odigo revisado:

\begin{method}{The revised \ct{drawOn:} method, which fills the center of the cross once.}
drawOn: aCanvas 
	| topAndBottom |
	aCanvas fillRectangle: self horizontalBar color: self color.
	topAndBottom := self verticalBar areasOutside: self horizontalBar. 
	topAndBottom do: [ :each | aCanvas fillRectangle: each color: self color]
\end{method}

Este c\'odigo parece funcionar, pero si lo pruebas con algunas cruces y le cambias el tamanio, notar\'as que en ciertos tamanio, una l\'inea de un pixel separa la parte inferior de la cruz del resto, como se muestra en \figref{bug}.
Esto es debido al redondeo: cuando el tamanio del rect\'angulo a ser llenado no es un entero, \ct{fillRectangle: color:}
parece redondear consistentemente, dejando ona fila de pixeles sin llenar.
Podemos trabajar sobre esto redondeando expl\'icitamente cuando calculamos los tamanio de las barras.

\needlines{5}
\begin{method}{\ct{CrossMorph>>>horizontalBar} with explicit rounding.}
horizontalBar
	| crossHeight |
	crossHeight := (self height / 3.0) rounded.
	^ self bounds insetBy: 0 @ crossHeight
\end{method}

\needlines{5}
\begin{method}{\ct{CrossMorph>>>verticalBar} with explicit rounding.}
verticalBar
	| crossWidth |
	crossWidth := (self width / 3.0) rounded.
	^ self bounds insetBy: crossWidth @ 0
\end{method}



%=================================================================
%\section{Composing Morphs}

%\on{The source code is in the examples directory.
%For the moment I prefer to leave out the examples, as they do not add much.}

%Below, we present a few morphs that were designed for a course project.

%\paragraph{An adhesive Label} The \ct{LabelStickerMorph} is a metaphor for an adhesive label with a colored border and three lines of text (\figref{labeler}, \egref{labeler}).

%\begin{figure}[ht]
%	\centerline{\includegraphics[width=0.25\textwidth]{labeler}}
%	\caption{The sticker label morph.
%		\figlabel{labeler}}
%\end{figure}

%\begin{example}[labeler]{Creating a sticker label}{}
%label := LabelstickerMorph new openInWorld.
%label text1: 'Confiture sans sucre';
%	text2: 'Fraises du jardin';
%	text3: '9 mai 2006'.
%label lineColor: Color blue
%\end{example}

%\paragraph{A Number Pyramid}
%The previous morph is designed by overriding the \ct{drawOn:} method.
%We built \ct{PyramidMorph} by composing morphs: we used \ct{TextMorph}s to make the blocks and added them to a base morph (\figref{pyramid}, \egref{pyramid}). \damien{figure does not match text... no numbers? Where is the code?}
%\begin{figure}[ht]
%	\centerline{\includegraphics{pyramid}}
%	\caption{The number pyramid morph.
%		\figlabel{pyramid}}
%\end{figure}

%\begin{example}[pyramid]{Manipulating the number pyramid}{}
%pyramid := (PyramidMorph base: 4) openInWorld.
%pyramid block: 8 value: 2
%\end{example}


%=================================================================
\section{Interacci\'on y animaci\'on }

Para construir interfaces de usuario vivas usando morphs, necesitamos poder interactuar con ellos usando el rat\'on y el teclado. 
Más aún, los morphs necesitan ser capaces de responder a la entrada del usuario cambiando su apariencia y posici\'on\,---\,esto es, anim\'andose asimismos.


\subsection{Eventos del rat\'on}

Cuando in bot\'on del rat\'on es presionado, Morphic env\'ia el mensaje \mthind{Morph}{mouseDown:} a cada morph ubicado bajo el puntero del rat\'on y también envia el mensaje \mthind{Morph}{mouseUp:} cuando el suario libera el bot\'on del rat\'on.
Si todos los morphs contestan \ct{false}, entonces Morphic inicia una operaci\'on drap-and-drop.
Como discutiremos m\'as abajo, los mensajes \ct{mouseDown:} y \ct{mouseUp:} son enviados con el argumento\,---\,a \clsind{MouseEvent} \,---\,que codifica los detalles de la acci\'on del rat\'on.

Extendamos el \ct{CrossMorph} para manejar eventos del rat\'on, 
Comenzamos por asegurarnos que todos los crossMorphs contestan \ct{true} a el mensaje\mthind{Morph}{handlesMouseDown:}. 

\dothis{Agrega este método a \ct{CrossMorph}:}
\begin{method}{Declaring that \ct{CrossMorph} will react to mouse clicks.}
CrossMorph>>>handlesMouseDown: anEvent
	^true
\end{method}

Supongamos que cuando hacemos click en la cruz, queremos cambiar el color de la cruz a rojo, y que cuando \actclick en esta, queremos cambiar el color a amarillo.
Esto se puede hacer con \mthref{mouseDown}.

\needlines{7}
\begin{method}[mouseDown]{Reacting to mouse clicks by changing the morph's color.}
CrossMorph>>>mouseDown: anEvent
	anEvent redButtonPressed "click"
		ifTrue: [self color: Color red].
	anEvent yellowButtonPressed "action-click"
		ifTrue: [self color: Color yellow].
	self changed
\end{method}

\ab{I added this note:}
Nota que adicionalmente a cambiar el color de un morph, este m\'etodo tambi\'en envia \ct{self changed}.
Esto asegura que el morphic env\'ia \ct{drawOn:} de manera oportuna.

\ab{De todas formas, el mensaje \ct{self changed} parece ser enteramente innecesario; el color cambia instantaneamente sin este.}
Nota tambi\'en que una vez que el morph maneja el \ind{mouse events}, ya no puedes agarrarlo con el rat\'on y moverlo.
En lugar de ello tienes que utilizar el halo: \metaclick en el morph para haccer aparecer el halo y agarrar el manejador marr\'on \moveHandle{}  o el manejador negro \grabHandle{} en la parte superior del morph,

El argumento \ct{anEvent} de \ct{mouseDown:} es una instancia de \mbox{\clsind{MouseEvent},} que es una subclase de  \lct{Mor\-phic\-Event}. \ct{MouseEvent} define los m\'etodos \mthind{MouseEvent}{redButtonPressed} y \mthind{MouseEvent}{yellowButtonPressed}. Navega esta clase para ver que otros m\'etodos provee para interrogar los eventos del rat\'on.

\subsection{Eventos del teclado}

To catch \ind{keyboard events}, we need to take three steps.
\begin{enumerate}
	\item Give the ``keyboard focus'' to a specific morph: for instance we can give focus to our morph when the mouse is over it.
	\item Handle the keyboard event itself with the \mthind{Morph}{handleKeystroke:} method: this message is sent to the morph that has keyboard focus when the user presses a key.
	\item Release the keyboard focus when the mouse is no longer over our morph.
\end{enumerate}

Extendamos el \ct{CrossMorph} para que reaccione a las pulsaciones de teclas.
Primero necesitamos ser notificados cuando el rat\'on est\'a sobre el morph.
Esto suceder\'a si nuestro morph responde \ct{true} al mensaje \mthind{Morph}{handlesMouseOver:}

\dothis{Declare that \ct{CrossMorph} will react when it is under the mouse pointer.}
\begin{method}{We want to handle ``mouse over'' events.} 
CrossMorph>>>handlesMouseOver: anEvent
	^true
\end{method}

\noindent
Este mensaje es el equivalente a \mthind{Morph}{handlesMouseDown:} para la posici\'on del rat\'on.
Cuando el puntero del rat\'on entra o sale del morph, los mensajes \mthind{Morph}{mouseEnter:} y \mthind{Morph}{mouseLeave:} son enviados a este.

\dothis{Define dos m\'etodos para que el \ct{CrossMorph} atrape y libere el foco del teclado, y un tercer m\'etodo para manejar las pulsaciones de teclado.}
\begin{method}{Getting the keyboard focus when the mouse enters the morph.}
CrossMorph>>>mouseEnter: anEvent
	anEvent hand newKeyboardFocus: self
\end{method}

\begin{method}{Handing back the focus when the pointer goes away.}
CrossMorph>>>mouseLeave: anEvent
	anEvent hand newKeyboardFocus: nil
\end{method}

\begin{method}[handleKeystroke]{Receiving and handling keyboard events.}
CrossMorph>>>handleKeystroke: anEvent
	| keyValue |
	keyValue := anEvent keyValue.
	keyValue = 30	 "up arrow"
		ifTrue: [self position: self position - (0 @ 1)].
	keyValue = 31	 "down arrow"
		ifTrue: [self position: self position + (0 @ 1)].
	keyValue = 29	 "right arrow"
		ifTrue: [self position: self position + (1 @ 0)].
	keyValue = 28	 "left arrow"
		ifTrue: [self position: self position - (1 @ 0)]
\end{method}

Hemos escrito este m\'etodo  para poder mover el morph usando las teclas de flecha.
Nota que cuando el rat\'on ya no est\'a sobre el morph, el mensaje \mthind{Morph}{handleKeystroke:} no es enviado, por lo que el morph deja de responder a los comandos del teclado.
Para descubrir los valores de las teclas, pueden abrir un Transcript y agregar \glbind{Transcript} \ct{show: anEvent keyValue} al método \mthref{handleKeystroke} 

El argumento \ct{anEvent} de \ct{handleKeystroke:} es una instancia de \clsind{KeyboardEvent}, otra subclase de \clsind{MorphicEvent}. Navega esta clase para aprender m\'as sobre los eventos de teclado. 

\subsection{Animaciones Morphic}

Morphic provee un sistema simple de animaci\'on con dos m\'etodos: \mthind{Morphic}{step} es enviado a un morph en intervalos regulares de tiempo, mientras que \mthind{Morphic}{stepTime} especifica el tiempo en milisegundos entre \ct{step}s.\footnote{\ct{stepTime} es en realidad el \emph{m\'inimo} tiempo entre \ct{step}s.}

Si preguntas por un \ct{stepTime} de 1\,ms, no te sorprendas si \pharo est\'a muy ocupado para step tu morph tan seguido.

In addition, 
\mthind{Morphic}{startStepping} turns on the stepping mechanism, while \mthind{Morphic}{stopStepping} turns it off again;  \mthind{Morphic}{isStepping} can be used to find out whether a morph is currently being stepped.
\index{Morphic!animation}

\dothis{Make \ct{CrossMorph} blink by defining these methods as follows:}
\begin{method}{Defining the animation time interval.}
CrossMorph>>>stepTime
	^ 100
\end{method}
\begin{method}{Making a step in the animation.}
CrossMorph>>>step
	(self color diff: Color black) < 0.1
		ifTrue: [self color: Color red]
		ifFalse: [self color: self color darker]
\end{method}
\noindent

Para comenzar, puedes abrir un inspector en un \ct{CrossMorph}  (usando el manejador de debug \debugHandle{} en una halo de morphic), tipea \ct{self startStepping} en el pequeño workspace de abajo, y \menu{do it}.
Alternativamente, puedes modificar el m\'edtodo \ct{handleKeystroke:}  para que puedas usar las teclas $+$ and $-$  para comenzar y deterner eel paso a paso.


\dothis{Agregar el siguiente c\'odigo a \mthref{handleKeystroke}:}

\begin{code}{}
	keyValue = $+ asciiValue 
		ifTrue: [self startStepping].
	keyValue = $- asciiValue
		ifTrue: [self stopStepping].
\end{code}

% \on{You can also \menu{debug \go inspect morph} and evaluate: \ct{self currentWorld startStepping: self}.}

%=================================================================
\section{Interactors}

Para pedirle al usuario una entrada, la clase \clsind{UIManager} provee una gran n\'umero de  cajas de di\'alogo listas para usar.
Por ejemplo, el m\'etodo \mthind{UIManager}{request:initialAnswer:} revuelve un cadena ingresada por le usuario (\figref{dialogName}).

\begin{code}{}
UIManager default request: 'What''s your name?' initialAnswer: 'no name'
\end{code}

\begin{figure}[htb]
\begin{minipage}{0.48\textwidth}
	\centerline{\includegraphics[width=0.8\textwidth]{dialog}}
	\caption{An input dialog.}\figlabel{dialogName}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
	\vfill
	\centerline{\includegraphics [width=0.8\textwidth]{popup}}
	\vfill
	\vspace{4ex}
	\caption{Pop-up menu.}\figlabel{popup}
\end{minipage}
\end{figure}

Para desplegar un men\'e emergente, usa uno de los variso m\'etodos \ct{chooseFrom:} (\figref{popup}):
\begin{code}{}
UIManager default
	chooseFrom: #('circle' 'oval' 'square' 'rectangle' 'triangle')
	lines: #(2 4) message: 'Choose a shape'
\end{code}

\dothis{Nageva la clase \clsind{UIManager} y prueba algunos de los m\'etodos de interacci\'on ofrecidos.}

%\begin{figure}[ht]
%	\centerline{\includegraphics[width=5cm]{dialog}}
%	\caption{Dialog displayed by \ct{FillInTheBlank request: 'What''s your name?' initialAnswer: 'no name'}.
%		\figlabel{dialogName}}
%\end{figure}

%To display a pop-up menu, use the \clsind{PopupMenu} class:
%\begin{code}{}
%UIManager default chooseFrom: #('circle' 'oval' 'square' 'rectangle' 'triangle') lines: #(2 4) message: 'Choose a shape'
%\end{code}

%\begin{figure}[ht]
%	\centerline{\includegraphics[width=3cm]{popup}}
%	\caption{PopUp displayed by \ct{PopUpMenu>>>startUpWithCaption:}.}
%\end{figure}

%=================================================================
\section{Arrastrar y Soltar}
Morphic tambi\'en soporta drag-and-drop. Examinemos un simple ejemplo con dos morphs, un morph receptor y un morph dropped. 
El receptor aceptar\'a un morph solo si el morph arrastrado coincide con una condici\on dada: en nuestro ejemplo, el morph debe ser azul. Si es rechazado el  morph arrastrado decide que hacer.

\dothis{Primero definamos el morph receptor:}
\begin{classdef}{Defining a morph on which we can drop other morphs}
Morph subclass: #ReceiverMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-Morphic'
\end{classdef}

\dothis{Ahora define el m\'etodo de inicializaci\'on de la manera usual:}
\begin{method}{Initializing \ct{ReceiverMorph}.}
ReceiverMorph>>>initialize
	super initialize.
	color := Color red.
	bounds := 0 @ 0 extent: 200 @ 200
\end{method}

Como dedicir si el receptor aceptar\'a o rechazar\'a el morph arrastrado?
En general ambos morphs tendr\'an que acordar en la interacci\'on.

El receptor hace esto respondiendo a \mthind{Morph}{wantsDroppedMorph:event:}; al primer argumento es el morph arrastrado, y el segundo es el evento del mouse, de esta forma el receptor puede por ejemplo ver si alguna tecla modificador fue presionada al momento del arrastre.
El morph arrastrado tambi\'en tiene la oportunidad de chequear y ver si le gusta el morph sobre el que está siendo arrojado; se le env\'ia el mensaje \ct{wantsToBeDroppedInto:}. La implementaci\'on por defecto de este m\'etodo (en la clase \ct{Morph}) responde \ct{true}.

\begin{method}{Accept dropped morphs based on their color.}
ReceiverMorph>>>wantsDroppedMorph: aMorph event: anEvent
	^ aMorph color = Color blue
\end{method}

Que ocurre con el morph arrojado si el morph receptor no lo quiere? El comportamiento por defecto es no hacer nada, eso es, sentarse encima del  morph receptor, pero sin interactuar con el. Un comportamiento m\'as intuitivo es que el morph arrojado vuelva a su posici\'on original. Esto puede lograrse en el receptor, contestando \ct{true}  al mensaje \mthind{Morph}{repelsMorph:event:} cuando no quiere al morph arrojado:


\needlines{4}
\begin{method}{Changing the behaviour of the dropped morph when it is rejected.}
ReceiverMorph>>>repelsMorph: aMorph event: ev
	^ (self wantsDroppedMorph: aMorph event: ev) not
\end{method}

Eso es todo lo que necesitamos en lo que respecta al receptor.

\dothis{Crea instancias de \clsind{ReceiverMorph} y \clsind{EllipseMorph} en un workspace:}
\begin{code}{}
ReceiverMorph new openInWorld.
EllipseMorph new openInWorld.
\end{code}
\noindent
Intenta hacer drag-and-drop  el \ct{EllipseMorph}  amarillo sobre el receptor. Este ser\'a rechazado y enviado de vuelta a su posici\'on original.

\dothis{Para cambiar este comportamiento, cambia el color de la morph elipse a \ct{Color blue} usando un inspector. Los morphs azules deben ser aceptado por el \ct{ReceiverMorph}.}


Creemos una subclasse de \ct{Morph}, llamada \ct{DroppedMorph}, para que podamos experimentar un poco m\'as:

\begin{classdef}{Defining a morph we can drag-and-drop onto \ct{ReceiverMorph}}
Morph subclass: #DroppedMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-Morphic'
\end{classdef}

\needlines{5}
\begin{method}{Initializing \ct{DroppedMorph}.}
DroppedMorph>>>initialize
	super initialize.
	color := Color blue.
	self position: 250@100
\end{method}

Ahora podemos especificar que debe hacer el morph arrastrado cuando es rechazado por el receptor; aqui este permanecer\'a adjunto al puntero del rat\'on.:

\begin{method}{Reacting when the morph was dropped but rejected.}
DroppedMorph>>>rejectDropMorphEvent: anEvent
	| h |
	h := anEvent hand.
	WorldState
		addDeferredUIMessage: [h grabMorph: self].
	anEvent wasHandled: true
\end{method}

Enviar el mensaje \mthind{MorphicEvent}{hand} a un evento, responde la \emph{hand}, una instancia de \ct{HandMorph} que representa el puntero del rat\'on y lo que sea que sostenga.

Aqui le decimos al \ct{World} que la mano debe agarrar \ct{self}, el morph rechazado.

\dothis{Crea dos intancias de \ct{DroppedMorph}, y luego drag-and-drop sobre el receptor.}
\begin{code}{}
ReceiverMorph new openInWorld.
(DroppedMorph new color: Color blue) openInWorld.
(DroppedMorph new color: Color green) openInWorld.
\end{code}
\noindent
The green morph is rejected and therefore stays attached to the mouse pointer.
El morph verde is rechazado y por lo tanto permanece adjunto a puntero del rat\'on.

%=================================================================
\section{Un ejmeplo completo}

Deseñemos un moprh para tirar un dado. Haciendo click en el, mostrar\'a los valores de todas las caras del dado en un ciclo, y otro click detendr\'a la animaci\'on.

\begin{figure}[ht]
	\centerline{\includegraphics[scale=0.65]{die}}
	\caption{The die in Morphic.
		\figlabel{dialogDie}}
\end{figure}

\dothis{Define un dado como una subclase de \clsind{BorderedMorph} en lugar de \ct{Morph}, porque haremos uso del borde.}

\needlines{6}
\begin{classdef}{Defining the die morph}
BorderedMorph subclass: #DieMorph
	instanceVariableNames: 'faces dieValue isStopped'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-Morphic'
\end{classdef}

La variable de instancia \ct{faces} registra el n\'umero de caras del dado; nos permitir\'a dados con hasta 9 caras! \ct{dieValue} registra los valores de la cara que est\'a actualmente mostrada, y \ct{isStopped} is verdadero si la animaci\'on est\'a detenida.

Para crear una instancia de dado, definimos el m\'etodo caras en el lado \emph{class}  de \clsind{DieMorph} para crear un nuevo dado con \ct{n} caras.

\begin{method}{Creating a new die with the number of faces we like.}
DieMorph class>>>faces: aNumber
	^ self new faces: aNumber
\end{method}

El m\'etodo \ct{initialize} est\'a es definido en la instancia como de costumbre; recuerda que \ct{new} env\'ia \ct{initialize} a la nueva instancia creada.
\begin{method}{Initializing instances of \ct{DieMorph}.}
DieMorph>>>initialize
	super initialize.
	self extent: 50 @ 50.
	self useGradientFill; borderWidth: 2; useRoundedCorners.
	self setBorderStyle: #complexRaised.
	self fillStyle direction: self extent.
	self color: Color green.
	dieValue := 1.
	faces := 6.
	isStopped := false
\end{method}

Usamos unos pocos m\'etodos de \ct{BorderedMorph}  para dar una apariencia agradable al dado: un borde grueso con una efecto raised, esquinas redondeadas, y un color gradiente en la cara visible.

Definimos el m\'etodo de instancia \ct{faces:} to chequear par\'ametros v\'alidos como sigue:

\begin{method}{Setting the number of faces of the die.}
DieMorph>>>faces: aNumber
	"Set the number of faces"
	(aNumber isInteger
			and: [aNumber > 0]
			and: [aNumber <= 9])
		ifTrue: [faces := aNumber]
\end{method}
\on{Why not make this a pre-condition, \ie an assertion?}

Podr\'ia ser bueno reveer el orden en que se envian los mensajes cuando un dado es creado. Por ejemplo, si comenzamos por
evaluar \ct{DieMorph faces: 9}:
\begin{enumerate}
	\item The class method \ct{DieMorph class>>>faces:} sends \ct{new} to \ct{DieMorph class}.
	\item The method for \ct{new} (inherited by \ct{DieMorph class} from \ct{Behavior}) creates the new instance and sends it the \ct{initialize} message.
	\item The \ct{initialize} method in \ct{DieMorph} sets \ct{faces} to an initial value of 6.
	\item \ct{DieMorph class>>>new} returns to the class method \ct{DieMorph class>>>faces:}, which then sends the message \ct{faces: 9} to the new instance.
	\item The instance method \ct{DieMorph>>>faces:} now executes, setting the \ct{faces} instance variable to 9.
\end{enumerate}

Antes de definir \ct{drawOn:}, necesitamos unos pocos m\'etodos para poner los puntos en la cara mostrada:
\begin{methods}{Nine methods for placing points on the faces of the die.}
DieMorph>>>face1
	^{0.5@0.5}
DieMorph>>>face2
	^{0.25@0.25 . 0.75@0.75}
DieMorph>>>face3
	^{0.25@0.25 . 0.75@0.75 . 0.5@0.5}
DieMorph>>>face4
	^{0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75}
DieMorph>>>face5
	^{0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75 . 0.5@0.5}
DieMorph>>>face6
	^{0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75 . 0.25@0.5 . 0.75@0.5}
DieMorph>>>face7
	^{0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75 . 0.25@0.5 . 0.75@0.5 . 0.5@0.5}
DieMorph >>>face8
	^{0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75 . 0.25@0.5 . 0.75@0.5 . 0.5@0.5 . 0.5@0.25}
DieMorph >>>face9
	^{0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75 . 0.25@0.5 . 0.75@0.5 . 0.5@0.5 . 0.5@0.25 . 0.5@0.75}
\end{methods}
\on{kind of ugly boilerplate code -- should be a nice way to map these more elegantly to coordinates.}

Estos m\'etodos definen colecciones de coordenadas de puntos para cada cara. Las coordenadas estan en un cuadrado de tamaño $1\times1$; simplemente necesitaremos escalarlas para ubicar los verdaderos puntos.

El m\'etodo \ct{drawOn:} hace dos cosas: dibuja el fondo muerto con la \ct{super}-send, y luego dibuja los puntos.
\begin{method}{Drawing the die morph.}
DieMorph>>>drawOn: aCanvas
	super drawOn: aCanvas.
	(self perform: ('face' , dieValue asString) asSymbol)
		do: [:aPoint | self drawDotOn: aCanvas at: aPoint]
\end{method}

La segunda parte de este m\'etodo usa las capacidades refletivas de \st.
Dibujar los puntos de una cara es una simple cuesti\'on de iterar sobre la colecci\'on de dada por el m\'etodo \ct{faceX} para esa cara, envienado el mensaje \ct{drawDotOn:at:} para cada coordenada. Para llamar el correcto m'etodo \ct{faceX}, usamos el m\'etodo \mthind{Object}{perform:} que envia un mensaje creado desde un string, aqu\'i \lct{('face', dieValue asString) asSymbol}. Encotraras este uso de este \ct{perform:} bastante regularmente.
\index{reflection}
\begin{method}{Drawing a single dot on a face.}
DieMorph>>>drawDotOn: aCanvas at: aPoint
	aCanvas
		fillOval: (Rectangle
			center: self position + (self extent * aPoint)
			extent: self extent / 6)
		color: Color black
\end{method}
\ew{I would not use reflection to call faceX on p.234. A statically filled Dictionary would be more appropriate. Get the point set with "MyDict at: X".}

Since the coordinates are normalized to the $[0{:}1]$ interval, we scale them to the dimensions of our die: \ct{self extent * aPoint}.

\dothis{We can already create a die instance from a workspace:}
\begin{code}{}
(DieMorph faces: 6) openInWorld.
\end{code}

To change the displayed face, we create an accessor that we can use as \ct{myDie dieValue: 4}:
\begin{method}{Setting the current value of the die.}
DieMorph>>>dieValue: aNumber
	(aNumber isInteger
			and: [aNumber > 0]
			and: [aNumber <= faces])
		ifTrue:
			[dieValue := aNumber.
			self changed]
\end{method}

Now we will use the animation system to show quickly all the faces:
\needlines{3}
\index{Morphic!animation}
\begin{methods}{Animating the die.}
DieMorph>>>stepTime
	^ 100

DieMorph>>>step
	isStopped ifFalse: [self dieValue: (1 to: faces) atRandom]
\end{methods}
Now the die is rolling!

To start or stop the animation by clicking, we will use what we learned previously about mouse events.
First, activate the reception of mouse events:

\begin{methods}{Handling mouse clicks to start and stop the animation.}
DieMorph>>>handlesMouseDown: anEvent
	^ true

DieMorph>>>mouseDown: anEvent
	anEvent redButtonPressed
		ifTrue: [isStopped := isStopped not]
\end{methods}
Now the die will roll or stop rolling when we click on it.

% That's all for the essentials of Morphic!

% Most of the work on \ct{DieMorph} was done with an instance of it living in the environment; this is quite nice when to tweak programs.

%=================================================================
\section{More about the canvas}

The \ct{drawOn:} method has an instance of \clsindmain{Canvas} as its sole argument;
the canvas is the area on which the morph draws itself.
By using the graphics methods of the canvas you are free to give the appearance you want to a morph.
If you browse the inheritance hierarchy of the \ct{Canvas} class, you will see that it has several variants.
The default variant of \ct{Canvas} is \clsind{FormCanvas}; you will find the key graphics methods in \ct{Canvas} and \ct{FormCanvas}.
These methods can draw points, lines, polygons, rectangles, ellipses, text, and images with rotation and scaling.

It is also possible to use other kinds of canvas, to obtain transparent morphs, more graphics methods, antialiasing, and so on.
To use these features you will need an \clsind{AlphaBlendingCanvas} or a \clsind{BalloonCanvas}.
But how can you obtain such a canvas in a \ct{drawOn:} method, when \ct{drawOn:} receives an instance of \ct{FormCanvas} as its argument?
Fortunately, you can transform one kind of canvas into another.

\dothis{To use a canvas with a 0.5 alpha-transparency in \ct{DieMorph}, redefine \ct{drawOn:} like this:}
\needlines{7}
\begin{method}{Drawing a translucent die.}
DieMorph>>>drawOn: aCanvas
	| theCanvas |
	theCanvas := aCanvas asAlphaBlendingCanvas: 0.5.
	super drawOn: theCanvas.
	(self perform: ('face' , dieValue asString) asSymbol)
		do: [:aPoint | self drawDotOn: theCanvas at: aPoint]
\end{method}
\noindent
That's all you need to do!

\begin{figure}[ht]
	\centerline{\includegraphics[scale=0.7]{multiMorphs}}
	\caption{The die displayed with alpha-transparency.
		\figlabel{multiMorphs}}
\end{figure}

% ON: This appears to be broken:

%If you're curious, have a look at the \mthind{Canvas}{asAlphaBlendingCanvas:} method.
%You can also get antialiasing by using \clsind{BalloonCanvas} and transforming the die drawing methods as shown in \mthsref{aadie}.

%\needlines{6}
%\begin{methods}[aadie]{Drawing an antialiased die.}
%DieMorph>>>drawOn: aCanvas
%	| theCanvas |
%	theCanvas := aCanvas asBalloonCanvas aaLevel: 3.
%	super drawOn: aCanvas.
%	(self perform: ('face' , dieValue asString) asSymbol)
%		do: [:aPoint | self drawDotOn: theCanvas at: aPoint]

%DieMorph>>>drawDotOn: aCanvas at: aPoint
%	aCanvas
%		drawOval: (Rectangle
%			center: self position + (self extent * aPoint)
%			extent: self extent / 6)
%		color: Color black
%		borderWidth: 0
%		borderColor: Color transparent
%\end{methods}

%=================================================================
\section{Chapter summary}

Morphic is a graphical framework in which graphical interface elements can be dynamically composed.

\begin{itemize}
  \item You can convert an object into a morph and display that morph on the screen by sending it the messages \ct{asMorph openInWorld}.
  \item You can manipulate a morph by \metaclick{ing} on it and using the handles that appear. (Handles have help balloons that explain what they do.)
  \item You can compose morphs by embedding one onto another, either by drag and drop or by sending the message \ct{addMorph:}.
  \item You can subclass an existing morph class and redefine key methods, like \ct{initialize} and \ct{drawOn:}.
  \item You can control how a morph reacts to mouse and keyboard events by redefining the methods \ct{handlesMouseDown:}, \ct{handlesMouseOver:}, \etc
  \item You can animate a morph by defining the methods \ct{step} (what to do) and \ct{stepTime} (the number of milliseconds between steps).
  \item Various pre-defined morphs, like \ct{PopUpMenu} and \ct{FillInTheBlank}, are available for interacting with users.
\end{itemize}

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%-----------------------------------------------------------------
