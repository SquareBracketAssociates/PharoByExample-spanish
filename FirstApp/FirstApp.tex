% $Author$
% $Date$
% $Revision$

% HISTORY:
% 2006-12-05 - Stef started
% 2006-12-30 - Andrew new material
% 2007-01-10 - Stef edit
% 2007-01-12 - Andrew edit
% 2007-06-07 - Oscar edit
% 2007-07-03 - Stef edit
% 2007-09-06 - Lukas review
% 2007-09-06 - Cassou corrections
% 2007-09-24 - Cassou review
% 2009-07-01 - Oscar migrated to Pharo

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
\chapter{Una primer aplicación}
\chalabel{firstApp}

En este capítulo vamos a desarrollar un juego simple: \ind{Lights Out}.\footnote{\url{http://en.wikipedia.org/wiki/Lights_Out_(game)}}
En el camino mostraremos la mayoría de las herramientas que los programadores
de \pharo usan para construir y depurar sus programas, y mostraremos como se
intercambian los programas con otros desarrolladores. Veremos el explorador,
el inspector de objetos, el depurador y el paquete explorador \ind{Monticello}
El desarrollo en Smalltalk es eficiente: encontrará que pasa mas tiempo escribiendo código y mucho menos manejando el proceso de desarrollo.
Esto es en parte porque Smalltalk es muy simple, y en parte porque las herramientas que conforman el entorno de programación están muy bien integradas con el lenguaje.

%=================================================================
\section{El juego Lights Out}

% DON'T USE WRAPFIGURE CLOSE TOO A PAGE BREAK!!! (ON)
%\begin{wrapfigure}[13]{r}{0.35\linewidth}%
%	\vskip -\baselineskip
%	\centerline{\includegraphics[width=.8\linewidth]{GameBoard}}
%	\caption{The Lights Out game board. The user has just clicked the mouse as shown by the cursor.
%	\figlabel{gameBoard}}
%\end{wrapfigure}

\begin{figure}[ht]
	\vskip -\baselineskip
	\centerline{\includegraphics[width=.3\linewidth]{GameBoard}}
	\caption{El tablero del juego Lights Out. El usuario ha hecho click con el mouse como muestra el cursor.
	\figlabel{gameBoard}}
\end{figure}


% To show you how to use \pharo's programming tools, we will build a simple game
% called \emph{Lights Out}.  The game board is shown in \figref{gameBoard}; it
% consists of rectangular array of light yellow \emph{cells}.  When you click on
% one of the cells with the mouse, the four surrounding cells turn blue.  \Click
% again, and they toggle back to light yellow.  The object of the game is to turn
% blue as many cells as possible.

Para mostrarle como utilizar las herramientas de \pharo, construiremos un un juego
sencillo llamado \emph{Lights Out}. El tablero del juego se muesta en \figref{gameBoard};
consiste en una grilla rectagular de \emph{celdas} amarillas. Cuando haces click
sobre una celda con el mouse, las cuatro celdas adyacentes se tornan azules. Si
haces \Click otra vez, se volverán otras vez amarillas. El objetivo del juego
es poner azules la mayor cantidad de celdas como sea posible.

% The Lights Out game shown in \figref{gameBoard} is made up of two kinds of
% objects: the game board itself, and 100 individual cell objects.  The \pharo
% code to implement the game will contain two classes: one for the game and one
% for the cells.  We will now show you how to define these classes using the
% \pharo programming tools.

En el Lights Out que se muesta \figref{gameBoard} está compuesto por
dos objetos: el tablero del juego en sí, y 100 objetos celda individuales. El
código de \pharo para implementar el juego tendrá dos clases: una para el
juego y otra para las celdas. Ahora veremos cómo definir estas clases usando
las herramientas de programación de \pharo.

\section{Creando un paquete nuevo}

% We have already seen the \ind{browser} in \charef{quick}, where we learned how
% to navigate to classes and methods, and saw how to define new methods.  Now we
% will see how to create packages, categories and classes.

Ya hemos visto el \ind{Browser} en \charef{quick}, donde aprendimos como
navegar clases y métodos, y vimos como definir nuevos métodos. Ahora veremos
como crear paquetes, categorías y clases.

\index{category!creating}
\index{package!creating}

% \dothis{Open a browser and \actclick in the package pane.  
% Select \menu{create package}.\footnote{We are assuming that the Package Browser is 
% installed as the default browser, which should normally 
% be the case. If the browser you get does
% not look like the one shown in \figref{addPackage}, then you may need to change
% the default browser.  See \faqref{packagebrowser}.}}

\dothis{Abre el explorador y seleccione la herramienta package.
Selecciona \menu{create package}.\footnote{Estamos asumiendo que el explorador
de paquetes está instalado como el explorador por defecto, lo que
ocurre en casi todos los casos. Si el navagador que obtienes no se
ve similar al de \figref{addPackage}, entonces tal vez tienes que cambiar
el explorador por defecto. Mire \faqref{packagebrowser}.}}

\begin{figure}[htb]
\begin{minipage}[b]{0.48\textwidth}
\ifluluelse
	{\centerline {\includegraphics[width=0.9\textwidth]{AddPackage}}}
	{\centerline {\includegraphics[scale=0.7]{AddPackage}}}
	\caption{Agregando un paquete.
	\figlabel{addPackage}}
\end{minipage}
\hfill
\begin{minipage}[b]{0.48\textwidth}
\ifluluelse
	{\centerline {\includegraphics[width=0.8\textwidth]{ClassTemplate}}}
	{\centerline {\includegraphics[scale=0.6]{ClassTemplate}}}
	\caption{La plantilla de una clase.
	\figlabel{classTemplate}}
\end{minipage}
\end{figure}

% Type the name of the new package (we will use \scat{PBE-LightsOut}) in the
% dialog box and click \menu{accept} (or just press the return key); the new
% package is created, and positioned alphabetically in the list of packages.

Escriba el nombre del nuevo paquete (usaremos \scat{PBE-LightsOut}) en
el cuadro de dialogo y seleccionamos \menu{accept} (o solo pulsamos
la tecla enter); El nuevo paquete se ha creado, y se posiciona alfabeticamente
en la lista de paquetes.

%=================================================================
% \section{Defining the class LOCell}
\section{Definiendo la clase LOCell}

% As yet there are  of course no classes in the new package. However, the main
% editing pane displays a template to make it easy to create a new class (see
% \figref{classTemplate}).

Por supuesto, todavía no hay clases en el nuevo paquete. Aún así, el panel
principal de edición nos muestra una plantilla para hacer mas sencillo crear
una nueva clase (vea \figref{classTemplate}).



% This template shows us a \st expression that sends a message to a class called
% \ct{Object}, asking it to create a subclass called \ct{NameOfSubClass}.  The
% new class has no variables, and should belong to the category
% \scat{PBE-LightsOut}.

Esta plantilla nos nuestra una \st expression que senvía un mensaje a la clases
que se llama \ct{Object}, solicitandole que genere una subclase llamada
\ct{NameOfSubClass}. La nueva clase no tendrá variables, y deberá pertenecer
a la categoría \scat{PBE-LightsOut}.

% \subsection{On Categories and Packages}
\subsection{Sobre categorías y paquetes}
\seclabel{categoriesPackages}

% Historically, \st only knows about \emph{categories}, not packages.
% You may well ask, what is the difference?
% A category is simply a collection of related classes in a \st image.
% A \emph{package} is a collection of related classes \emph{and extension methods} that may be versioned using the Monticello versioning tool.
% By convention, package names and category names are the same.
% For most purposes we do not care about the difference, but we will be careful to use the correct terminology in this book since there are points where the difference is crucial.
% We will learn more when we start working with Monticello.
% \index{package}
% \index{category}

Historicamente, se trata sobre \emp{categorias}, no paquetes.
Entonces podrías preguntarte, ?`cual es la diferencia?
Una categoría es simplemente una collección de clases relacionanadas en
una \st imagen.
Un \emp{paquete} es una colleccion de clases relacionadas junto a
\emph{metodos de extensión} que podrían estar bajo un control de versiones
como Monticello.
Por convención, los nombres de paquetes y categorias son siempre los mismos.
En la mayoría de los casos no nos preocuparemos por las diferencias, pero
seremos cuidadosos en la terminología de este libro para utilizar la
denominación correcta, ya que hay puntos donde de la diferencia es crucial.
Aprenderemos mas sobre este tema cuando comencemos a trabajar con Monticello.
\index{package}
\index{category}


% \subsection{Creating a new class}
\subsection{Creating a new class}

Solamente modificaremos la plantilla para crear la clase que realmente queremos.

\dothis{Modifique la plantilla de creación de clase como sigue:}
\begin{itemize}
  \item Reemplace \clsind{Object} por \clsind{SimpleSwitchMorph}.
  \item Reemplace \ct{NameOfSubClass} por \clsind{LOCell}.
  \item Añada \ct{mouseAction} a la lista de variables de instancia.
\end{itemize}
El resultado devería parecerse a \clsref{firstClassDef}.

\needlines{5}
\begin{classdef}[firstClassDef]{Defining the class \ct| LOCell|}
SimpleSwitchMorph subclass: #LOCell
   instanceVariableNames: 'mouseAction'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'PBE-LightsOut'
\end{classdef}
\index{browser!defining a class}
\index{class!creation}
\index{Morphic}

% This new definition consists of a \st expression that sends a message to the
% existing class \ct{SimpleSwitchMorph}, asking it to create a subclass called
% \ct{LOCell}.  (Actually, since \ct{LOCell} does not exist yet, we passed as an
% argument the \emphind{symbol} \ct{#LOCell} which stands for the name of the
% class to create.) We also tell it that instances of the new class should have a
% \ct{mouseAction} instance variable, which we will use to define what action the
% cell should take if the mouse should click over it.

Esta nueva definición consiste de una expresión \st que envía un mensaje a la
clase existente \ct{SimpleSwitchMorph}, pidiéndole que cree una subclase llamada
\ct{LOCell}. (En realidad, como \ct{LOCell} no existe aún, se le pasa 
\emphind{symbol} \ct{#LOCell} como argumento, que indica el nombre de la clase a 
crear). También le indicamos que las instancias de la nueva clase deberían 
tener una instancia de variable de \ct{mouseAction}, que usaremos para definir
que acción debería tomar la celda si se hiciera click sobre esta.


% \emph{At this point you still have not created anything.}
% Note that the border of the class template pane has changed to red (\figref{acceptClassDef}).
% This means that there are \emph{unsaved changes}.
%WIP To actually send this message, you must \menu{accept} it.

\emph {Hasta el momento no has creado nada.}
Nota que el borde del panel de template de clase cambió a rojo (\figref{acceptClassDef}).
Esto significa que hay cambios \emph {sin guardar.}
Para enviar este mensaje, debes \menu {aceptarlo}. 
%ver que hace el \menu, para ver si 'aceptarlo' queda en ingles o castellano


%WIP \begin{figure}[h!t]
%WIP \ifluluelse
%WIP	 {\centerline {\includegraphics[width=\textwidth]{AcceptClassDef}}}
%WIP	 {\centerline {\includegraphics[scale=0.7]{AcceptClassDef}}}
%WIP \caption{The class-creation Template.
%WIP \figlabel{acceptClassDef}}
%WIP \end{figure}

\begin{figure}[h!t]
\ifluluelse
  {\centerline {\includegraphics[width=\textwidth]{AcceptClassDef}}}
  {\centerline {\includegraphics[scale=0.7]{AcceptClassDef}}}
\caption{Template de creación de clase.
\figlabel{acceptClassDef}}
\end{figure}

% \dothis{Accept the new class definition.}
% Either \actclick and select \menu{accept}, or use the shortcut \short{s} (for ``save'').
% The message will be sent to \ct{SimpleSwitchMorph}, which will cause the new class to be compiled.
%WIP \index{keyboard shortcut!accept}

\dothis{Aceptar la definición de la nueva clase.}
Esto se puede hacer de dos formas: o bien \actclicky selecciona \menu{accept}, o bien
usa el atajo \short{s} (para ``guardar'').
El mensaje será enviado a \ct{SimpleSwitchMorph}, causando que la nueva clase sea compilada.
\index{keyboard shortcut!accept} % <-- ver si hay que traducir esto.

% Once the class definition is accepted, the class will be created and appear in the classes pane of the browser (\figref{LOCell}).
% The editing pane now shows the class definition, and a small pane below it will remind you to write a few words describing the purpose of the class. This is called a \emph{class comment}, and it is quite important to write one that will give other programmers a high-level overview of the purpose of this class.
% Smalltalkers put a very high value on the readability of their code, and detailed comments in methods are unusual: the philosophy is that the code should speak for itself. (If it doesn't, you should refactor it until it does!) A class \subind{class}{comment} need not contain a detailed description of the class, but a few words describing its overall purpose are vital if programmers who come after you are to know whether to spend time looking at this class.
% \index{refactoring}

Una vez que la definición de la clase es aceptada, la clase será creada y aparecerá en el panel de clases del navegador (\figref{LOCell}).
Ahora el panel de edición muestra la definición de la clase, y un pequeño panel debajo te recordará escribir unas pocas palabras describiendo el propósito de la clase. Esto se llama \emph {comentario de la clase}. Es importante escribir un comentario que le de a otros programadores una visión de alto nivel del propósito de la clase.
Los desarrolladores Smalltalk le dan un gran valor a la legibilidad de su código, y es poco común entcontrar comentarios detallados dentro de los métodos: la filosofía de Smalltalk es que el código debe ser autoexplicativo. (Si no lo es, deberías refactorizarlo hasta que lo sea!) Una clase \subind{clase}{comentario} no debería contener una descripción detallada de la clase, pero unas pocas palabras que describan su propósito de manera general son vitales para que otros programadores sepan si vale la pena invertir tiempo en mirar la clase o no.
\index{refactoring} % <--ver si se traduce

%\dothis{Type a class comment for \ct{LOCell} and accept it; you can always improve it later.}
\dothis{Escribe un comentario de clase para \ct{LOCell} y guárdalo; siempre se puede mejorar mas tarde.}

\begin{figure}[h!t]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{LOCell}}}
	{\centerline {\includegraphics[scale=0.7]{LOCell}}}
\caption{La nueva clase creada \ct{LOCell}\figlabel{LOCell}}
\end{figure}


%=================================================================
%\section{Adding methods to a class}
\section{Agregando métodos a una clase}

%Now let's add some methods to our class.
Ahora agreguemos algunos métodos a nuestra clase.

% \dothis{Select the protocol \prot{-{}-all-{}-} in the protocol pane.}
% You will see a template for method creation in the editing pane.
% Select it, and replace it by the text of \mthref{scbecellinitialize}.
% \protindex{all}
% \index{method!creation}
% \index{browser!defining a method}

\dothis{Selecciona el protocolo \prot{-{}-todo-{}-} en el panel de protocolos.}
Verás un template para la creaciń de métodos en el panel de edición.
Selecciónalo y reemplazalo por el texto de \mthref{scbecellinitialize}.
\protindex{all}
\index{method!creation}
\index{browser!defining a method}


\needlines{10}
\begin{numMethod}[scbecellinitialize]{Initializing instances of \ct{LOCell}}
initialize
   super initialize.
   self label: ''.
   self borderWidth: 2.
   bounds := 0@0 corner: 16@16.
   offColor := Color paleYellow.
   onColor := Color paleBlue darker.
   self useSquareCorners.
   self turnOff
\end{numMethod}
\index{initialization}

%\noindent
% Note that the characters \ct{''} on line 3 are two separate single quotes with nothing between them, not a double quote!  \ct{''} denotes the empty string.

\noindent
Notar que los caracteres \ct{''} en la línea 3 son comillas simples sin nada en el medio, no una doble comilla. \ct{''} es una cadena de caracteres vacía. 

%\dothis{\menu{Accept} this method definition.}

\dothis{\menu{Aceptar} la definición de este método.}

%What does the above code do?  We won't go into all of the details here (that's what the rest of the book is for!), but we will give you a quick preview.  Let's take it line by line.

?`Qué hace el código de arriba? No nos adentraremos en los detalles aquí (para eso es el resto del libro!), pero te daremos una rápida introducción. Veámoslo línea por línea.
\fede{una mejor traducción para 'a quick preview'?}

%Notice that the method is called \mthind{LOCell}{initialize}.
%The name is very significant!
%By convention, if a class defines a method named \ct{initialize}, it will be called right after the object is created.
%So, when we evaluate \ct{LOCell new}, the message \ct{initialize} will be sent automatically to this newly created object.
%Initialize methods are used to set up the state of objects, typically to set their instance variables; this is exactly what we are doing here.
%\seeindex{Object!initialization}{initialization}
%\index{initialization}

Notar que el método se llama \mthind{LOCell}{initialize}.
El nombre es muy significativo!
Por convención, si una clase define un método llamado \ct{initialize}, este será llamado inmediatamente después que el objeto sea creado. 
Entonces, cuando evaluamos \ct{LOCell new}, el mensaje \ct{initialize} será enviado automáticamente al objeto recién creado. 
Los métodos "initialize" se usan para establecer el estado de los objetos, normalmente para establecer las variables de instancia; esto es exactamente lo que estamos haciendo acá. 
\seeindex{Object!initialization}{initialization}
\index{initialization}

% The first thing that this method does (line 2) is to execute the \ct{initialize} method of its superclass, \ct{SimpleSwitchMorph}.
% The idea here is that any inherited state will be properly initialized by the \ct{initialize} method of the superclass.
% It is always a good idea to initialize inherited state by sending \ct{super initialize} before doing anything else; we don't know exactly what \ct{SimpleSwitchMorph}'s \ct{initialize} method will do, and we don't care, but it's a fair bet that it will set up some instance variables to hold reasonable default values, so we had better call it, or we risk starting in an unclean state.

Lo primero que hace este método (línea 2) es ejecutar el método \ct{initialize} de su superclase, \ct{SimpleSwitchMorph}.
% Superclass lo traducimos como superclase o como clase padre o como? <----
El objetivo de esto es que cualquier estado heredado sea inicializado adecuadamente por el método \ct{initialize} de la superclase.
Siempre es buena idea inicializar estado heredado enviando el mensaje \ct{super initialize} antes de hacer cualquier otra cosa; no sabemos exactamente que hará el método \ct{initialize} de \ct{SimpleSwitchMorph}, y no nos importa, pero seguramente inicializará algunas variables de instancia para que contengan valores razonables, por lo que es mejor invocarlo para no arriesgarse a que los objetos empiecen en un estado inválido.

% The rest of the method sets up the state of this object.
% Sending \ct{self label: ''}, for example, sets the label of this object to the empty string.
% \pvindex{self}

El resto del método establece el estado del objeto.
Enviar el mensaje \ct{self label: ''}, por ejemplo, establece la etiqueta de este objeto a la cadena de caracteres vacía.
\pvindex{self}

% The expression \ct{0@0 corner: 16@16} probably needs some explanation. 
% \lct{0@0} represents a \clsind{Point} object with $x$ and $y$ coordinates both set to 0.
% In fact, \ct{0@0} sends the message \ct{@}

La expresión \ct{0@0 corner: 16@16} probablemente necesite un poco de explicación.
\lct{0@0} representa un objeto \clsind{Point} con las coordenadas $x$ e $y$ en 0.
De hecho, \ct{0@0} envía el mensaje \ct{@}

% Yuck... the following should be \mthind{Number}{@} 
%%% THIS IS BROKEN -- don't do it! (on)
%\def\atsign{\textsf{@}}%
%{\makeatletter
%	\protected@write\@indexfile{}%
%    {\string\indexentry{\string\atsign|see{Number, \string\atsign}}{\thepage}}%
%	\protected@write\@indexfile{}%
%    {\string\indexentry{Number!\string\atsign|hyperpage}{\thepage}}%
%	\makeatother}

% to the number \ct{0} with argument \ct{0}.
% The effect will be that the number \ct{0} will ask the \ct{Point} class to create a new instance with coordinates (0,0).
% Now we send this newly created point the message \ct{corner: 16@16}, which causes it to create a \clsind{Rectangle} with corners \ct{0@0} and \ct{16@16}.
% This newly created rectangle will be assigned to the \ct{bounds} variable, inherited from the superclass.

al número \ct{0} con parámetro \ct{0}.
El efecto será que el número \ct{0} le pedirá a la clase \ct{Point} que cree una nueva instancia con coordenadas (0,0).
Ahora le enviamos a este nuevo punto el mensaje \ct{corner: 16@16}, que hace que cree un \clsind{Rectangle} con esquinas \ct{0@0} y \ct{16@16}.
Este nuevo rectángulo será asignado a la variable \ct{bounds}, heredada de la superclase. 

% Note that the origin of the \pharo screen is the \emph{top left}, and the $y$ coordinate increases \emph{downwards}.
Nota que el orígen de la pantalla de \pharo es la \emph{esquina izquierda}, y la coordenada $y$ se incrementa hacia \emph{abajo}.

% The rest of the method should be self-explanatory.
% Part of the art of writing good \st code is to pick good method names so that \st code can be read like a kind of pidgin English.
% You should be able to imagine the object talking to itself and saying ``\ct{Self use square corners!}'', ``\ct{Self turn off!}''.

El resto del método debería ser auto explicativo. 
Parte de arte de escribir buen código \st es escoger los nombres adecuados para los métodos para que el código pueda ser leido como una especie de inglés macarrónico. 
Deberías poder imaginar al objeto hablandose a sí mismo y diciendo ``\ct{Self use square corners!}'', ``\ct{Self turn off}''.

%=================================================================
% \section{Inspecting an object}
\section{Inspeccionando un objeto}

% You can test the effect of the code you have written by creating a new \ct{LOCell} object and inspecting it.
Puedes probar el efecto del código que acabas de escribir creando un nuevo objeto \ct{LOCell} y luego inspeccionándolo. 

% \dothis{Open a workspace. Type the expression \ct{LOCell new} and \menu{inspect it}.}
\dothis{Abre un workspace. Tipea la expresión \ct{LOCell new} y \menu{inspect it}.}

%\begin{figure}[htbp]
%   \centering
%   \includegraphics[width=\textwidth]{LOCellInspector} 
%   \caption{The inspector used to examine a LOCell object.\figlabel{LOCellInspector}}
%\end{figure}

\begin{figure}[htbp]
   \centering
   \includegraphics[width=\textwidth]{LOCellInspector} 
   \caption{El inspector usado para examinar un objeto LOCell.\figlabel{LOCellInspector}}
\end{figure}

% The left-hand pane of the \ind{inspector} shows a list of instance variables; if you select one (try \mbox{\ct{bounds}),} the value of the \ind{instance variable} is shown in the right pane.

El panel izquierdo de \ind{inpector} muestra una lista de variables de instancia; si seleccionas una (prueba \mbox{\ct{bounds}}), el valor de la \ind{variable de instancia} se muestra en el panel derecho. 

%--- Codigo que ya estaba comentado, no figura en la version original ---%
%  You can also use the inspector to change the value of an instance variable.
%\dothis{Change the value of \ct{bounds} to \ct{0@0 corner: 50@50} and \menu{accept} it.}
%\on{This does not work any more. I get:}
%\ct{OTNamedVariableNode(Object)>>doesNotUnderstand: #selectedClass}
%\on{should use the mini workspace instead to send bounds: ?}

% The bottom pane of the inspector is a mini-workspace.  It's useful because in this workspace the pseudo-variable \self is bound to the object selected. 
El panel inferior del inspector es un mini-workspace. Es muy útil porque en este workspace la pseudo variable \self está ligada al objeto seleccionado.

% \dothis{
% Select the LOCell at the root of the inspector window.
% Type the text \ct{self bounds: (200@200 corner: 250@250)} in the bottom pane and \menu{do it}. The \ct{bounds} variable should change in the inspector.
% Now type the text \ct{self openInWorld} in the mini-workspace and \menu{do it}.}
% The cell should appear near the top left-hand corner of the screen, indeed, exactly where its \ct{bounds} say that it should appear.
% \metaclick on the cell to bring up the morphic \subind{Morphic}{halo}.
% Move the cell with the brown (next to top-right) handle and resize it with the yellow (bottom-right) handle.
% Notice how the bounds reported by the inspector also change.
% (You may have to \actclick{} \menu{refresh} to see the new bounds value.)

\dothis{
Selecciona LOCell en la raíz de la ventana del inspector.
Tipea el texto \ct{self openInWorld} en el mini-workspace y \menu{do it}.}
La celda debería aparecer cerca de la esquina superior izquierda de la pantalla, exactamente donde sus \ct{límites} dicen que debería aparecer. 
\metaclick en la celda para que aparezca el halo de Morphic \subind{Morphic}. %% <---verificar
Mueve la celda con el asa marrón (esquina superior derecha) y redimensiónalo con el asa amarilla (abajo a la derecha).
Nota como los límites reportados por el inspector también cambian. 
(Tal vez tengas que \actclick{} \menu{refresh} para ver los nuevos valores de los límites.)

% \begin{figure}[htbp]
% \centering
% \ifluluelse
% 	{\includegraphics[width=\textwidth]{LOCellResize} }
% 	{\includegraphics[scale=0.7]{LOCellResize} }
% \caption{Resizing the cell.\figlabel{cellresize}}
% \end{figure}

% \dothis{Delete the cell by clicking on the \ct{x} in the pink handle.}

\begin{figure}[htbp]
\centering
\ifluluelse
	{\includegraphics[width=\textwidth]{LOCellResize} }
	{\includegraphics[scale=0.7]{LOCellResize} }
\caption{Redimensiona la celda.\figlabel{cellresize}}
\end{figure}

\dothis{Borra la celda haciendo click en la \ct{x} en el asa rosa.}

%=================================================================
% \section{Defining the class LOGame}
\section{Definiendo la clase LOGame}

% Now let's create the other class that we need for the game, which we will call \clsind{LOGame}.
Ahora creemos la otra clase que necesitamos para el juego, que llamaremos \clsind{LOGame}.

% \dothis{Make the class definition template visible in the browser main window.}
% Do this by clicking on the package name.
% Edit the code so that it reads as follows, and \menu{accept} it.

\dothis{Has visible el template de definici\'on de clases en la ventana principal del navegador.}
Has esto haciendo click en el nombre del paquete.
Edita el c\'odigo para que quede como se muestra a continuaci\'on, y has \menu{accept}.

\needlines{6}
\begin{classdef}[sbegame]{Defining the \ct{LOGame} class}
BorderedMorph subclass: #LOGame
   instanceVariableNames: ''
   classVariableNames: ''
   poolDictionaries: ''
   category: 'PBE-LightsOut'
\end{classdef}

% Here we subclass \clsind{BorderedMorph}; \clsind{Morph} is the superclass of all of the graphical shapes in \pharo, and (surprise!) a \ct{BorderedMorph} is a \ct{Morph} with a border.  
% We could also insert the names of the instance variables between the quotes on the second line, but for now, let's just leave that list empty.

Aqu\'i creamos una subclase de \clsind{BorderedMorph}; \clsind{Morph} es la superclase de todas las formas gr\'aficas e \pharo, y(sorpresa!) un \ct{BorderedMorph} es un \ct{Morph} con borde.
Podr\'iamos insertar los nombres de las variables de instancia entre comillas en la segunda l\'inea pero, por ahora, dejemos esa lista vac\'ia.

% Now let's define an \mthind{LOGame}{initialize} method for \ct{LOGame}.
Ahora definamos un m\'etodo \mthind{LOGame}{initialize} para \ct{LOGame}.

% \dothis{Type the following into the browser as a method for \ct{LOGame} and try to \menu{accept} it:}
\dothis{Escribe lo siguiente en el navegador como un m\'etodo para \ct{LOGame} e intenta \menu{accept}:}

\begin{numMethod}[sbegameinitialize]{Initializing the game}
initialize
   | sampleCell width height n |
   super initialize.
   n := self cellsPerSide.
   sampleCell := LOCell new.
   width := sampleCell width.
   height := sampleCell height.
   self bounds: (5@5 extent: ((width*n) @(height*n)) + (2 * self borderWidth)).
   cells := Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ].
\end{numMethod}

%\sd{it would be nicer if we would not have to create an instance of LOCell for nothing}
%\on{yes}

% \pharo will complain that it doesn't know the meaning of some of the terms.
% \pharo tells you that it doesn't know of a message \ct{cellsPerSide}, and suggests a number of corrections, in case it was a spelling mistake.

\pharo se quejar\'a de que no conoce el significado de ciertos t\'erminos.
\pharo dice que no conoce un mensaje \ct{cellsPerSide}, y sugiere algunas correcciones, en caso de que haya sido un error de tipeo.

\begin{figure}[htb]
\begin{minipage}{0.48\textwidth}
	\centering
	\ifluluelse
		{\includegraphics[width=\textwidth]{UnknownSelector}}
		{\includegraphics[scale=0.7]{UnknownSelector}}
%	\caption{\pharo detecting an unknown selector.\figlabel{unknownSelector}}
 \caption{\pharo detectando un identificador desconocido.\figlabel{unknownSelector}}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
	\centering
	\ifluluelse
		{\includegraphics[width=\textwidth]{DeclareInstanceVar}}
		{\includegraphics[scale=0.7]{DeclareInstanceVar}}
%	\caption{Declaring a new instance variable.\figlabel{declareInstance}}
	\caption{Declarando una nueva variable de instancia.\figlabel{declareInstance}}
\end{minipage}
\end{figure}

% But \ct{cellsPerSide} is not a mistake\,---\,it is just a method that we haven't yet defined\,---\,we will do so in a minute or two.
Pero \ct{cellsPerSide} no es un error\,---\, es solo un m\'etodo que no hemos definido aun\,---\, lo haremos en un momento.

% \dothis{So just select the first item from the menu, which confirms that we really meant \ct{cellsPerSide}.}
\dothis{Selecciona el primer item del men\'u, que confirma que quisimos escribir \ct{cellsPerSide}.}

% Next, \pharo will complain that it doesn't know the meaning of \ct{cells}.  It offers you a number of ways of fixing this.
A continuaci\'on, \pharo se quejar\'a de que no conoce el significado de \ct{cells}. Te ofrece un n\'umero de formas de arreglar esto. 

% \dothis{Choose \menu{declare instance} because we want \ct{cells} to be an instance variable.}
% Finally, \pharo will complain about the message \ct{newCellAt:at:} sent on the last line; this is also not a mistake, so confirm that message too.
% \index{on the fly variable definition}
% \index{instance variable definition} 

\dothis{Elige \menu{declare instance} porque queremos que \ct{cells} sea una variable de instancia.}
Finalmente, \pharo se quejar\'a del mensaje \ct{newCellAt:at:} en la \'ultima l\'inea; esto tampoco es un error, asi que debes confirmar ese mensaje tambi\'en.
\index{definici\'on de variable al vuelo} 
%FR "al vuelo" me pareció lo mejor para "on the fly"
\index{definici\'on de variable de instancia}

% If you now look at the class definition once again (which you can do by clicking on the \button{instance} button), you will see that the browser has modified it to include the instance variable \ct{cells}.

Si miras ahora a la definici\'on de la clase de nuevo (cosa que puedes hacer haciendo click en el bot\'on \button{nstance}), ver\'as que el navegador la modific\'o para incluir la variable de instancia \ct{cells}.

% Let's look at this \ct{initialize} method.
% The line \ct{| sampleCell width height n |}  declares 4 temporary variables. They are called temporary variables because their scope and lifetime are limited to this method.  Temporary variables with explanatory names are helpful in making code more readable.  Smalltalk has no special syntax to distinguish constants and variables, and in fact all four of these ``variables'' are really constants. 
% Lines 4--7 define these constants.
Miremos ahora al m\'etodo \ct{initialize}.
La l\'inea \ct{| sampleCell width height n |} declara 4 variables temporales. Son llamadas temporarias porque su \'ambito y tiempo de vida son limitados a este m\'etodo. Las variables temporales con nombres explicativos ayudan a hacer el c\'odigo mas legible. SMalltalk no tiene sintaxis especial para distinguir constantes y variables, y en realidad estas cuatro ``variables'' son en realidad constantes.
Las l\'ineas 4--7 definen estas constantes.

% How big should our game board be?  Big enough to hold some integral number of cells, and big enough to draw a border around them.
% How many cells is the right number?  5? 10? 100? We don't know yet, and if we did, we would probably change our minds later.  So we delegate the responsibility for knowing that number to another method, which we will call \ct{cellsPerSide}, and which we will write in a minute or two.
% It's because we are sending the \ct{cellsPerSide} message before we define a method with that name that \pharo asked us to ``confirm, correct, or cancel'' when we accepted the method body for \ct{initialize}.
% Don't be put off by this: it is actually good practice to write in terms of other methods that we haven't yet defined.
% Why?  Well, it wasn't until we started writing the \ct{initialize} method that we realized that we needed it, and at that point, we can give it a meaningful name, and move on, without interrupting our flow.
?`Qu\'e tan grande deber\'ia ser nuestro tablero de juego? Lo suficientemente grande como para almacenar algun n\'umero entero de celdas, y lo suficientemente grande como para dibujar un borde alrededor de ellas.
?`Cu\'al ser\'ia el n\'umero correcto de celdas? ?`5? ?`10? ?`100? No sabemos a\'un, y si supi\'eramos, probablemente cambiar\'iamos de parecer luego. As\'i que delegamos la responsabilidad de saber ese n\'umero a otro m\'etodo, que llamaremos \ct{cellsPerSide}, y que escribiremos en un momento.
Es porque estamos enviando el mensaje \ct{cellsPerSide} antes de definirlo que \pharo nos pidi\'o ``confirmar, corregir o cancelar'' cuando aceptamos el cuerpo del m\'etodo \ct{initialize}.
No te desanimes por esto: es en realidad una buena pr\'actica escribir en t\'erminos de m\'etodos que no hemos definido a\'un.
?`Por que? No fu\'e hasta que empezamos a escribir el m\'etodo \ct{initialize} que nos dimos cuenta que lo necesit\'abamos, y en ese momento, podemos darle un nombre significativo, y seguir adelante, sin interrumpir el flujo.
 
% The fourth line uses this method: 
% the Smalltalk \ct{self cellsPerSide} sends the message \ct{cellsPerSide} to \pvind{self}, i.e., to this very object.  
% The response, which will be the number of cells per side of the game board, is assigned to \ct{n}.
La cuarta l\'inea usa este m\'etodo:
El c\'odigo Smalltalk \ct{self cellsPerSide} env\'ia el mensaje \ct{cellsPerSide} a \pvind{self}, es decir, a este mismo objeto.
La respuesta, que ser\'a el n\'umero de celdas por lado del tablero de juego, es asignado a \ct{n}.

% The next three lines create a new \ct{LOCell} object, and assign its width and height to the appropriate temporary variables. 
Las siguientes tres l\'ineas crean un nuevo objeto \ct{LOCell}, y asignan su ancho y alto a las variables temporales adecuadas. 

%**** CODIGO COMENTADO EN LA VERSION ORIGINAL ****%
%The eighth line sends the message \ct{bounds:} to \self.
%\ct{bounds:} is a method that we inherit from our superclass; it is used to define the space on the screen that this Morph will occupy.  
%The single colon (\ct{:}) at the end of the name says that \ct{bounds:} expects a single parameter, which should be a rectangle object.
%**** FIN CODIGO COMENTADO ****%

% Line 8 sets the \ct{bounds} of the new object.
% Without worrying too much about the details just yet, just believe us that the expression in parentheses creates a square with its origin (\ie its top-left corner) at the point (5,5) and its bottom-right corner far enough away to allow space for the right number of cells.
La l\'inea 8 establece los \ct{l\'imites} del nuevo objeto.
Sin preocuparte mucho por los detalles ahora, conf\'ia en que la expresi\'on entre par\'entesis crea un cuadrado con or\'igen (\ie esquina superior izquierda) en el punto (5,5) y su esquina inferior derecha lo suficientemente lejos como para dar espacio al n\'umero correcto de celdas.

% The last line sets the \ct{LOGame} object's instance variable \ct{cells} to a newly created \clsind{Matrix} with the right number of rows and columns.   We do this by sending the message \ct{new:tabulate:} to the \ct{Matrix} class (classes are objects too, so we can send them messages).  We know that \mthind{Matrix class}{new:tabulate:} takes two arguments because it has two colons (\ct{:}) in its name.   The arguments go right after the colons.
% If you are used to languages that put all of the arguments together inside parentheses, this may seem weird at first.  Don't panic, it's only syntax!
% It turns out to be a very good syntax because the name of the method can be used to explain the roles of the arguments.  For example, it is pretty clear that \ct{Matrix rows: 5 columns: 2} has 5 rows and 2 columns, and not 2 rows and 5 columns.
% \cmindex{Matrix class}{rows:columns:}
La \'ultima l\'inea establece la variable de instancia \ct{cells} del el objeto \ct{LOGame} a una recien creada \clsind{Matrix} con el correcto n\'umero de filas y columnas. Hacemos esto enviando el mensaje \ct{new:tabulate:} a la clase \ct{Matrix} (las clases son objetos tambi\'en, por lo que les podemos enviar mensajes). Sabemos que \mthind{Matrix class}{new:tabulate} espera dos par\'ametros porque tiene dos s\'imbolos \ct{:} en su nombre. Los par\'ametros van justo despues de los s\'imbolos ':'.
Si est\'as acostumbrado a lenguajes que ponen todos los argumentos juntos dentro de par\'entesis, esto puede parecer raro al principio. !`No entres en p\'anico, es solo sintaxis!
Resulta que es una muy buena sintaxis porque el nombre de un m\'etodo puede ser usado para explicar los roles de los argumentos. Por ejemplo, es bastante claro que \ct{Matrix rows: 5 columns: 2} tiene 5 filas y 2 columnas, y no 2 filas y 5 columnas. 

\cmindex{Matrix class}{rows:columns:}

% \ct{Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]} creates a new \ct{n}{$\times$}\ct{n} matrix and initializes its elements.  The initial value of each element will depend on its coordinates.  The \ct{(i,j)}\textsuperscript{th} element will be initialized to the result of evaluating \ct{self newCellAt: i at: j}.  
\ct{Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]} crea una nueva matriz de \ct{n}{$\times$}\ct{n} e inicializa sus elementos. El valor inicial de cada elemento depender\'a de sus coordenadas.  El \ct{(i,j)}-\'esimo elemento ser\'a inicializado al resultado de evaluar \ct{self newCellAt: i at: j}.

%:===> Pretty-print is broken! (how to pretty-print?)

% \on{I think it is silly to copy paste from the pretty-print view to the normal view}

%**** CODIGO COMENTADO EN LA VERSION ORIGINAL ****%
%That's \ct{initialize}.  When you accept this message body, you might want to take the opportunity to pretty-up the formatting.  You don't have to do this by hand: from the \actclick menu select \menu{more \ldots \go prettyprint}, and the browser will do it for you\damien{this didn't do anything to me}.  You have to \menu{accept} again after you have \subind{method}{pretty-print}{}ed a method, or of course you can \subind{keyboard shortcut}{cancel} 
%(\short{l}\,---\,that's a lower-case letter \emph{L}) if you don't like the result.
%Alternatively, you can set up the browser to use the pretty-printer automatically whenever it shows you code: use the the right-most button in the button bar to adjust the view.
%\seeindex{pretty-print}{method}

%If you find yourself using \menu{more\,\ldots} a lot, it's useful to know that you can hold down the {\sc shift} key when you click to directly bring up the \menu{more \ldots} menu.
%**** FIN CODIGO COMENTADO ****%

%=================================================================
% \section{Organizing methods into protocols}
\section{Organizando m\'etodos en protocolos}

% Before we define any more methods, let's take a quick look at the third pane at the top of the browser.
% In the same way that the first pane of the browser lets us categorize classes into packages so we are not overwhelmed by a very long list of class names in the second pane, so the third pane lets us categorize methods so that we are not overwhelmed by a very long list of method names in the fourth pane.   
% These categories of methods are called ``protocols''.
% \index{protocol}
Antes de definir m\'as m\'etodos, demos una r\'apida mirada al tercer panel en la parte superior del navegador. 
De la misma manera que el primer panel del navegador nos permite categorizar clases en paquetes para que no nos sintamos abrumados por una larga lista de nombres de clases en el segundo panel, el tercer panel nos permite categorizar m\'etodos para que no nos sintamos abrumados por una larga lista de nombres de m\'etodos en el cuarto panel.
Estas categor\'ias de m\'etodos se llaman ``protocolos''.
\index{protocolo}

% If there are only a few methods in a class, the extra level of hierarchy provided by protocols is not really necessary.
% This is why the browser also offers us the \prot{-{}-all-{}-} virtual protocol, which, you will not be surprised to learn, contains all of the methods in the class.
% \protindex{all}
Si s\'olo hay unos pocos m\'etodos en la clase, el nivel extra de jerarqu\'ia provisto por los protocolos no es realmente necesario.
Esta es la raz\'on por la que el navegador tambi\'en nos ofrece el protocolo virtual \prot{-{}-all-{}-}, que, como no te sorprender\'a, contiene todos los m\'etodos de la clase.
\protindex{all}

\begin{figure}[htbp]
   \centering
   \includegraphics[width=\textwidth]{Categorize} 
   %\caption{Automatically categorize all uncategorized methods.\figlabel{categorize}}
   \caption{Catergoriza autim\'aticamente todos los m\'etodos sin categorizar.\figlabel{categorize}}
\end{figure}

% If you have followed along with this example, the third pane may well contain the protocol \protind{as yet unclassified}.
Si has seguido este ejemplo, el tercer panel bien podr\'ia contener el protocolo \protind{as yet unclassified}.

% \dothis{\Actclick in the protocol pane and select \menu{various \go categorize automatically} to fix this, and move the \ct{initialize} methods to a new protocol called \protind{initialization}.}
% How does \pharo{} know that this is the right protocol?  Well, in general \pharo{} can't know, but in this case there is also an \ct{initialize} method in a superclass, and \pharo assumes that our \ct{initialize} method should go in the same category as the one that it overrides.
% \index{method!categorize}
\dothis{\Actclick en el panel de protocolo y selecciona \menu{various \go categorize automatically} para arreglar esto, y mueve los m\'etodos \ct{initialize} a un nuevo protocolo llamado \protind{initialization}.}
?`Como sabe \pharo que este es el protocolo correcto? Bueno, en general  \pharo{} no puede saber, pero en este caso tambi\'en hay un m\'etodo \ct{initialize} en una superclase, y \pharo asume que nuestro m\'etodo \ct{initialize deber\'ia ir en la misma categor\'ia que el que est\'a sobreescribiendo. 
\index{method!categorize}

%*** CODIGO COMENTADO EN LA VERSION ORIGINAL ***%
%You may find that \pharo has already put your \ct{initialize} method into the \protind{initialization} protocol.
%If so, it's probably because you have loaded a package called \ct{AutomaticMethodCategorizer} into your image.
%*** FIN CODIGO COMENTADO EN LA VERSION ORIGINAL ***%

% \paragraph{A typographic convention.} Smalltalkers frequently use the notation ``\verb|>>|'' to identify the class to which a method belongs, so, for example, the \ct{cellsPerSide} method in class \ct{LOGame} would be referred to as \ct{LOGame>>cellsPerSide}.
% To indicate that this is \emph{not} \st syntax, we will use the special symbol \ct{>>>} instead, so this method will appear in the text as \ct{LOGame>>>cellsPerSide}
% \cmindex{Behavior}{>>}
\paragraph{Convenci\'on tipogr\'afica.} Los programadors Smalltalk usan con frecuencia la notaci\'on ``\verb|>>|'' para identificar la clase a la que pertenece un m\'etodo. Por ejemplo, el m\'etodo \ct{cellsPerSide} en la clase \ct{LOGame} ser\'ia referenciado como \ct{LOGame>>cellsPerSide}.
Para indicar que esto \emph{no es} sintaxis \st, usaremos en su lugar el s\'imbolo especial \ct{>>>}, con lo que el m\'etodo en el texto aparecer\'a como \ct{LOGame>>>cellsPerSide}.
\cmindex{Behavior}{>>}

% From now on, when we show a method in this book, we will write the name of the method in this form.  Of course, when you actually type the code into the browser, you don't have to type the class name or the \ct{>>>}; instead, you just make sure that the appropriate class is selected in the class pane.  
De ahora en adelante, cuando mostremos un m\'etodo en este libro, escribiremos el nombre del m\'etodo en esta forma. Por supuesto, cuando escribas el c\'odigo en el navegador, no tendr\'as que escribir el nombre del a clase ni \ct{>>>}; solo aseg\'urate de que la clase correcta est\'a seleccionada en el panel de clases. 


% Now let's define the other two methods that are used by the \ct{LOGame>>>initialize} method. Both of them can go in the \prot{initialization} protocol.
Ahora definamos los otros dos m\'etodos que son usados por el m\'etodo \ct{LOGame>>>initialize}. Ambos pueden ir dentro del protocolo \prot{initialization}.

% \begin{method}[sbegamecellsperside]{A constant method.}
\begin{method}[sbegamecellsperside]{Un m\'etodo constante.}
LOGame>>>cellsPerSide
   %"The number of cells along each side of the game"
   "El n\'umero de celdas a cada lado del juego"
   ^ 10
\end{method}
\cmindex{LOGame}{cellsPerSide}
\index{constant methods}

% This method could hardly be simpler: it answers the constant 10.  One advantage of representing constants as methods is that if the program evolves so that the constant then depends on some other features, the method can be changed to calculate this value.
Este m\'etodo no podr\'ia ser mas simple: responde con la constante 10. Una ventaja de representar constantes con m\'etodos es que si el programa evoluciona de manera que la constante depende de otras caracter\'isticas, el m\'etodo puede ser cambiado para calcular el nuevo valor. 

\needlines{10}
%\begin{method}[newCellAt:at:]{An initialization helper method}
\begin{method}[newCellAt:at:]{Un m\'etodo de inicializaci\'on}
LOGame>>>newCellAt: i at: j
   % "Create a cell for position (i,j) and add it to my on-screen
   % representation at the appropriate screen position.  Answer the new cell"
   "Crea una celda para la posici'on (i,j) y la agrega a la representacion
   en la pantalla en la posici\'on adecuada de la pantalla. Devuelve la nueva celda"
   | c origin |
   c := LOCell new.
   origin := self innerBounds origin.
   self addMorph: c.
   c position: ((i - 1) * c width) @ ((j - 1) * c height) + origin.
   c mouseAction: [self toggleNeighboursOfCellAt: i at: j]
\end{method}
\cmindex{LOGame}{newCellAt:at:}
%   ^ c      "omit this final line to create a bug"

% \dothis{Add the methods \ct{LOGame>>>cellsPerSide} and \ct{LOGame>>>newCellAt:at:}.}
% Confirm the spelling of the new selectors \ct{toggleNeighboursOfCellAt:at:} and \ct{mouseAction:}.
\dothis{Agrega los m\'etodos \ct{LOGame>>>cellsPerSide} y \ct{LOGame>>>newCellAt:at:}.}
Confirma la pronunciaci\'on de los nuevos m\'etodos \ct{toggleNeighboursOfCellAt:at:} y \ct{mouseAction:}.

% \Mthref{newCellAt:at:} answers a new LOCell, specialized to position \ct{(i, j)} in the \clsind{Matrix} of cells.
% The last line defines the new cell's \ct{mouseAction} to be the \emph{block}
% \mbox{\lct{[self toggleNeighboursOfCellAt: i at: j ]}.}
% In effect, this defines the callback behaviour to perform when the mouse is clicked.
% The corresponding method also needs to be defined.
\Mthref{newCellAt:at:} devuelve una nueva LOCell, especializada en la posici\'on \ct{(i,j)} en la \clsind{Matriz} de celdas.
La \'ultima l\'inea define el \ct{mouseAction} de la nueva celda como el \emph{bloque}
\mbox{\lct{[self toggleNeighboursOfCellAt: i at: j ]}.}
En efecto, esto define el comportamiento callback cuando se hace click con el rat\'on. 
El m\'etodo correspondiente tambi\'en tiene que ser definido. 

\begin{method}[toggleNeighboursOfCellAt:at:]{The callback method}
LOGame>>>toggleNeighboursOfCellAt: i at: j
   (i > 1) ifTrue: [ (cells at: i - 1 at: j ) toggleState].
   (i < self cellsPerSide) ifTrue: [ (cells at: i + 1 at: j) toggleState].
   (j > 1) ifTrue: [ (cells at: i  at: j - 1) toggleState].
   (j < self cellsPerSide) ifTrue: [ (cells at: i at: j + 1) toggleState].
\end{method}
\cmindex{LOGame}{toggleNeighboursOfCellAt:at:}

% \Mthref{toggleNeighboursOfCellAt:at:} toggles the state of the four cells to the north, south, west and east of cell (\ct{i}, \ct{j}).  The only complication is that the board is finite, so we have to make sure that a neighboring cell exists before we toggle its state.
\Mthref{toggleNeighboursOfCellAt:at:} cambia el estado de las cuatro celdas al norte, sur, este y oeste de una celda (\ct{i}, \ct{j}). La \'unica complicaci\'on es que el tablero es finito, por lo que tenemos que asegurarnos que las celdas vecinas existen antes que cambiemos su estado. 

% \dothis{Place this method in a new protocol called \prot{game logic}. (\Actclick in the protocol pane to add a new protocol.)}
% To move the method, you can simply click on its name and drag it to the newly-created protocol (\figref{dragMethod}).
\dothis{Coloca este m\'etodo en un nuevo protocolo llamado \prot{game logic}. (\Actclick en el panel de protocolo para agregar un nuevo protocolo.)}
Para mover el m\'etodo, puedes hacer click en su nombre y arrastrarlo dentro del nuevo protocolo (\figref{dragMethod}).

\begin{figure}[htbp]
   \centering
   \ifluluelse
		{\includegraphics[width=\textwidth]{DragMethod} }
		{\includegraphics[scale=0.7]{DragMethod} }
   % \caption{Drag a method to a protocol.\figlabel{dragMethod}}
   \caption{Arrastra un m\'etodo a un protocolo.\figlabel{dragMethod}}
\end{figure}

% To complete the Lights Out game, we need to define two more methods in class \ct{LOCell} to handle mouse events.
Para completar el juego Lights Out, necesitamos definir dos m\'etodos mas en la clase \ct{LOCell} para manejar los eventos del rat\'on.
% \begin{method}[mouseAction:]{A typical setter method}
\begin{method}[mouseAction:]{Un m\'etodo setter t\'ipico}
LOCell>>>mouseAction: aBlock
   ^ mouseAction := aBlock
\end{method}
\cmindex{LOCell}{mouseAction:}

% \Mthref{mouseAction:} does nothing more than set the cell's \ct{mouseAction} variable to the argument, and then answers the new value.
\Mthref{mouseAction:} no hace nada mas que establecer la variable \ct{mouseAction} de la celda al argumento, y luego retorna el nuevo valor.

% Any method that \emph{changes} the value of an instance variable in this way is called a \emph{setter method}; a method that \emph{answers} the current value of an instance variable is called a \emph{getter method}.
Cualquier m\'etodo que \emph{cambie} el valor de una variable de instancia de esta manera se llama \emph{m\'etodo setter}; un m\'etodo que \emph{retorna} el valor actual de una variable de instancia se llama \emph{m\'etodo getter}.
\seeindex{setter method}{accessor}
\seeindex{getter method}{accessor}

% If you are used to getters and setters in other programming languages, you might expect these methods to be called \ct{setmouseAction} and \ct{getmouseAction}.
Si est\'as acostumbrado a los getters y setters en otros lenguajes, podr\'ias esperar que estos m\'etodos se  llamen \ct{setmouseAction} and \ct{getmouseAction}.
% The \st convention is different.
%A getter always has the same name as the variable it gets, and a setter is named similarly, but with a trailing ``\ct{:}'', hence \ct{mouseAction} and \ct{mouseAction:}.
La convenci\'on \st es diferente. 
Un getter siempre tiene el mismo nombre que la variable que devuelve, y un setter siempre es llamado de manera similar, pero con un ``\ct{:}'' al final, por lo que queda \ct{mouseAction} and \ct{mouseAction:}.

% Collectively, setters and getters are called  \emphind{accessor} methods, and by convention they should be placed in the \protind{accessing} protocol.
% In Smalltalk, \emph{all} instance variables are private to the object that owns them, so the only way for another object to read or write those variables in the Smalltalk language is through accessor methods like this one\footnote{In fact, the instance variables can be accessed in subclasses too.}.
Colectivamente, los setters y getters son llamados m\'etodos \emphind{de acceso}, y por convenci\'on deber\'ian ser colocados en el protocolo \protind{accessing}.
En Smalltalk, \emph{todas} las variables de instancia son privadas para el objeto que las posee, por lo que la \'unica manera de leer o escribir esas variables para otro objeto en el lenguaje Smalltalk es a trav\'es de los m\'etodos de acceso como este\footnote{En realidad, las variables de instancia tambi\'en pueden ser accedidas desde las subclases.}.

% \dothis{Go to the class \ct{LOCell}, define \ct{LOCell>>>mouseAction:} and put it in the \prot{accessing} protocol.}
\dothis{Ve a la clase \ct{LOCell}, define \ct{LOCell>>>mouseAction:} y ponlo en el protocolo \prot{accessing}.}

% Finally, we need to define a method \ct{mouseUp:}; this will be called automatically by the GUI framework if the mouse button is released while the mouse is over this cell on the screen.
Finalmente, necesitamos definir un m\'etodo \ct{mouseUp:}; este ser\'a llamado autom\'aticamente por el GUI framework  si el bot\'on del rat\'on es soltado cuando el rat\'on est\'a sobre la celda en la pantalla.

% \begin{method}[sbecellmouseup]{An event handler}
\begin{method}[sbecellmouseup]{Un manejador de eventos}
LOCell>>>mouseUp: anEvent
   mouseAction value
\end{method}
\cmindex{LOCell}{mouseUp:}

% \dothis{Add the method \ct{LOCell>>>mouseUp:} and then
%   \menu{categorize automatically} methods.}
% \index{method!categorize}
\dothis{Agrega el m\'etodo \ct{LOCell>>>mouseUp:} y luego
  \menu{categorize automatically} los m\'etodos.}
\index{method!categorize}

% What this method does is to send the message \ct{value} to the object stored in the instance variable \ct{mouseAction}. 
% Recall that in \ct{LOGame>>>newCellAt: i at: j} we assigned the following code fragment to \ct{mouseAction}:
Lo que hace este m\'etodo es enviar el mensaje \ct{value} al objeto almacenado en la variable de instancia \ct{mouseAction}.
Recuerda que en \ct{LOGame>>>newCellAt: i at: j} asignamos el siguiente fragmento de c\'odigo a \ct{mouseAction}:

\ct{[self toggleNeighboursOfCellAt: i at: j ]} 

\noindent
% Sending the \ct{value} message causes this code fragment to be evaluated, and consequently the state of the cells will toggle.
Enviar el mensaje \ct{value} provoca que este fragmento de c\'odigo sea evaluado, y consecuentemente el estado de las celdas cambiar\'a. 

%=================================================================
% \section{Let's try our code}
\section{Probemos nuestro c\'odigo}

% That's it: the Lights Out game is complete!
Eso es: el juego Lights Out est\'a completo!

% If you have followed all of the steps, you should be able to play the game, consisting of just 2 classes and 7 methods.
Si has seguido todos los pasos, deber\'ias poder jugar el juego, que consiste en solo 2 clases y 7 m\'etodos.

% \dothis{In a workspace, type \ct{LOGame new openInWorld} and \menu{do it}.}
\dothis{En un workspace, tipea \ct{LOGame new openInWorld} y \menu{do it}.}

% The game will open, and you should be able to click on the cells and see how it works.
El juego se abrir\'a, y deber\'ias poder hacer click en las celdas y ver como funciona. 

% Well, so much for theory\ldots{}
% When you click on a cell, a \emphind{notifier} window called the \clsind{PreDebugWindow}window appears with an error message!
% As depicted in \figref{lightsOutError}, it says \ct{MessageNotUnderstood: LOGame>>>toggleState}.
Bueno, demasiada teor\'ia\ldots{}
Cuando haces click en una celda, una ventana de \emphind{notificaci\'on} llamada ventana \clsind{PreDebugWindow} aparece con un mensaje de error!
Como se muestra en \figref{lightsOutError}, dice \ct{MessageNotUnderstood: LOGame>>>toggleState}.

\begin{figure}[ht]
\ifluluelse
	{\centerline{\includegraphics[width=\textwidth]{Error}}}
	{\centerline{\includegraphics[scale=0.7]{Error}}}
%\caption{There is a bug in our game when a cell is clicked!
\caption{'!Hay un bug en nuestro juego cuando se hace click en nuestra celda!
\figlabel{lightsOutError}}
\end{figure}

\noindent
% What happened? To find out, let's use one of Smalltalk's more powerful tools: the \ind{debugger}.
'¿Qu\'e pas\'o? Para averiguarlo, usemos uno de las herramientas m\'as poderosas de Smalltalk: el \ind{debugger}.

% \dothis{Click on the \menu{debug} button in the notifer window.}
% The debugger will appear.
% In the upper part of the debugger window you can see the execution stack, showing all the active methods; selecting any one of them will show, in the middle pane, the Smalltalk code being executed in that method, with the part that triggered the error highlighted.
\dothis{Haz click en el bot\'on \menu{debug} en la ventana de notificaci\'on.}
El debugger aparecer\'a.
En la parte superior de la ventana del debugger puedes ver la pila de ejecuci\'on, mostrando todos los m\'etodos activos; seleccionando alguno de ellos se mostrar\'a, en el panel del medio, el c\'odigo Smalltalk ejecut\'andose en ese m\'etodo, con la parte que dispar\'o el error resaltada. 

% \dothis{Click on the line labelled
% \ct{LOGame>>>toggleNeighboursOfCellAt:at:} (near the top).}
% The debugger will show you the \ind{execution context} within this method where the error occurred (\figref{debugToggle}).
\dothis{Has click en la l\'inea etiquetada 
\ct{LOGame>>>toggleNeighboursOfCellAt:at:} (near the top).}
El debugger te mostrar\'a el \ind{contexto de ejecuci\'on} de este m\'etodo donde ocurri\'o el error (\figref{debugToggle}).

\begin{figure}[ht]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{Debugger}}}
	{\centerline {\includegraphics[scale=0.7]{Debugger}}}
% \caption{The debugger, with the method \ct{toggleNeighboursOfCell:at:}  selected.
\caption{El debugger, con el m\'etodo \ct{toggleNeighboursOfCell:at:}  seleccionado.
\figlabel{debugToggle}}
\end{figure}

% At the bottom of the debugger are two small inspector windows.  On the left, you can inspect the object that is the receiver of the message that caused the selected method to execute, so you can look here to see the values of the instance variables.
% On the right you can inspect an object that represents the currently executing method itself, so you can look here to see the values of the method's parameters and temporary variables.
En la parte inferior del debugger hay dos pequeñas ventanas de inspecci\'on. A la izquierda, puedes inspeccionar el objeto receptor del mensaje que caus\'o que el mensaje seleccionado se ejecute, asi que pudes mirar aqu\'i para ver los valores de las variables de instancia.
A la derecha puedes inspeccionar un objeto que representa el m\'etodo que se est\'a ejecutando, asi que puedes mirar aqu\'i para ver los valores de los par\'ametros del m\'etodo y las variables temporales.


% Using the debugger, you can execute code step by step, inspect objects in parameters and local variables, evaluate code just as you can in a workspace, and, most surprisingly to those used to other debuggers, change the code while it is being debugged! Some Smalltalkers program in the debugger almost all the time, rather than in the browser.  The advantage of this is that you see the method that you are writing as it will be executed, with real parameters in the actual execution context.
Usando el debugger, puedes ejecutar c\'odigo paso a paso, inspeccionar objetos en par\'ametros y variables locales, evaluar c\'odigo como lo puedes hacer en el workspace, y, m\'as sorprendente a\'un para los que est\'an acostumbrados a otros debuggers, '!cambiar el c\'odigo mientras est\'a siendo debuggeado! Algunos programadores Smalltalk programan en el debugger casi todo el tiempo, en lugar de usar el browser. La ventaja de esto es que puedes ver el m\'etodo que est\'as escribiendo como ser\'a ejecutado, con par\'ametros reales en el contexto de ejecuci\'on real.

% In this case we can see in the first line of the top panel that the \ct{toggleState} message has been sent to an instance of \ct{LOGame}, while it should clearly have been an instance of \lct{LOCell}.
% The problem is most likely with the initialization of the \ct{cells} matrix.
% Browsing the code of \cmind{LOGame}{initialize} shows that \ct{cells} is filled with the return values of \ct{newCellAt:at:}, but when we look at that method, we see that there is no return statement there!
% By default, a method returns \ct{self}, which in the case of \ct{newCellAt:at:} is indeed an instance of \ct{LOGame}.
% \index{method!returning self}
En este caso podemos ver en la primera l\'inea del panel superior que el mensaje \ct{toggleState} fu\'e enviado a una instancia de \ct{LOGame}, cuando, claramente, deber\'ia haber sido una instancia de \lct{LOCell}.
El problema est\'a seguramente con la inicializaci\'on de la matriz \ct{cells}.
Explorando el c\'odigo de \cmind{LOGame}{initialize} nos muestra que \ct{cells} se llena con el valor de retorno de \ct{newCellAt:at:}, pero cuand miramos ese m\'etodo, '!vemos que no hay sentencia de retorno!
Por defecto, un m\'etodo retorna \ct{self}, que en el caso de \ct{newCellAt:at:} es de hecho una instancia de \ct{LOGame}.
\index{method!returning self}

% \dothis{Close the debugger window.
% Add the expression ``\ct{^ c}'' to the end of the method \ct{LOGame>>>newCellAt:at:} so that it returns \ct{c}.
%-- Codigo comentado en la version original --%
% It should now look as shown in \mthref{newCellAt:at:nobug}.}
%-- Fin codigo comentado en la version original --%
% (See \mthref{newCellAt:at:nobug}.)}

\dothis{Cierra la ventana del debugger.
Agrega la expresi\'on ``\ct{^ c}'' al final del m\'etodo \ct{LOGame>>>newCellAt:at:} para que devuelva \ct{c}.
(Ver \mthref{newCellAt:at:nobug}.)}

% \needlines{6}
\begin{method}[newCellAt:at:nobug]{Fixing the bug.}
LOGame>>>newCellAt: i at: j
   "Create a cell for position (i,j) and add it to my on-screen
   representation at the appropriate screen position.  Answer the new cell"
   | c origin |
   c := LOCell new.
   origin := self innerBounds origin.
   self addMorph: c.
   c position: ((i - 1) * c width) @ ((j - 1) * c height) + origin.
   c mouseAction: [self toggleNeighboursOfCellAt: i at: j].
   ^ c
\end{method}
\cmindex{LOGame}{newCellAt:at:}

% \noindent
%Recall from \charef{quick} that the construct to \ind{return} a \subind{method}{value} from a method in Smalltalk is \ct{^}, which you obtain by typing \verb|^|.
% \index{^@\verb|^|}
% \index{^@{$\uparrow$}|see{return}}
\noindent
Recuerda de \charef{quick} que la manera de hacer \ind{return} de un \subind{method}{valor} de un m\'etodo en Smalltalk es \ct{^}, que obtienes tipeando \verb|^|.
\index{^@{$\uparrow$}|see{return}}
% Verificar si esta bien esto del subind... como se puede traducir?

% Often, you can fix the code directly in the debugger window and click \menu{Proceed} to continue running the application.
% In our case, because the bug was in the initialization of an object, rather than in the method that failed, the easiest thing to do is to close the debugger window, destroy the running instance of the game (with the \subind{Morphic}{halo}), and create a new one.
A menudo puedes arreglar el c\'odigo directamente en la ventaba del debugger y hacer click en \menu{Proceed} para continuar corriendo la aplicaci\'on.
En nuestro caso, como el bug estaba en la inicializaci\'on de un objeto, y no en el m\'etodo que fall\'o, lo m\'as f\'acil
es cerrar la ventana de debug, destruir la intancia del juego ejecut\'andose (con el \subind{Morphic}{halo}), y crear una nueva.
%%%------------HASTA ACA LLEGUE---------------%%%
%Indeed, even in this case it would be possible to \menu{do} \ct{self initialize} and then \menu{Proceed} the \ct{toggleNeighboursOfCellAt:at:} method.
%\ab{St\'eph, did you try this?  It seems to me that it ought to work, but when I tried it, it messed up my image.}
% ON : It messed me up too!  Better not propose this.

\dothis{Do: \ct{LOGame new openInWorld} again.}

Now the game should work properly ... or nearly so.  If we happen to move the mouse between clicking and releasing, then the cell the mouse is over will also be toggled.  This turns out to be behavior that we inherit from \ct{SimpleSwitchMorph}. We can fix this simply by overriding \ct{mouseMove:} to do nothing:

% \needlines{6}
\begin{method}[mouseMove:]{Overriding mouse move actions.}
LOGame>>>mouseMove: anEvent
\end{method}

Finally we are done!

%\sd{It would be good to have a word about the debugger buttons into, step.... Or to have a separate chapter, we would use the material I wrote for my turtle book, please check it.}
%\on{I think that is too much for this chapter. It will come soon enough.}

%=================================================================
\section{Saving and sharing Smalltalk code}
\seclabel{Monticello}

Now that you have the Lights Out game working, you probably want to save it somewhere so that you can share it with your friends. Of course, you can save your whole \pharo image, and show off your first program by running it, but your friends probably have their own code in their images, and don't want to give that up to use your image.
What you need is a way of getting source code out of your \pharo image so that other programmers can bring it into theirs.

The simplest way of doing this is by \emph{filing out} the code.  The \actclick menu in the Package pane will give you the option to \menu{various \go{} file out} the whole of package \scat{PBE-LightsOut}.
The resulting file is more or less human readable, but is really intended for computers, not humans.
You can email this file to your friends, and they can file it into their own \pharo images using the file list browser.
\seeindex{saving code}{categories}
\seeindex{category!filing out}{file, filing out}
\seeindex{class!filing out}{file, filing out}
\seeindex{method!filing out}{file, filing out}
\index{file!filing out}

\dothis{\Actclick on the \scat{PBE-LightsOut} package and \menu{various \go{} file out} the contents.}
You should now find a file called ``PBE-LightsOut.st'' in the same folder on disk where your image is saved.
Have a look at this file with a text editor.

\dothis{Open a fresh \pharo image and use the File Browser tool (\menu{Tools \ldots {\go} File Browser}) to \menu{file in} the PBE-LightsOut.st fileout.
Verify that the game now works in the new image.}
\seeindex{category!filing in}{file, filing in}
\seeindex{class!filing in}{file, filing in}
\seeindex{method!filing in}{file, filing in}
\index{file!filing in}

\begin{figure}[ht]
\centerline {\includegraphics[width=\textwidth]{FileIn}}
\caption{Filing in \pharo source code.
\figlabel{filein}}
\end{figure}

\subsection{Monticello packages}
Although fileouts are a convenient way of making a snapshot of the code you have written, they are decidedly ``old school''.
Just as most open-source projects find it much more convenient to maintain their code in a repository using \ind{CVS}\footnote{\url{http://www.nongnu.org/cvs}} or \ind{Subversion}\footnote{\url{http://subversion.tigris.org}},
so \pharo programmers find it more convenient to manage their code using \ind{Monticello} packages. 
These packages are represented as files with names ending in \ct{.mcz}; they are actually zip-compressed bundles that contain the complete code of your \ind{package}.

Using the Monticello package browser, you can save packages to repositories on various types of server, including FTP and HTTP servers; you can also just write the packages to a repository in a local file system directory.
A copy of your package is also always cached on your local hard-disk in the \emph{package-cache} folder. 
Monticello lets you save multiple versions of your program, merge versions, go back to an old version, and browse the differences between versions. 
In fact, Monticello is a distributed revision control system; this means it allows developers to save their work on different places, not on a single repository as it is the case with CVS or Subversion.\damien{Mercurial, Git are examples of distributed revision control system; not sure it's worth mentioning them.}
\seeindex{package browser}{Monticello}

You can also send a \ct{.mcz} file by email. 
The recipient will have to place it in her \emph{package-cache} folder; she will then be able to use Monticello to browse and load it. 
%(It is also possible to load it using the file list, but there is a difference between loading a \ct{.mcz} file using a file list and using Monticello \sd{check}.)

\dothis{Open the Monticello browser from the \menu{World} menu.}
In the right-hand pane of the browser (see \figref{monticello1}) is a list of Monticello repositories, which will include all of the repositories from which code has been loaded into the image that you are using.  
%In addition to \sqsrc servers, Monticello repositories can live in a variety of other places, the simplest being a directory on your local disk.

\begin{figure}[hbt]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{MonticelloBrowser}}}
	{\centerline {\includegraphics[scale=0.7]{MonticelloBrowser}}}
\caption{The Monticello browser.
\figlabel{monticello1}}
\end{figure}

At the top of the list in the Monticello browser is a repository in a local directory called the \emphind{package cache}, which caches copies of the packages that you have loaded or published over the network. This local cache is really handy because it lets you keep your own local history; it also allows you to work in places where you do not have internet access, or where access is slow enough that you do not want to save to a remote repository very frequently.


\subsection{Saving and loading code with Monticello.}
On the left-hand side of the Monticello browser is a list of packages that have a version loaded into the image; packages that have been modified since they were loaded are marked with an asterisk.  (These are sometimes referred to as \subind{package}{dirty} packages.)  If you select a package, the list of repositories is restricted to just those repositories that contain a copy of the selected package.
\seeindex{*}{package, dirty}
\seeindex{dirty package}{package, dirty}

%What is a package?  For now, you can think of a package as a group of  class and method categories that share the same prefix.  Since we put all of the code for the Lights Out game into the category called \scat{PBE-LightsOut}, we can refer to it as the \ct{PBE-LightsOut} package.

\dothis{Add the \ct{PBE-LightsOut} package to your Monticello browser using the \button{+Package} button and type \ct{PBE-LightsOut}.}

\subsection{\ind{\sqsrc}: a \ind{SourceForge} for \pharo.} 
We think that the best way to save your code and share it is to create an account for your project on a \sqsrc server. 
\sqsrc is like SourceForge\footnote{\url{http://sourceforge.net}}: it is a web front-end to a HTTP Monticello server that lets you manage your projects.
There is a public \sqsrc server at \url{http://www.squeaksource.com}, and a copy of the code related to this book is stored there at \url{http://www.squeaksource.com/PharoByExample.html}. You can look at this project with a web browser, but it's a lot more productive to do so from inside \pharo, using the Monticello browser, which lets you manage your packages.

\dothis{Open a web browser to \url{http://www.squeaksource.com}.
Create an account for yourself and then create (\ie ``register'') a project for the Lights Out game.}
\sqsrc will show you the information that you should use when adding a repository using the Monticello browser. 

Once your project has been created on \sqsrc, you have to tell your \pharo system to use it. 

\dothis{With the \ct{PBE-LightsOut} package selected, click the \button{+Repository} button in the Monticello browser.}  You will see a list of the different types of Repository that are available; to add a \sqsrc repository select \menu{HTTP}. You will be presented with a dialog in which you can provide the necessary information about the server.
You should copy the presented template to identify your \sqsrc project, paste it into Monticello and supply your initials and password:

\needlines{5}
\begin{code}{}
MCHttpRepository 
    location: 'http://www.squeaksource.com/!\emph{YourProject}!'
    user: '!\emph{yourInitials}!' 
    password: '!\emph{yourPassword}!'
\end{code}   

\noindent
If you provide empty initials and password strings, you can still load the project, but you will not be able to update it:

\needlines{5}
\begin{code}{}
MCHttpRepository 
    location: 'http://www.squeaksource.com/!\emph{YourProject}!'
    user: '' 
    password: ''
\end{code}   

%You can then load the code in your image by selecting the version you want. You can browse the code without loading it, using the \button{Browse} button.
Once you have accepted this template, your new repository should be listed on the right-hand side of the Monticello browser.

\begin{figure}[hbt]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{BrowseRepository}}}
	{\centerline {\includegraphics[scale=0.7]{BrowseRepository}}}
\caption{Browsing a Monticello Repository
\figlabel{monticello3}}
\end{figure}

\dothis{Click on the \button{Save} button to save a first version of your Lights Out game on \sqsrc.}

To load a package into your image, you must first select a particular version.  You can do this in the repository browser, which you can open using the \button{Open} button or the \actclick menu.  Once you have selected a version, you can load it onto your image.

\dothis{Open the \ct{PBE-LightsOut} repository you have just saved.}

Monticello has many more capabilities, which will be discussed in depth in \charef{env}.
You can also look at the on-line documentation for Monticello at \url{http://www.wiresong.ca/Monticello/}.

%=================================================================
\section{Chapter summary}
In this chapter you have seen how to create categories, classes and methods.  You have see how to use the browser, the inspector, the debugger and the Monticello browser.

\begin{itemize}
  \item Categories are groups of related classes.
  \item A new class is created by sending a message to its superclass.
  \item Protocols are groups of related methods.
  \item A new method is created or modified by editing its definition in the browser and then \emph{accepting} the changes.
  \item The inspector offers a simple, general-purpose GUI for inspecting and interacting with arbitrary objects.
  \item The browser detects usage of undeclared methods and variables, and offers possible corrections.
  \item The \ct{initialize} method is automatically executed after an object is created in \pharo. You can put any initialization code there.
  \item The debugger provides a high-level GUI to inspect and modify the state of a running program.
  \item You can share source code \emph{filing out} a category.
  \item A better way to share code is to use Monticello to manage an external repository, for example defined as a \sqsrc project.
\end{itemize}

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================
%=================================================================
%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:
