% $Author$
% $Date$
% $Revision$

% HISTORY:
% 2006-12-05 - Stef started
% 2006-12-30 - Andrew new material
% 2007-01-10 - Stef edit
% 2007-01-12 - Andrew edit
% 2007-06-07 - Oscar edit
% 2007-07-03 - Stef edit
% 2007-09-06 - Lukas review
% 2007-09-06 - Cassou corrections
% 2007-09-24 - Cassou review
% 2009-07-01 - Oscar migrated to Pharo
% 2011-06-20 - Federico Rodriguez translated to Spanish

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
\chapter{Una primer aplicaci\'on}
\chalabel{firstApp}

En este cap\'itulo vamos a desarrollar un juego simple: \ind{Lights Out}.\footnote{\url{http://en.wikipedia.org/wiki/Lights_Out_(game)}}
En el camino mostraremos la mayor\'ia de las herramientas que los programadores
de \pharo usan para construir y depurar sus programas, y mostraremos como se
intercambian los programas con otros desarrolladores. Veremos el explorador,
el inspector de objetos, el depurador y el paquete explorador \ind{Monticello}
El desarrollo en Smalltalk es eficiente: encontrar\'as que pasas m\'as tiempo escribiendo c\'odigo y mucho menos manejando el proceso de desarrollo.
Esto es en parte porque Smalltalk es muy simple, y en parte porque las herramientas que conforman el entorno de programaci\'on est\'an muy bien integradas con el lenguaje.

%=================================================================
\section{El juego Lights Out}

% DON'T USE WRAPFIGURE CLOSE TOO A PAGE BREAK!!! (ON)
%\begin{wrapfigure}[13]{r}{0.35\linewidth}%
%	\vskip -\baselineskip
%	\centerline{\includegraphics[width=.8\linewidth]{GameBoard}}
%	\caption{The Lights Out game board. The user has just clicked the mouse as shown by the cursor.
%	\figlabel{gameBoard}}
%\end{wrapfigure}

\begin{figure}[ht]
	\vskip -\baselineskip
	\centerline{\includegraphics[width=.3\linewidth]{GameBoard}}
	\caption{El tablero del juego Lights Out. El usuario ha hecho clic con el rat\'on como muestra el cursor.
	\figlabel{gameBoard}}
\end{figure}

Para mostrar como utilizar las herramientas de \pharo, construiremos un un juego
sencillo llamado \emph{Lights Out}. El tablero del juego se muestra en \figref{gameBoard};
consiste en una grilla rectagular de \emph{celdas} amarillas. Cuando haces clic
sobre una celda con el rat\'on, las cuatro celdas adyacentes se tornan azules. Si
haces \Click otra vez, se volver\'an otras vez amarillas. El objetivo del juego
es poner azules la mayor cantidad de celdas que sea posible.

En el Lights Out que se muesta en \figref{gameBoard} est\'a compuesto por
dos objetos: el tablero del juego en s\'i, y 100 objetos celda individuales. El
c\'odigo de \pharo para implementar el juego tendr\'a dos clases: una para el
juego y otra para las celdas. Ahora veremos c\'omo definir estas clases usando
las herramientas de programaci\'on de \pharo.

\section{Creando un paquete nuevo}

Ya hemos visto el \ind{Browser} en \charef{quick}, donde aprendimos como
navegar clases y m\'etodos, y vimos como definir nuevos m\'etodos. Ahora veremos
como crear paquetes, categor\'ias y clases.

\index{category!creating}
\index{package!creating}

\dothis{Abre el explorador y seleccione la herramienta package.
Selecciona \menu{create package}.\footnote{Estamos asumiendo que el explorador
de paquetes est\'a instalado como el explorador por defecto, lo que
ocurre en casi todos los casos. Si el navagador que obtienes no se
ve similar al de \figref{addPackage}, entonces tal vez tengas que cambiar
el explorador por defecto. Mira \faqref{packagebrowser}.}}

\begin{figure}[htb]
\begin{minipage}[b]{0.48\textwidth}
\ifluluelse
	{\centerline {\includegraphics[width=0.9\textwidth]{AddPackage}}}
	{\centerline {\includegraphics[scale=0.7]{AddPackage}}}
	\caption{Agregando un paquete.
	\figlabel{addPackage}}
\end{minipage}
\hfill
\begin{minipage}[b]{0.48\textwidth}
\ifluluelse
	{\centerline {\includegraphics[width=0.8\textwidth]{ClassTemplate}}}
	{\centerline {\includegraphics[scale=0.6]{ClassTemplate}}}
	\caption{La plantilla de una clase.
	\figlabel{classTemplate}}
\end{minipage}
\end{figure}

Escribe el nombre del nuevo paquete (usaremos \scat{PBE-LightsOut}) en
el cuadro de di\'alogo y selecciona \menu{accept} (o solo pulsa
la tecla enter); el nuevo paquete se ha creado, y se posiciona alfab\'eticamente
en la lista de paquetes.

%=================================================================
\section{Definiendo la clase LOCell}

Por supuesto, todav\'ia no hay clases en el nuevo paquete. A\'un as\'i, el panel
principal de edici\'on nos muestra una plantilla para hacer m\'as sencilla la tarea de crear
una nueva clase (ver \figref{classTemplate}).

% This template shows us a \st expression that sends a message to a class called
% \ct{Object}, asking it to create a subclass called \ct{NameOfSubClass}.  The
% new class has no variables, and should belong to the category
% \scat{PBE-LightsOut}.

Esta plantilla nos muestra una \st expression que env\'ia un mensaje a la clases
que se llama \ct{Object}, solicit\'andole que genere una subclase llamada
\ct{NameOfSubClass}. La nueva clase no tendr\'a variables, y deber\'a pertenecer
a la categor\'ia \scat{PBE-LightsOut}.

% \subsection{On Categories and Packages}
\subsection{Sobre categor\'ias y paquetes}
\seclabel{categoriesPackages}

% Historically, \st only knows about \emph{categories}, not packages.
% You may well ask, what is the difference?
% A category is simply a collection of related classes in a \st image.
% A \emph{package} is a collection of related classes \emph{and extension methods} that may be versioned using the Monticello versioning tool.
% By convention, package names and category names are the same.
% For most purposes we do not care about the difference, but we will be careful to use the correct terminology in this book since there are points where the difference is crucial.
% We will learn more when we start working with Monticello.
% \index{package}
% \index{category}

Hist\'oricamente, se trata sobre \emph{categor\'ias}, no paquetes.
Entonces podr\'ias preguntarte, ?`cual es la diferencia?
Una categor\'ia es simplemente una colecci\'on de clases relacionanadas en
una \st im\'agen.
Un \emph{paquete} es una colecci\'on de clases relacionadas junto a
\emph{m\'etodos de extensi\'on} que podr\'ian estar bajo un control de versiones
como Monticello.
Por convenci\'on, los nombres de paquetes y categor\'ias son siempre los mismos.
En la mayor\'ia de los casos no nos preocuparemos por las diferencias, pero
seremos cuidadosos en la terminolog\'ia de este libro para utilizar la
denominaci\'on correcta, ya que hay puntos donde de la diferencia es crucial.
Aprenderemos m\'as sobre este tema cuando comencemos a trabajar con Monticello.
\index{package}
\index{category}


% \subsection{Creating a new class}
\subsection{Creating a new class}

Solamente modificaremos la plantilla para crear la clase que realmente queremos.

\dothis{Modifique la plantilla de creaci\'on de clase como sigue:}
\begin{itemize}
  \item Reemplace \clsind{Object} por \clsind{SimpleSwitchMorph}.
  \item Reemplace \ct{NameOfSubClass} por \clsind{LOCell}.
  \item A単ada \ct{mouseAction} a la lista de variables de instancia.
\end{itemize}
El resultado deber\'ia parecerse a \clsref{firstClassDef}.

\needlines{5}
\begin{classdef}[firstClassDef]{Defining the class \ct| LOCell|}
SimpleSwitchMorph subclass: #LOCell
   instanceVariableNames: 'mouseAction'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'PBE-LightsOut'
\end{classdef}
\index{browser!defining a class}
\index{class!creation}
\index{Morphic}

% This new definition consists of a \st expression that sends a message to the
% existing class \ct{SimpleSwitchMorph}, asking it to create a subclass called
% \ct{LOCell}.  (Actually, since \ct{LOCell} does not exist yet, we passed as an
% argument the \emphind{symbol} \ct{#LOCell} which stands for the name of the
% class to create.) We also tell it that instances of the new class should have a
% \ct{mouseAction} instance variable, which we will use to define what action the
% cell should take if the mouse should click over it.

Esta nueva definici\'on consiste de una expresi\'on \st que env\'ia un mensaje a la
clase existente \ct{SimpleSwitchMorph}, pidi\'endole que cree una subclase llamada
\ct{LOCell}. (En realidad, como \ct{LOCell} no existe a\'un, se le pasa 
\emphind{symbol} \ct{#LOCell} como argumento, que indica el nombre de la clase a 
crear). Tambi\'en le indicamos que las instancias de la nueva clase deber\'ian 
tener una instancia de variable de \ct{mouseAction}, que usaremos para definir
que acci\'on deber\'ia tomar la celda si se hiciera clic sobre esta.

\emph {Hasta el momento no has creado nada.}
Nota que el borde del panel de plantilla de clase cambi\'o a rojo (\figref{acceptClassDef}).
Esto significa que hay cambios \emph {sin guardar.}
Para enviar este mensaje, debes seleccionar \menu {accept}. 

\begin{figure}[h!t]
\ifluluelse
  {\centerline {\includegraphics[width=\textwidth]{AcceptClassDef}}}
  {\centerline {\includegraphics[scale=0.7]{AcceptClassDef}}}
\caption{Template de creaci\'on de clase.
\figlabel{acceptClassDef}}
\end{figure}

\dothis{Aceptar la definici\'on de la nueva clase.}
Esto se puede hacer de dos formas: o bien \actclick y selecciona \menu{accept}, o bien
usa el atajo \short{s} (para ``guardar'').
El mensaje ser\'a enviado a \ct{SimpleSwitchMorph}, causando que la nueva clase sea compilada.
\index{keyboard shortcut!accept} % <-- ver si hay que traducir esto.

Una vez que la definici\'on de la clase es aceptada, la clase ser\'a creada y aparecer\'a en el panel de clases del navegador (\figref{LOCell}).
Ahora el panel de edici\'on muestra la definici\'on de la clase, y un peque単o panel debajo te recordar\'a escribir unas pocas palabras describiendo el prop\'osito de la clase. Esto se llama \emph {comentario de la clase}. Es importante escribir un comentario que le de a otros programadores una visi\'on de alto nivel del prop\'osito de la clase.
Los desarrolladores Smalltalk le dan un gran valor a la legibilidad de su c\'odigo, y es poco com\'un encontrar comentarios detallados dentro de los m\'etodos: la filosof\'ia de Smalltalk es que el c\'odigo debe ser autoexplicativo. (Si no lo es, !`deber\'ias refactorizarlo hasta que lo sea!) Una clase \subind{clase}{comentario} no deber\'ia contener una descripci\'on detallada de la clase, pero unas pocas palabras que describan su prop\'osito de manera general son vitales para que otros programadores sepan si vale la pena invertir tiempo en mirar la clase o no.
\index{refactoring}

\dothis{Escribe un comentario de clase para \ct{LOCell} y gu\'ardalo; siempre se puede mejorar m\'as tarde.}

\begin{figure}[h!t]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{LOCell}}}
	{\centerline {\includegraphics[scale=0.7]{LOCell}}}
\caption{La nueva clase creada \ct{LOCell}\figlabel{LOCell}}
\end{figure}


%=================================================================
\section{Agregando m\'etodos a una clase}

Ahora agreguemos algunos m\'etodos a nuestra clase.

\dothis{Selecciona el protocolo \prot{-{}-all-{}-} en el panel de protocolos.}
Ver\'as un plantilla para la creaci\'on de m\'etodos en el panel de edici\'on.
Selecci\'onalo y reempl\'azalo por el texto de \mthref{scbecellinitialize}.
\protindex{all}
\index{method!creation}
\index{browser!defining a method}

\needlines{10}
\begin{numMethod}[scbecellinitialize]{Initializing instances of \ct{LOCell}}
initialize
   super initialize.
   self label: ''.
   self borderWidth: 2.
   bounds := 0@0 corner: 16@16.
   offColor := Color paleYellow.
   onColor := Color paleBlue darker.
   self useSquareCorners.
   self turnOff
\end{numMethod}
\index{initialization}

\noindent
Notar que los caracteres \ct{''} en la l\'inea 3 son comillas simples sin nada en el medio, no una doble comilla. \ct{''} es una cadena de caracteres vac\'ia. 

\dothis{\menu{Aceptar} la definici\'on de este m\'etodo.}

?`Qu\'e hace el c\'odigo de arriba? No nos adentraremos en los detalles aqu\'i (!`para eso es el resto del libro!), pero te daremos una breve introducci\'on. Ve\'amoslo l\'inea por l\'inea.

Notar que el m\'etodo se llama \mthind{LOCell}{initialize}.
El nombre es muy significativo!
Por convenci\'on, si una clase define un m\'etodo llamado \ct{initialize}, este ser\'a llamado inmediatamente despu\'es que el objeto sea creado. 
Entonces, cuando evaluamos \ct{LOCell new}, el mensaje \ct{initialize} ser\'a enviado autom\'aticamente al objeto reci\'en creado. 
Los m\'etodos "initialize" se usan para establecer el estado de los objetos, normalmente para establecer las variables de instancia; esto es exactamente lo que estamos haciendo ac\'a. 
\seeindex{Object!initialization}{initialization}
\index{initialization}

Lo primero que hace este m\'etodo (l\'inea 2) es ejecutar el m\'etodo \ct{initialize} de su superclase, \ct{SimpleSwitchMorph}.
% Superclass lo traducimos como superclase o como clase padre o como? <----
El objetivo de esto es que cualquier estado heredado sea inicializado adecuadamente por el m\'etodo \ct{initialize} de la superclase.
Siempre es buena idea inicializar estado heredado enviando el mensaje \ct{super initialize} antes de hacer cualquier otra cosa; no sabemos exactamente que har\'a el m\'etodo \ct{initialize} de \ct{SimpleSwitchMorph}, y no nos importa, pero seguramente inicializar\'a algunas variables de instancia para que contengan valores razonables, por lo que es mejor invocarlo para no arriesgarse a que los objetos empiecen en un estado inv\'alido.

El resto del m\'etodo establece el estado del objeto.
Enviar el mensaje \ct{self label: ''}, por ejemplo, establece la etiqueta de este objeto a la cadena de caracteres vac\'ia.
\pvindex{self}

La expresi\'on \ct{0@0 corner: 16@16} probablemente necesite un poco de explicaci\'on.
\lct{0@0} representa un objeto \clsind{Point} con las coordenadas $x$ e $y$ en 0.
De hecho, \ct{0@0} env\'ia el mensaje \ct{@} al n\'umero \ct{0} con par\'ametro \ct{0}.

El efecto ser\'a que el n\'umero \ct{0} le pedir\'a a la clase \ct{Point} que cree una nueva instancia con coordenadas (0,0).
Ahora le enviamos a este nuevo punto el mensaje \ct{corner: 16@16}, que hace que cree un \clsind{Rectangle} con esquinas \ct{0@0} y \ct{16@16}.
Este nuevo rect\'angulo ser\'a asignado a la variable \ct{bounds}, heredada de la superclase. 

Nota que el or\'igen de la pantalla de \pharo es la \emph{esquina izquierda}, y la coordenada $y$ se incrementa hacia \emph{abajo}.

El resto del m\'etodo deber\'ia ser autoexplicativo.
Parte de arte de escribir buen c\'odigo \st es escoger los nombres adecuados para los m\'etodos para que el c\'odigo pueda ser leido como una especie de ingl\'es macarr\'onico. 
Deber\'ias poder imaginar al objeto hablandose a s\'i mismo y diciendo ``\ct{Self use square corners!}'', ``\ct{Self turn off}''.

%=================================================================
\section{Inspeccionando un objeto}

Puedes probar el efecto del c\'odigo que acabas de escribir creando un nuevo objeto \ct{LOCell} y luego inspeccion\'andolo. 

\dothis{Abre un workspace. Tipea la expresi\'on \ct{LOCell new} y \menu{inspect it}.}

\begin{figure}[htbp]
   \centering
   \includegraphics[width=\textwidth]{LOCellInspector} 
   \caption{El inspector usado para examinar un objeto LOCell.\figlabel{LOCellInspector}}
\end{figure}

El panel izquierdo de \ind{inpector} muestra una lista de variables de instancia; si seleccionas una (prueba \mbox{\ct{bounds}}), el valor de la \ind{variable de instancia} se muestra en el panel derecho. 

El panel inferior del inspector es un mini-workspace. Es muy \'util porque en este workspace la pseudo variable \self est\'a ligada al objeto seleccionado.

\dothis{
Selecciona LOCell en la ra\'iz de la ventana del inspector.
Tipea el texto \ct{self openInWorld} en el mini-workspace y \menu{do it}.}
La celda deber\'ia aparecer cerca de la esquina superior izquierda de la pantalla, exactamente donde sus \ct{l\'imites} dicen que deber\'ia aparecer. 
\metaclick en la celda para que aparezca el halo de Morphic \subind{Morphic}. %% <---verificar
Mueve la celda con el asa marr\'on (esquina superior derecha) y redimensi\'onalo con el asa amarilla (abajo a la derecha).
Nota como los l\'imites reportados por el inspector tambi\'en cambian. 
(Tal vez tengas que \actclick{} \menu{refresh} para ver los nuevos valores de los l\'imites.)

\begin{figure}[htbp]
\centering
\ifluluelse
	{\includegraphics[width=\textwidth]{LOCellResize} }
	{\includegraphics[scale=0.7]{LOCellResize} }
\caption{Redimensiona la celda.\figlabel{cellresize}}
\end{figure}

\dothis{Borra la celda haciendo clic en la \ct{x} en el asa rosa.}

%=================================================================
\section{Definiendo la clase LOGame}

Ahora creemos la otra clase que necesitamos para el juego, que llamaremos \clsind{LOGame}.

\dothis{Has visible el plantilla de definici\'on de clases en la ventana principal del navegador.}
Has esto haciendo clic en el nombre del paquete.
Edita el c\'odigo para que quede como se muestra a continuaci\'on, y has \menu{accept}.

\needlines{6}
\begin{classdef}[sbegame]{Defining the \ct{LOGame} class}
BorderedMorph subclass: #LOGame
   instanceVariableNames: ''
   classVariableNames: ''
   poolDictionaries: ''
   category: 'PBE-LightsOut'
\end{classdef}

Aqu\'i creamos una subclase de \clsind{BorderedMorph}; \clsind{Morph} es la superclase de todas las formas gr\'aficas e \pharo, y(!`sorpresa!) un \ct{BorderedMorph} es un \ct{Morph} con borde.
Podr\'iamos insertar los nombres de las variables de instancia entre comillas en la segunda l\'inea pero, por ahora, dejemos esa lista vac\'ia.

Ahora definamos un m\'etodo \mthind{LOGame}{initialize} para \ct{LOGame}.

\dothis{Escribe lo siguiente en el navegador como un m\'etodo para \ct{LOGame} e intenta \menu{accept}:}

\begin{numMethod}[sbegameinitialize]{Initializing the game}
initialize
   | sampleCell width height n |
   super initialize.
   n := self cellsPerSide.
   sampleCell := LOCell new.
   width := sampleCell width.
   height := sampleCell height.
   self bounds: (5@5 extent: ((width*n) @(height*n)) + (2 * self borderWidth)).
   cells := Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ].
\end{numMethod}

\pharo se quejar\'a de que no conoce el significado de ciertos t\'erminos.
\pharo dice que no conoce un mensaje \ct{cellsPerSide}, y sugiere algunas correcciones, en caso de que haya sido un error de tipeo.

\begin{figure}[htb]
\begin{minipage}{0.48\textwidth}
	\centering
	\ifluluelse
		{\includegraphics[width=\textwidth]{UnknownSelector}}
		{\includegraphics[scale=0.7]{UnknownSelector}}
 \caption{\pharo detectando un identificador desconocido.\figlabel{unknownSelector}}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
	\centering
	\ifluluelse
		{\includegraphics[width=\textwidth]{DeclareInstanceVar}}
		{\includegraphics[scale=0.7]{DeclareInstanceVar}}
	\caption{Declarando una nueva variable de instancia.\figlabel{declareInstance}}
\end{minipage}
\end{figure}

Pero \ct{cellsPerSide} no es un error\,---\, es solo un m\'etodo que no hemos definido aun\,---\, lo haremos en un momento.

\dothis{Selecciona el primer item del men\'u, que confirma que quisimos escribir \ct{cellsPerSide}.}

A continuaci\'on, \pharo se quejar\'a de que no conoce el significado de \ct{cells}. Te ofrece un n\'umero de formas de arreglar esto. 

\dothis{Elige \menu{declare instance} porque queremos que \ct{cells} sea una variable de instancia.}
Finalmente, \pharo se quejar\'a del mensaje \ct{newCellAt:at:} en la \'ultima l\'inea; esto tampoco es un error, asi que debes confirmar ese mensaje tambi\'en.
\index{on the fly variable definition}
\index{instance variable definition} 

Si miras ahora a la definici\'on de la clase de nuevo (cosa que puedes hacer haciendo clic en el bot\'on \button{nstance}), ver\'as que el navegador la modific\'o para incluir la variable de instancia \ct{cells}.

Miremos ahora al m\'etodo \ct{initialize}.
La l\'inea \ct{| sampleCell width height n |} declara 4 variables temporales. Son llamadas temporarias porque su \'ambito y tiempo de vida son limitados a este m\'etodo. Las variables temporales con nombres explicativos ayudan a hacer el c\'odigo m\'as legible. SMalltalk no tiene sintaxis especial para distinguir constantes y variables, y en realidad estas cuatro ``variables'' son en realidad constantes.
Las l\'ineas 4--7 definen estas constantes.

?`Qu\'e tan grande deber\'ia ser nuestro tablero de juego? Lo suficientemente grande como para almacenar algun n\'umero entero de celdas, y lo suficientemente grande como para dibujar un borde alrededor de ellas.
?`Cu\'al ser\'ia el n\'umero correcto de celdas? ?`5? ?`10? ?`100? No sabemos a\'un, y si supi\'eramos, probablemente cambiar\'iamos de parecer luego. As\'i que delegamos la responsabilidad de saber ese n\'umero a otro m\'etodo, que llamaremos \ct{cellsPerSide}, y que escribiremos en un momento.
Es porque estamos enviando el mensaje \ct{cellsPerSide} antes de definirlo que \pharo nos pidi\'o ``confirmar, corregir o cancelar'' cuando aceptamos el cuerpo del m\'etodo \ct{initialize}.
No te desanimes por esto: es en realidad una buena pr\'actica escribir en t\'erminos de m\'etodos que no hemos definido a\'un.
?`Por que? No fu\'e hasta que empezamos a escribir el m\'etodo \ct{initialize} que nos dimos cuenta que lo necesit\'abamos, y en ese momento, podemos darle un nombre significativo, y seguir adelante, sin interrumpir el flujo.
 
La cuarta l\'inea usa este m\'etodo:
El c\'odigo Smalltalk \ct{self cellsPerSide} env\'ia el mensaje \ct{cellsPerSide} a \pvind{self}, es decir, a este mismo objeto.
La respuesta, que ser\'a el n\'umero de celdas por lado del tablero de juego, es asignado a \ct{n}.

Las siguientes tres l\'ineas crean un nuevo objeto \ct{LOCell}, y asignan su ancho y alto a las variables temporales adecuadas. 

La l\'inea 8 establece los \ct{l\'imites} del nuevo objeto.
Sin preocuparte mucho por los detalles ahora, conf\'ia en que la expresi\'on entre par\'entesis crea un cuadrado con or\'igen (\ie esquina superior izquierda) en el punto (5,5) y su esquina inferior derecha lo suficientemente lejos como para dar espacio al n\'umero correcto de celdas.

La \'ultima l\'inea establece la variable de instancia \ct{cells} del el objeto \ct{LOGame} a una reci\'en creada \clsind{Matrix} con el correcto n\'umero de filas y columnas. Hacemos esto enviando el mensaje \ct{new:tabulate:} a la clase \ct{Matrix} (las clases son objetos tambi\'en, por lo que les podemos enviar mensajes). Sabemos que \mthind{Matrix class}{new:tabulate} espera dos par\'ametros porque tiene dos s\'imbolos \ct{:} en su nombre. Los par\'ametros van justo despues de los s\'imbolos ':'.
Si est\'as acostumbrado a lenguajes que ponen todos los argumentos juntos dentro de par\'entesis, esto puede parecer raro al principio. !`No entres en p\'anico, es solo sintaxis!
Resulta que es una muy buena sintaxis porque el nombre de un m\'etodo puede ser usado para explicar los roles de los argumentos. Por ejemplo, es bastante claro que \ct{Matrix rows: 5 columns: 2} tiene 5 filas y 2 columnas, y no 2 filas y 5 columnas. 

\cmindex{Matrix class}{rows:columns:}

\ct{Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]} crea una nueva matriz de \ct{n}{$\times$}\ct{n} e inicializa sus elementos. El valor inicial de cada elemento depender\'a de sus coordenadas.  El \ct{(i,j)}-\'esimo elemento ser\'a inicializado al resultado de evaluar \ct{self newCellAt: i at: j}.


%=================================================================
\section{Organizando m\'etodos en protocolos}

Antes de definir m\'as m\'etodos, demos una r\'apida mirada al tercer panel en la parte superior del navegador. 
De la misma manera que el primer panel del navegador nos permite categorizar clases en paquetes para que no nos sintamos abrumados por una larga lista de nombres de clases en el segundo panel, el tercer panel nos permite categorizar m\'etodos para que no nos sintamos abrumados por una larga lista de nombres de m\'etodos en el cuarto panel.
Estas categor\'ias de m\'etodos se llaman ``protocolos''.
\index{protocolo}

Si s\'olo hay unos pocos m\'etodos en la clase, el nivel extra de jerarqu\'ia provisto por los protocolos no es realmente necesario.
Esta es la raz\'on por la que el navegador tambi\'en nos ofrece el protocolo virtual \prot{-{}-all-{}-}, que, como no te sorprender\'a, contiene todos los m\'etodos de la clase.
\protindex{all}

\begin{figure}[htbp]
   \centering
   \includegraphics[width=\textwidth]{Categorize} 
   \caption{Catergoriza autim\'aticamente todos los m\'etodos sin categorizar.\figlabel{categorize}}
\end{figure}

Si has seguido este ejemplo, el tercer panel bien podr\'ia contener el protocolo \protind{as yet unclassified}.

\dothis{\Actclick en el panel de protocolo y selecciona \menu{various \go categorize automatically} para arreglar esto, y mueve los m\'etodos \ct{initialize} a un nuevo protocolo llamado \protind{initialization}.}
?`Como sabe \pharo que este es el protocolo correcto? Bueno, en general  \pharo{} no puede saberlo, pero en este caso tambi\'en hay un m\'etodo \ct{initialize} en una superclase, y \pharo asume que nuestro m\'etodo \ct{initialize} deber\'ia ir en la misma categor\'ia que el que est\'a sobreescribiendo. 
\index{method!categorize}

\paragraph{Convenci\'on tipogr\'afica.} Los programadors Smalltalk usan con frecuencia la notaci\'on ``\verb|>>|'' para identificar la clase a la que pertenece un m\'etodo. Por ejemplo, el m\'etodo \ct{cellsPerSide} en la clase \ct{LOGame} ser\'ia referenciado como \ct{LOGame>>cellsPerSide}.
Para indicar que esto \emph{no es} sintaxis \st, usaremos en su lugar el s\'imbolo especial \ct{>>>}, con lo que el m\'etodo en el texto aparecer\'a como \ct{LOGame>>>cellsPerSide}.
\cmindex{Behavior}{>>}

De ahora en adelante, cuando mostremos un m\'etodo en este libro, escribiremos el nombre del m\'etodo en esta forma. Por supuesto, cuando escribas el c\'odigo en el navegador, no tendr\'as que escribir el nombre del a clase ni \ct{>>>}; solo aseg\'urate de que la clase correcta est\'a seleccionada en el panel de clases. 

Ahora definamos los otros dos m\'etodos que son usados por el m\'etodo \ct{LOGame>>>initialize}. Ambos pueden ir dentro del protocolo \prot{initialization}.

\begin{method}[sbegamecellsperside]{Un m\'etodo constante.}
LOGame>>>cellsPerSide
   "The number of cells along each side of the game"
   ^ 10
\end{method}
\cmindex{LOGame}{cellsPerSide}
\index{constant methods}

Este m\'etodo no podr\'ia ser m\'as simple: responde con la constante 10. Una ventaja de representar constantes con m\'etodos es que si el programa evoluciona de manera que la constante depende de otras caracter\'isticas, el m\'etodo puede ser cambiado para calcular el nuevo valor. 

\needlines{10}
\begin{method}[newCellAt:at:]{Un m\'etodo de inicializaci\'on}
LOGame>>>newCellAt: i at: j
   "Create a cell for position (i,j) and add it to my on-screen
   representation at the appropriate screen position.  Answer the new cell"
   | c origin |
   c := LOCell new.
   origin := self innerBounds origin.
   self addMorph: c.
   c position: ((i - 1) * c width) @ ((j - 1) * c height) + origin.
   c mouseAction: [self toggleNeighboursOfCellAt: i at: j]
\end{method}
\cmindex{LOGame}{newCellAt:at:}

\dothis{Agrega los m\'etodos \ct{LOGame>>>cellsPerSide} y \ct{LOGame>>>newCellAt:at:}.}
Confirma la pronunciaci\'on de los nuevos m\'etodos \ct{toggleNeighboursOfCellAt:at:} y \ct{mouseAction:}.

\Mthref{newCellAt:at:} devuelve una nueva LOCell, especializada en la posici\'on \ct{(i,j)} en la \clsind{Matriz} de celdas.
La \'ultima l\'inea define el \ct{mouseAction} de la nueva celda como el \emph{bloque}
\mbox{\lct{[self toggleNeighboursOfCellAt: i at: j ]}.}
En efecto, esto define el comportamiento callback cuando se hace clic con el rat\'on. 
El m\'etodo correspondiente tambi\'en tiene que ser definido. 

\begin{method}[toggleNeighboursOfCellAt:at:]{The callback method}
LOGame>>>toggleNeighboursOfCellAt: i at: j
   (i > 1) ifTrue: [ (cells at: i - 1 at: j ) toggleState].
   (i < self cellsPerSide) ifTrue: [ (cells at: i + 1 at: j) toggleState].
   (j > 1) ifTrue: [ (cells at: i  at: j - 1) toggleState].
   (j < self cellsPerSide) ifTrue: [ (cells at: i at: j + 1) toggleState].
\end{method}
\cmindex{LOGame}{toggleNeighboursOfCellAt:at:}

\Mthref{toggleNeighboursOfCellAt:at:} cambia el estado de las cuatro celdas al norte, sur, este y oeste de una celda (\ct{i}, \ct{j}). La \'unica complicaci\'on es que el tablero es finito, por lo que tenemos que asegurarnos que las celdas vecinas existen antes que cambiemos su estado. 

\dothis{Coloca este m\'etodo en un nuevo protocolo llamado \prot{game logic}. (\Actclick en el panel de protocolo para agregar un nuevo protocolo.)}
Para mover el m\'etodo, puedes hacer clic en su nombre y arrastrarlo dentro del nuevo protocolo (\figref{dragMethod}).

\begin{figure}[htbp]
   \centering
   \ifluluelse
		{\includegraphics[width=\textwidth]{DragMethod} }
		{\includegraphics[scale=0.7]{DragMethod} }
   \caption{Arrastra un m\'etodo a un protocolo.\figlabel{dragMethod}}
\end{figure}

Para completar el juego Lights Out, necesitamos definir dos m\'etodos m\'as en la clase \ct{LOCell} para manejar los eventos del rat\'on.

\begin{method}[mouseAction:]{Un m\'etodo setter t\'ipico}
LOCell>>>mouseAction: aBlock
   ^ mouseAction := aBlock
\end{method}
\cmindex{LOCell}{mouseAction:}

\Mthref{mouseAction:} no hace nada m\'as que establecer la variable \ct{mouseAction} de la celda al argumento, y luego retorna el nuevo valor.

Cualquier m\'etodo que \emph{cambie} el valor de una variable de instancia de esta manera se llama \emph{m\'etodo setter}; un m\'etodo que \emph{retorna} el valor actual de una variable de instancia se llama \emph{m\'etodo getter}.
\seeindex{setter method}{accessor}
\seeindex{getter method}{accessor}

Si est\'as acostumbrado a los getters y setters en otros lenguajes, podr\'ias esperar que estos m\'etodos se  llamen \ct{setmouseAction} and \ct{getmouseAction}.
La convenci\'on \st es diferente. 
Un getter siempre tiene el mismo nombre que la variable que devuelve, y un setter siempre es llamado de manera similar, pero con un ``\ct{:}'' al final, por lo que queda \ct{mouseAction} and \ct{mouseAction:}.

Colectivamente, los setters y getters son llamados m\'etodos \emphind{de acceso}, y por convenci\'on deber\'ian ser colocados en el protocolo \protind{accessing}.
En Smalltalk, \emph{todas} las variables de instancia son privadas para el objeto que las posee, por lo que la \'unica manera de leer o escribir esas variables para otro objeto en el lenguaje Smalltalk es a trav\'es de los m\'etodos de acceso como este\footnote{En realidad, las variables de instancia tambi\'en pueden ser accedidas desde las subclases.}.

\dothis{Ve a la clase \ct{LOCell}, define \ct{LOCell>>>mouseAction:} y ponlo en el protocolo \prot{accessing}.}

Finalmente, necesitamos definir un m\'etodo \ct{mouseUp:}; este ser\'a llamado autom\'aticamente por el GUI framework  si el bot\'on del rat\'on es soltado cuando el rat\'on est\'a sobre la celda en la pantalla.

\begin{method}[sbecellmouseup]{Un manejador de eventos}
LOCell>>>mouseUp: anEvent
   mouseAction value
\end{method}
\cmindex{LOCell}{mouseUp:}

\dothis{Agrega el m\'etodo \ct{LOCell>>>mouseUp:} y luego
  \menu{categorize automatically} los m\'etodos.}
\index{method!categorize}

Lo que hace este m\'etodo es enviar el mensaje \ct{value} al objeto almacenado en la variable de instancia \ct{mouseAction}.
Recuerda que en \ct{LOGame>>>newCellAt: i at: j} asignamos el siguiente fragmento de c\'odigo a \ct{mouseAction}:

\ct{[self toggleNeighboursOfCellAt: i at: j ]} 

\noindent
Enviar el mensaje \ct{value} provoca que este fragmento de c\'odigo sea evaluado, y consecuentemente el estado de las celdas cambiar\'a. 

%=================================================================
\section{Probemos nuestro c\'odigo}

Eso es: !`el juego Lights Out est\'a completo!

Si has seguido todos los pasos, deber\'ias poder jugar el juego, que consiste en solo 2 clases y 7 m\'etodos.

\dothis{En un workspace, tipea \ct{LOGame new openInWorld} y \menu{do it}.}

El juego se abrir\'a, y deber\'ias poder hacer clic en las celdas y ver como funciona. 

Bueno, demasiada teor\'ia\ldots{}
Cuando haces clic en una celda, una ventana de \emphind{notificaci\'on} llamada ventana \clsind{PreDebugWindow} aparece con un mensaje de error!
Como se muestra en \figref{lightsOutError}, dice \ct{MessageNotUnderstood: LOGame>>>toggleState}.

\begin{figure}[ht]
\ifluluelse
	{\centerline{\includegraphics[width=\textwidth]{Error}}}
	{\centerline{\includegraphics[scale=0.7]{Error}}}
\caption{'!Hay un bug en nuestro juego cuando se hace clic en nuestra celda!
\figlabel{lightsOutError}}
\end{figure}

\noindent
'多Qu\'e pas\'o? Para averiguarlo, usemos uno de las herramientas m\'as poderosas de Smalltalk: el \ind{debugger}.

\dothis{Haz clic en el bot\'on \menu{debug} en la ventana de notificaci\'on.}
El debugger aparecer\'a.
En la parte superior de la ventana del debugger puedes ver la pila de ejecuci\'on, mostrando todos los m\'etodos activos; seleccionando alguno de ellos se mostrar\'a, en el panel del medio, el c\'odigo Smalltalk ejecut\'andose en ese m\'etodo, con la parte que dispar\'o el error resaltada. 

\dothis{Has clic en la l\'inea etiquetada 
\ct{LOGame>>>toggleNeighboursOfCellAt:at:} (near the top).}
El debugger te mostrar\'a el \ind{contexto de ejecuci\'on} de este m\'etodo donde ocurri\'o el error (\figref{debugToggle}).

\begin{figure}[ht]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{Debugger}}}
	{\centerline {\includegraphics[scale=0.7]{Debugger}}}
\caption{El debugger, con el m\'etodo \ct{toggleNeighboursOfCell:at:}  seleccionado.
\figlabel{debugToggle}}
\end{figure}

En la parte inferior del debugger hay dos peque単as ventanas de inspecci\'on. A la izquierda, puedes inspeccionar el objeto receptor del mensaje que caus\'o que el mensaje seleccionado se ejecute, asi que pudes mirar aqu\'i para ver los valores de las variables de instancia.
A la derecha puedes inspeccionar un objeto que representa el m\'etodo que se est\'a ejecutando, asi que puedes mirar aqu\'i para ver los valores de los par\'ametros del m\'etodo y las variables temporales.

Usando el debugger, puedes ejecutar c\'odigo paso a paso, inspeccionar objetos en par\'ametros y variables locales, evaluar c\'odigo como lo puedes hacer en el workspace, y, m\'as sorprendente a\'un para los que est\'an acostumbrados a otros debuggers, '!cambiar el c\'odigo mientras est\'a siendo debuggeado! Algunos programadores Smalltalk programan en el debugger casi todo el tiempo, en lugar de usar el browser. La ventaja de esto es que puedes ver el m\'etodo que est\'as escribiendo como ser\'a ejecutado, con par\'ametros reales en el contexto de ejecuci\'on real.

En este caso podemos ver en la primera l\'inea del panel superior que el mensaje \ct{toggleState} fu\'e enviado a una instancia de \ct{LOGame}, cuando, claramente, deber\'ia haber sido una instancia de \lct{LOCell}.
El problema est\'a seguramente con la inicializaci\'on de la matriz \ct{cells}.
Explorando el c\'odigo de \cmind{LOGame}{initialize} nos muestra que \ct{cells} se llena con el valor de retorno de \ct{newCellAt:at:}, pero cuand miramos ese m\'etodo, '!vemos que no hay sentencia de retorno!
Por defecto, un m\'etodo retorna \ct{self}, que en el caso de \ct{newCellAt:at:} es de hecho una instancia de \ct{LOGame}.
\index{method!returning self}

\dothis{Cierra la ventana del debugger.
Agrega la expresi\'on ``\ct{^ c}'' al final del m\'etodo \ct{LOGame>>>newCellAt:at:} para que devuelva \ct{c}.
(Ver \mthref{newCellAt:at:nobug}.)}

% \needlines{6}
\begin{method}[newCellAt:at:nobug]{Fixing the bug.}
LOGame>>>newCellAt: i at: j
   "Create a cell for position (i,j) and add it to my on-screen
   representation at the appropriate screen position.  Answer the new cell"
   | c origin |
   c := LOCell new.
   origin := self innerBounds origin.
   self addMorph: c.
   c position: ((i - 1) * c width) @ ((j - 1) * c height) + origin.
   c mouseAction: [self toggleNeighboursOfCellAt: i at: j].
   ^ c
\end{method}
\cmindex{LOGame}{newCellAt:at:}

\noindent
Recuerda de \charef{quick} que la manera de hacer \ind{return} de un \subind{method}{valor} de un m\'etodo en Smalltalk es \ct{^}, que obtienes tipeando \verb|^|.
\index{^@{$\uparrow$}|see{return}}
% Verificar si esta bien esto del subind... como se puede traducir?

A menudo puedes arreglar el c\'odigo directamente en la ventaba del debugger y hacer clic en \menu{Proceed} para continuar corriendo la aplicaci\'on.
En nuestro caso, como el bug estaba en la inicializaci\'on de un objeto, y no en el m\'etodo que fall\'o, lo m\'as f\'acil
es cerrar la ventana de debug, destruir la intancia del juego ejecut\'andose (con el \subind{Morphic}{halo}), y crear una nueva.


\dothis{Do: \ct{LOGame new openInWorld} again.}

Ahora el juego deber\'ia funcionar correctamente... o casi. Si hacemos clic, y luego movemos el rat\'on antes de soltar el bot\'on, la celda sobre la que esta el rat\'o tambi\'en cambiar\'a. Resulta que esto es comportamiento que heredamos de \ct{SimpleSwitchMorph}. Podemos arreglar esto simplemente sobreescribiendo \ct{moseMove:} para que no haga nada:

% \needlines{6}
\begin{method}[mouseMove:]{Overriding mouse move actions.}
LOGame>>>mouseMove: anEvent
\end{method}

!`Finalmente terminamos!

%=================================================================
\section{Guardando y compartiendo c\'odigo Samalltalk}
\seclabel{Monticello}

Ahora que tienes el juego Lights Out funcionando, probablemente quieras guardarlo en alg\'un lugar para poder compartirlo con tus amigos. Por supuesto, puedes guardar tu im\'agen de \pharo completa, y mostrar tu primer programa ejecut\'andola, pero tus amigos probablemente tengan su propio c\'odigo en sus im\'agenes, y no quieran renunciar a eso para usar tu im\'agen. 
Lo que necesitas es una manera de sacar tu c\'odigo fuente fuera de tu im\'agen \pharo para que otros programadores puedan introducirla en las suyas. 

La manera m\'as sencilla de hacer esto es haciendo \emph{file out} a nuestro c\'odigo. El men\'u \actclick en el panel de Paquete te dar\'a la opci\'on \menu{various \go{} file out} de todo el paquete \scat{PBE-LightsOut}.
El archivo resultante es m\'as o menos humanamente legible, pero est\'a realmente pensado para computadoras, no humanos. 
Puedes enviar este archivo via email a tus amigos, y ellos pueden archivarlo dentro de sus propias im\'agenes \pharo, usando el explorador de archivos.
\seeindex{saving code}{categories}
\seeindex{category!filing out}{file, filing out}
\seeindex{class!filing out}{file, filing out}
\seeindex{method!filing out}{file, filing out}
\index{file!filing out}
%Ver si esto se traduce

\dothis{\Actclick en el paquete \scat{PBE-LightsOut} y has \menu{various \go{} file out} de los contenidos.}
Ahora deber\'ias encontrar un archivo llamado ``PBE-LightsOut.st'' en el mismo directorio del disco donde se encuentra tu im\'agen.
Da una mirada a este archivo con un editor de texto.

\dothis{Abre una nueva im\'agen de \pharo y usa la herramienta File Browser (\menu{Tools \ldots {\go} File Browser}) para hacer \menu{file in} al PBE-LightsOut.st fileout.
Verifica que el juego ahora funciona en la nueva im\'agen.}
\seeindex{category!filing in}{file, filing in}
\seeindex{class!filing in}{file, filing in}
\seeindex{method!filing in}{file, filing in}
\index{file!filing in}

\begin{figure}[ht]
\centerline {\includegraphics[width=\textwidth]{FileIn}}
\caption{Filing in c\'odigo fuente \pharo.
\figlabel{filein}}
\end{figure}


\subsection{Paquetes Monticello}
Por m\'as que los fileouts son una manera conveniente de tomar una fotograf\'ia del c\'odigo que has escrito, son definitivamente de ``la vieja escuela''.
As\'i como muchos proyectos open-source hallan mucho m\'as conveniente mantener su c\'odigo en un repositorio usando \ind{CVS}\footnote{\url{http://www.nongnu.org/cvs}} o \ind{Subversion}\footnote{\url{http://subversion.tigris.org}}, los programadores \pharo encuentran m\'as conveniente manejar su c\'odigo usando paquetes \ind{Monticello}.
Estos paquetes se representan como archivos con nombres terminados en \ct{.mcz}; son en realidad paquetes comprimidos en formato zip que contienen el c\'odigo completo de tu \ind{paquete}.

Usando el navegador de paquetes Monticello, puedes guardar paquetes en repositorios en varios tipos de servidores, incluyendo servidores FTP y HTTP; tambi\'en puedes escribir paquetes en un repositorio en un sistema de archivos local. 
Una copia de tu paquete se cachea siempre en tu disco duro local, en el directorio \emph{package-cache}.
Monticello te permite guardar m\'ultiples versiones de tu programa, mezclar versiones, volver a una versi\'on vieja, y ver las diferencias entre las versiones.

De hecho, Monticello es un sistema de control de versiones distribuido; esto significa que permite a los desarrolladores guardar su trabajo en diferentes lugares, no en un solo repositorio como es el caso de CVS o Subversion. 
\seeindex{package browser}{Monticello}
 

Tambi\'en puedes enviar un archivo \ct{.mcz} por email.
El receptor tendr\'a que ponerlo en su directorio \emph{package-cache}; Luego ser\'ra capaz de usar Monticello para navegar y cargarlo.

\dothis{Abre el navegador Monticello desde el men\'u \menu{World}.}
En el panel de la derecha del navegador (ver \figref{monticello1}) hay una lista de repositorios Monticello, que incluir\'a todos los repositorios desde los cuales fu\'e cargado c\'odigo en la im\'agen que est\'as usando.

\begin{figure}[hbt]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{MonticelloBrowser}}}
	{\centerline {\includegraphics[scale=0.7]{MonticelloBrowser}}}
\caption{El navegador Monticello.
\figlabel{monticello1}}
\end{figure}

Al principio de la lista en el navegador Monticello hay un repositorio en un directorio local llamado \emphind{package cache}, que guarda en cache copias de los paquetes que has cargado o publicado en la red. Este cache local es realmente \'util porque te permite guardar tu propio historial; tambi\'en te permite trabajar en lugares donde no tienes acceso a internet, o cuando la conexi\'on es lo tan lenta que no quieres guardar en un repositorioremoto con mucha frecuencia. 

\subsection{Guardando y cargando c\'odigo con Monticello.}

A la izquierda del navegador Monticello hay una lista de paquetes que tienen una versi\'on cargada en la im\'agen; los paquetes que han sido modificados desde que han sido cargados est\'an marcados con un asterisco. (Estos algunas veces son nombrados como paquetes \subind{package}{sucios}.) Si seleccionas un pquete, la lista de repositorios se restringe a aquellos repositorios que contienen una copia del paquete seleccionado.
\seeindex{*}{package, dirty}
\seeindex{dirty package}{package, dirty}

\dothis{Agrega el paquete \ct{PBE-LightsOut} a tu navegador Monticello usando el bot\'on \button{+Package} y escribe \ct{PBE-LightsOut}.}

\subsection{\ind{\sqsrc}: un \ind{SourceForge} para \pharo.} 

Pensamos que la mejor manera de guardar tu c\'odigo y compartirlo es creando una cuenta para tu proyecto en un servidor \sqsrc. \sqsrc es como SourceForge\footnote{\url{http://sourceforge.net}}: es un front-end web para un servidor Monticello HTTP que te permite manejar tus proyectos.
Hay un servidor \sqsrc p\'ublico en \url{http://www.squeaksource.com}, y hay una copia del c\'odigo en este libro en \url{http://www.squeaksource.com/PharoByExample.html}. Puedes mirar este proyecto con un navegador web, pero es m\'as productivo hacerlo desde dentro de \pharo, usando el navegador Monticello, que te permite manejar tus paquetes.

\dothis{Abre \url{http://www.squeaksource.com} en un navegador web.
Crea una cuenta y luego crea ("registra") un proyecto para el juego Lights Out.}
\sqsrc te mostrar\'a la informaci\'on que deber\'ias usar para agregar un repositorio usando Monticello.

Una vez que tu proyecto haya sido creado en \sqsrc, tienes que indicarle a tu sistema \pharo que lo use. 

\dothis{Con el paquete \ct{PBE-LightsOut} seleccionado, haz clic en el bot\'on \button{+Repository} en el navegador Monticello.}
Ver\'as una lista con los diferentes tipos de repositorios que est\'an disponibles; para agregar un reposotorio \sqsrc selecciona \menu{HTTP}. Podr\'as proveer la informaci\'on necesaria sobre el servidor. 
Debes copiar el plantilla mostrado para identificar tu proyecto \sqsrc, pegarlo en Monticello y proveer tus iniciales y contrase\~na:

\needlines{5}
\begin{code}{}
MCHttpRepository 
    location: 'http://www.squeaksource.com/!\emph{YourProject}!'
    user: '!\emph{yourInitials}!' 
    password: '!\emph{yourPassword}!'
\end{code}   

\noindent
Si provees iniciales y contrase\~na vac\'ias, tambi\'en puedes cargar el proyecto, pero no podr\'as actualizarlo:

\needlines{5}
\begin{code}{}
MCHttpRepository 
    location: 'http://www.squeaksource.com/!\emph{YourProject}!'
    user: '' 
    password: ''
\end{code}   

Una vez que hayas aceptado este plantilla, tu nuevo repositorio deber\'ia ser listado en el lado derecho del navegador Monticello. 

\begin{figure}[hbt]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{BrowseRepository}}}
	{\centerline {\includegraphics[scale=0.7]{BrowseRepository}}}
\caption{Navegando en un reposotorio Monticello
\figlabel{monticello3}}
\end{figure}

\dothis{Haz clic en el bont\'on \button{Save} para guardar una primera versi\'on de tu juego Lights Out en \sqsrc.}

Para cargar el paquete en tu im\'agen, primero debes seleccionar una versi\on particular. Puedes hacer esto en el navegador del reposotorio, que puedes abrir usando el bot\'on \button{Open} o el men\'u \actclick. Una vez que hayas seleccionado una versi\'on, podr\'as cargarla en tu im\'agen.

\dothis{Abre el reposotorio \ct{PBE-LightsOut} que acabas de guardar.}

Monticello tiene muchas m\'as capacidades, que ser\'an abordadas con m\'as profundidad en \charef{env}.
Tambi\'en puedes mirar la documentaci\'on en l\'inea de Monticello en \url{http://www.wiresong.ca/Monticello/}.

%=================================================================
\section{Res\'umen del cap\'itulo}
En este cap\'itulo has visto como crear categor\'ias, clases y m\'etodos. Has visto como usarel navegador, el inspector, el debugger y el navegador Monticello.

\begin{itemize}
  \item Las categor\'ias son grupos de clases relacionadas entre s\'i.
  \item Una nueva clase se crea enviando un mensaje a su superclase.
  \item Los protocolos son grupos de m\'etodos relacionados entre s\'i.
  \item Un nuevo m\'etodo se crea o modifica editando su definici\'on en el navegador y luego los cambios \emph{aceptando}.
  \item El inspector ofrece una GUI simple y multi-prop\'osito para inspeccionar e interactuar con objetos arbitrarios-
  \item El navegador detecta el uso de m\'etodos y variables no declarados, y ofrece posibles correcciones.
  \item El m\'etodo \ct{initialize} se ejecuta autom\'aticamente despu\'es de que un objeto es creado en \pharo. Puedesponer cualquier c\'odigo de inicializaci\'on ah\'i.
  \item El debugger provee una GUI de alto nivel para inspeccionar y modificar el estado de un programa en tiempo de ejecuci\'on.
  \item Puedes compartir c\'odigo fuente haciendo \emph{file out} de una categor\'ia.
  \item Una mejor manera de compartir c\'odigo es usando Monticello para manejar un reposotorio externo, por ejemplo definido como un proyecto \sqsrc.
\end{itemize}

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================
%=================================================================
%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:
